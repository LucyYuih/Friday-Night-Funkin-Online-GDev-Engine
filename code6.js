gdjs.PlayonlineCode = {};
gdjs.PlayonlineCode.localVariables = [];
gdjs.PlayonlineCode.idToCallbackMap = new Map();
gdjs.PlayonlineCode.GDJoinObjects1= [];
gdjs.PlayonlineCode.GDJoinObjects2= [];
gdjs.PlayonlineCode.GDJoinObjects3= [];
gdjs.PlayonlineCode.GDbackObjects1= [];
gdjs.PlayonlineCode.GDbackObjects2= [];
gdjs.PlayonlineCode.GDbackObjects3= [];
gdjs.PlayonlineCode.GDBFObjects1= [];
gdjs.PlayonlineCode.GDBFObjects2= [];
gdjs.PlayonlineCode.GDBFObjects3= [];
gdjs.PlayonlineCode.GDPlayer2textObjects1= [];
gdjs.PlayonlineCode.GDPlayer2textObjects2= [];
gdjs.PlayonlineCode.GDPlayer2textObjects3= [];
gdjs.PlayonlineCode.GDPlayer1textObjects1= [];
gdjs.PlayonlineCode.GDPlayer1textObjects2= [];
gdjs.PlayonlineCode.GDPlayer1textObjects3= [];
gdjs.PlayonlineCode.GDselesongtextObjects1= [];
gdjs.PlayonlineCode.GDselesongtextObjects2= [];
gdjs.PlayonlineCode.GDselesongtextObjects3= [];
gdjs.PlayonlineCode.GDsongselectedtextObjects1= [];
gdjs.PlayonlineCode.GDsongselectedtextObjects2= [];
gdjs.PlayonlineCode.GDsongselectedtextObjects3= [];
gdjs.PlayonlineCode.GDStartObjects1= [];
gdjs.PlayonlineCode.GDStartObjects2= [];
gdjs.PlayonlineCode.GDStartObjects3= [];
gdjs.PlayonlineCode.GDBFPixelObjects1= [];
gdjs.PlayonlineCode.GDBFPixelObjects2= [];
gdjs.PlayonlineCode.GDBFPixelObjects3= [];
gdjs.PlayonlineCode.GDHardObjects1= [];
gdjs.PlayonlineCode.GDHardObjects2= [];
gdjs.PlayonlineCode.GDHardObjects3= [];
gdjs.PlayonlineCode.GDBackObjects1= [];
gdjs.PlayonlineCode.GDBackObjects2= [];
gdjs.PlayonlineCode.GDBackObjects3= [];
gdjs.PlayonlineCode.GDJoin2Objects1= [];
gdjs.PlayonlineCode.GDJoin2Objects2= [];
gdjs.PlayonlineCode.GDJoin2Objects3= [];
gdjs.PlayonlineCode.GDStatisticsObjects1= [];
gdjs.PlayonlineCode.GDStatisticsObjects2= [];
gdjs.PlayonlineCode.GDStatisticsObjects3= [];
gdjs.PlayonlineCode.GDComboNumbersObjects1= [];
gdjs.PlayonlineCode.GDComboNumbersObjects2= [];
gdjs.PlayonlineCode.GDComboNumbersObjects3= [];
gdjs.PlayonlineCode.GDNotesSplashObjects1= [];
gdjs.PlayonlineCode.GDNotesSplashObjects2= [];
gdjs.PlayonlineCode.GDNotesSplashObjects3= [];
gdjs.PlayonlineCode.GDfpsObjects1= [];
gdjs.PlayonlineCode.GDfpsObjects2= [];
gdjs.PlayonlineCode.GDfpsObjects3= [];
gdjs.PlayonlineCode.GDEngineTextObjects1= [];
gdjs.PlayonlineCode.GDEngineTextObjects2= [];
gdjs.PlayonlineCode.GDEngineTextObjects3= [];
gdjs.PlayonlineCode.GDLongUpscrollBFObjects1= [];
gdjs.PlayonlineCode.GDLongUpscrollBFObjects2= [];
gdjs.PlayonlineCode.GDLongUpscrollBFObjects3= [];
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects1= [];
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects2= [];
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects3= [];
gdjs.PlayonlineCode.GDHitboxLeftObjects1= [];
gdjs.PlayonlineCode.GDHitboxLeftObjects2= [];
gdjs.PlayonlineCode.GDHitboxLeftObjects3= [];
gdjs.PlayonlineCode.GDHitboxDownObjects1= [];
gdjs.PlayonlineCode.GDHitboxDownObjects2= [];
gdjs.PlayonlineCode.GDHitboxDownObjects3= [];
gdjs.PlayonlineCode.GDHitboxUpObjects1= [];
gdjs.PlayonlineCode.GDHitboxUpObjects2= [];
gdjs.PlayonlineCode.GDHitboxUpObjects3= [];
gdjs.PlayonlineCode.GDhitrightObjects1= [];
gdjs.PlayonlineCode.GDhitrightObjects2= [];
gdjs.PlayonlineCode.GDhitrightObjects3= [];
gdjs.PlayonlineCode.GDBFIconObjects1= [];
gdjs.PlayonlineCode.GDBFIconObjects2= [];
gdjs.PlayonlineCode.GDBFIconObjects3= [];
gdjs.PlayonlineCode.GDPauseButtonObjects1= [];
gdjs.PlayonlineCode.GDPauseButtonObjects2= [];
gdjs.PlayonlineCode.GDPauseButtonObjects3= [];
gdjs.PlayonlineCode.GDPauseButton2Objects1= [];
gdjs.PlayonlineCode.GDPauseButton2Objects2= [];
gdjs.PlayonlineCode.GDPauseButton2Objects3= [];
gdjs.PlayonlineCode.GDBlackScreenObjects1= [];
gdjs.PlayonlineCode.GDBlackScreenObjects2= [];
gdjs.PlayonlineCode.GDBlackScreenObjects3= [];
gdjs.PlayonlineCode.GDPauseTextObjects1= [];
gdjs.PlayonlineCode.GDPauseTextObjects2= [];
gdjs.PlayonlineCode.GDPauseTextObjects3= [];
gdjs.PlayonlineCode.GDExitTextObjects1= [];
gdjs.PlayonlineCode.GDExitTextObjects2= [];
gdjs.PlayonlineCode.GDExitTextObjects3= [];
gdjs.PlayonlineCode.GDRestartTextObjects1= [];
gdjs.PlayonlineCode.GDRestartTextObjects2= [];
gdjs.PlayonlineCode.GDRestartTextObjects3= [];
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects1= [];
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects2= [];
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects3= [];
gdjs.PlayonlineCode.GDBfUpNoteObjects1= [];
gdjs.PlayonlineCode.GDBfUpNoteObjects2= [];
gdjs.PlayonlineCode.GDBfUpNoteObjects3= [];
gdjs.PlayonlineCode.GDBfDownNoteObjects1= [];
gdjs.PlayonlineCode.GDBfDownNoteObjects2= [];
gdjs.PlayonlineCode.GDBfDownNoteObjects3= [];
gdjs.PlayonlineCode.GDBfLeftNoteObjects1= [];
gdjs.PlayonlineCode.GDBfLeftNoteObjects2= [];
gdjs.PlayonlineCode.GDBfLeftNoteObjects3= [];
gdjs.PlayonlineCode.GDBfRightNoteObjects1= [];
gdjs.PlayonlineCode.GDBfRightNoteObjects2= [];
gdjs.PlayonlineCode.GDBfRightNoteObjects3= [];
gdjs.PlayonlineCode.GDOppIconObjects1= [];
gdjs.PlayonlineCode.GDOppIconObjects2= [];
gdjs.PlayonlineCode.GDOppIconObjects3= [];
gdjs.PlayonlineCode.GDtimerBarObjects1= [];
gdjs.PlayonlineCode.GDtimerBarObjects2= [];
gdjs.PlayonlineCode.GDtimerBarObjects3= [];
gdjs.PlayonlineCode.GDtimeObjects1= [];
gdjs.PlayonlineCode.GDtimeObjects2= [];
gdjs.PlayonlineCode.GDtimeObjects3= [];
gdjs.PlayonlineCode.GDtimerBar2Objects1= [];
gdjs.PlayonlineCode.GDtimerBar2Objects2= [];
gdjs.PlayonlineCode.GDtimerBar2Objects3= [];
gdjs.PlayonlineCode.GDRatinsPopUpObjects1= [];
gdjs.PlayonlineCode.GDRatinsPopUpObjects2= [];
gdjs.PlayonlineCode.GDRatinsPopUpObjects3= [];
gdjs.PlayonlineCode.GDLongNoteObjects1= [];
gdjs.PlayonlineCode.GDLongNoteObjects2= [];
gdjs.PlayonlineCode.GDLongNoteObjects3= [];
gdjs.PlayonlineCode.GDnotesObjects1= [];
gdjs.PlayonlineCode.GDnotesObjects2= [];
gdjs.PlayonlineCode.GDnotesObjects3= [];
gdjs.PlayonlineCode.GDOppLeftNoteObjects1= [];
gdjs.PlayonlineCode.GDOppLeftNoteObjects2= [];
gdjs.PlayonlineCode.GDOppLeftNoteObjects3= [];
gdjs.PlayonlineCode.GDOppDownNoteObjects1= [];
gdjs.PlayonlineCode.GDOppDownNoteObjects2= [];
gdjs.PlayonlineCode.GDOppDownNoteObjects3= [];
gdjs.PlayonlineCode.GDOppUpNoteObjects1= [];
gdjs.PlayonlineCode.GDOppUpNoteObjects2= [];
gdjs.PlayonlineCode.GDOppUpNoteObjects3= [];
gdjs.PlayonlineCode.GDOppRightNoteObjects1= [];
gdjs.PlayonlineCode.GDOppRightNoteObjects2= [];
gdjs.PlayonlineCode.GDOppRightNoteObjects3= [];
gdjs.PlayonlineCode.GDLongNoteOppObjects1= [];
gdjs.PlayonlineCode.GDLongNoteOppObjects2= [];
gdjs.PlayonlineCode.GDLongNoteOppObjects3= [];
gdjs.PlayonlineCode.GDStatistics2Objects1= [];
gdjs.PlayonlineCode.GDStatistics2Objects2= [];
gdjs.PlayonlineCode.GDStatistics2Objects3= [];


gdjs.PlayonlineCode.userFunc0x1be96a8 = function GDJSInlineCode(runtimeScene) {
"use strict";
// WATCHER (download-only) — adapta repo ativo via localStorage e usa lógica de manifest otimizado do Script A
(async function(runtimeScene){
  // --- REPO STORAGE / HELPERS (Copiado do Script A) ---
  const REPO_STORAGE_KEY = "gdjs_repo_list_v1";
  const ACTIVE_REPO_KEY = "gdjs_active_repo_id_v1";

  function defaultRepoEntry() {
    return { id: "official", name: "oficial (LucyYuih/gdev-custom-charts)", owner: "LucyYuih", repo: "gdev-custom-skins", branch: "main", enabled: true };
  }

  function loadRepoList() {
    try {
      const raw = localStorage.getItem(REPO_STORAGE_KEY);
      if (!raw) { const list = [defaultRepoEntry()]; localStorage.setItem(REPO_STORAGE_KEY, JSON.stringify(list)); return list; }
      return JSON.parse(raw);
    } catch (e) { const list = [defaultRepoEntry()]; localStorage.setItem(REPO_STORAGE_KEY, JSON.stringify(list)); return list; }
  }

  function getActiveRepo() {
    try {
      const id = localStorage.getItem(ACTIVE_REPO_KEY);
      const list = loadRepoList();
      let pick = list.find(r => r.id === id && r.enabled);
      if (!pick) pick = list.find(r => r.enabled) || list[0];
      return pick || defaultRepoEntry();
    } catch(e){ return defaultRepoEntry(); }
  }

  function buildManifestCdnUrl(entry) {
    if (!entry) return null;
    if (entry.manifestUrl) return entry.manifestUrl;
    if (entry.owner && entry.repo) return `https://cdn.jsdelivr.net/gh/${entry.owner}/${entry.repo}@${entry.branch}/manifest.json`;
    return null;
  }

  // --- small util helpers ---
  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
  function isAudioFile(name){ return /\.(mp3|ogg|wav|aac|m4a)$/i.test(name); }
  function isJsonFile(name){ return /\.json$/i.test(name); }
  function basenameNoExt(p){ if(!p) return ""; const s = p.split("/").pop(); return s.replace(/\.[^.]+$/, ""); }

  // --- FUNÇÕES PARA MANIFEST OTIMIZADO COM ÁUDIOS (Copiado do Script A) ---
  function getBaseUrl(manifest) {
    if (manifest && manifest._base) {
      return `https://cdn.jsdelivr.net/gh/${manifest._base}/`;
    }
    // Fallback para manifest legado
    const activeRepo = getActiveRepo();
    return `https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/`;
  }

  function parseManifestEntry(entry, baseUrl = "") {
    if (!entry) return null;
    
    // Se for array de strings (diretórios ou arquivos)
    if (Array.isArray(entry) && entry.length > 0 && typeof entry[0] === "string") {
      // Verificar se são diretórios (não contém ponto) ou arquivos (contém ponto)
      const firstItem = entry[0];
      if (firstItem.includes('.') || firstItem.includes('/')) {
        // São arquivos (nova estrutura otimizada)
        return {
          type: 'files',
          value: entry.map(filePath => {
            const fileName = filePath.split('/').pop();
            return {
              name: fileName,
              type: "file",
              url: baseUrl + filePath
            };
          })
        };
      } else {
        // São diretórios
        return {
          type: 'subdirs', 
          value: entry
        };
      }
    }
    
    // Se for objeto com subdirs e files (nova estrutura com áudios em pastas não-folhas)
    if (typeof entry === 'object' && entry !== null && !Array.isArray(entry)) {
      if (entry.subdirs && entry.files) {
        return {
          type: 'folder',
          subdirs: entry.subdirs,
          files: entry.files.map(filePath => {
            const fileName = filePath.split('/').pop();
            return {
              name: fileName,
              type: "file", 
              url: baseUrl + filePath
            };
          })
        };
      }
    }
    
    // Se for array de objetos (estrutura legada)
    if (Array.isArray(entry) && entry.length > 0 && typeof entry[0] === "object") {
      return {
        type: 'files',
        value: entry.map(item => ({
          name: item.n || item.name,
          type: "file",
          url: item.u || item.url
        }))
      };
    }
    
    return null;
  }

  // --- MANIFEST / GITHUB helpers (Copiado do Script A, simplificado para o watcher) ---
  async function tryManifestFromGameVar(runtimeScene) {
    try {
      if (typeof runtimeScene !== "undefined" && runtimeScene.getGame) {
        const gg = runtimeScene.getGame().getVariables();
        if (gg.has("manifestjson")) {
          const s = gg.get("manifestjson").getAsString();
          if (s && s.trim()) {
            try { return JSON.parse(s); } catch(e) { return null; }
          }
        }
      }
    } catch(e){}
    return null;
  }

  async function tryManifestFromProjectResource() {
    try {
      const tries = ["manifest.json","resources/manifest.json","res/manifest.json","./manifest.json"];
      for (const p of tries) {
        try { const r = await fetch(p, {cache:"no-cache"}); if (r.ok) { try { return await r.json(); } catch(e){} } } catch(e){}
      }
    } catch(e){}
    return null;
  }

  async function tryManifestFromCdnOf(entry) {
    try {
      const url = buildManifestCdnUrl(entry);
      if (!url) return null;
      const r = await fetch(url, {cache:"no-cache"});
      if (r.ok) return await r.json();
    } catch(e){}
    return null;
  }

  const _manifest_cache_by_repo = {};

  async function loadManifestPreferLocalFor(entry, runtimeScene) {
    const repoId = (entry && entry.id) ? entry.id : "__default__";
    if (typeof _manifest_cache_by_repo[repoId] !== "undefined") return _manifest_cache_by_repo[repoId];

    const a = await tryManifestFromGameVar(runtimeScene); if (a) { _manifest_cache_by_repo[repoId] = a; return a; }
    const b = await tryManifestFromProjectResource(); if (b) { _manifest_cache_by_repo[repoId] = b; return b; }
    const c = await tryManifestFromCdnOf(entry); if (c) { _manifest_cache_by_repo[repoId] = c; return c; }
    _manifest_cache_by_repo[repoId] = null;
    return null;
  }

  // A função ghListApi do watcher original é mantida, mas renomeada para evitar conflito
  async function ghListApi(path="") {
    const active = getActiveRepo();
    if (!active.owner || !active.repo) throw new Error("No active GH repo configured");
    const apiUrl = `https://api.github.com/repos/${active.owner}/${active.repo}/contents/${encodeURIComponent(path)}?ref=${active.branch || "main"}`;
    let token = "";
    try { token = localStorage.getItem("gdjs_github_token") || ""; } catch(e){}
    try { if ((!token || token.trim()==="") && runtimeScene && runtimeScene.getGame) { const gv = runtimeScene.getGame().getVariables(); if (gv.has("GitHubToken")) token = gv.get("GitHubToken").getAsString(); } } catch(e){}
    const headers = token ? { "Authorization": "token " + token } : {};
    const r = await fetch(apiUrl, { headers });
    if (!r.ok) throw new Error(`GitHub API: ${r.status}`);
    const json = await r.json();
    return json.map(item => ({ name: item.name, path: item.path, type: item.type, download_url: item.download_url || null }));
  }

  // --- Variáveis e Funções do Watcher Original (Mantidas) ---
  const gg = runtimeScene.getGame().getVariables();
  function getVarString(name){ try { return gg.get(name).getAsString(); } catch(e){ return ""; } }
  function setVarString(name, v){ try { gg.get(name).setString(String(v)); } catch(e){} }
  function ensureVarString(name, def=""){ try { if(!gg.has(name)) gg.get(name).setString(def); } catch(e){} }
  function ensureVarNumber(name, def=0){ try { if(!gg.has(name)) gg.get(name).setNumber(def); } catch(e){} }
  function getVarNumber(name){ try { return gg.get(name).getAsNumber(); } catch(e){ return 0; } }
  function setVarNumber(name, n){ try { gg.get(name).setNumber(Number(n) || 0); } catch(e){} }

  ensureVarString("selectedTrackKey","");
  ensureVarString("BfChartJsonLoader","");
  ensureVarString("OppChartJsonLoader","");
  ensureVarString("metadatajson","");
  ensureVarString("SongName","");
  ensureVarNumber("jsmusicoffset",0);
  ensureVarNumber("jsmusicfinish",0);
  ensureVarNumber("Pause",0);

  ensureVarNumber("AllLoaded", 1);

  window.gdjsCustomAudio = window.gdjsCustomAudio || {};
  window.gdjsChannels = window.gdjsChannels || {};
  window._gdjs_manifest = window._gdjs_manifest || undefined; // Mantido para compatibilidade, mas não usado

  function stopAndCleanupAll(revokeBlobUrls = true){
    try {
      if (window.gdjsChannels) {
        Object.keys(window.gdjsChannels).forEach(k=>{
          try {
            const a = window.gdjsChannels[k];
            if (!a) return;
            try{ a.pause(); }catch(e){}
            try{ a.currentTime = 0; }catch(e){}
            if (a._gdjs_ended_handler) { try{ a.removeEventListener('ended', a._gdjs_ended_handler); }catch(e){} a._gdjs_ended_handler = null; }
            if (revokeBlobUrls && a.src && a.src.startsWith('blob:')) {
              try{ URL.revokeObjectURL(a.src); }catch(e){}
            }
          } catch(e){}
        });
      }
      if (window.gdjsCustomAudio) {
        Object.keys(window.gdjsCustomAudio).forEach(folder=>{
          try {
            const entry = window.gdjsCustomAudio[folder] || {};
            const audios = entry.audios || {};
            Object.keys(audios).forEach(name=>{
              try {
                const info = audios[name] || {};
                if (info && info.blobUrl && revokeBlobUrls) try{ URL.revokeObjectURL(info.blobUrl); }catch(e){}
              } catch(e){}
            });
            try{ delete window.gdjsCustomAudio[folder]; } catch(e){}
          } catch(e){}
        });
      }
    } catch(e){}
    window.gdjsChannels = {};
  }

  // Funções de Manifest do Watcher Original (Removidas/Substituídas)
  // tryManifestFromGameVar, tryManifestFromProjectResource, tryManifestFromCDN, loadManifestPreferLocal

  // --- NOVA LÓGICA DE LISTAGEM DE ARQUIVOS (Adaptada do Script A) ---
  async function getFilesFromManifest(folderPath, manifest, baseUrl) {
    if (!manifest || !manifest.hasOwnProperty(folderPath)) return [];
    
    const entry = manifest[folderPath];
    const parsed = parseManifestEntry(entry, baseUrl);

    if (parsed && parsed.type === 'files') {
      return parsed.value;
    }
    
    if (parsed && parsed.type === 'folder') {
      return parsed.files;
    }

    return [];
  }

  async function findAudioFilesWithFallback(rootFolder, difficultyPath) {
    const activeRepo = getActiveRepo();
    const manifest = await loadManifestPreferLocalFor(activeRepo, runtimeScene);
    const baseUrl = getBaseUrl(manifest);

    // 1. Tenta a pasta de dificuldade no manifest (estrutura otimizada)
    let list = await getFilesFromManifest(difficultyPath, manifest, baseUrl);
    if (list && list.length > 0) return list.filter(e => isAudioFile(e.name));

    // 2. Tenta a pasta raiz no manifest (estrutura otimizada)
    list = await getFilesFromManifest(rootFolder, manifest, baseUrl);
    if (list && list.length > 0) return list.filter(e => isAudioFile(e.name));

    // 3. Tenta a pasta pai no manifest (fallback do watcher original)
    const parts = (rootFolder || "").split("/").filter(Boolean);
    if (parts.length >= 2) {
      const modFolder = parts.slice(0, parts.length - 1).join("/");
      if (modFolder) {
        list = await getFilesFromManifest(modFolder, manifest, baseUrl);
        if (list && list.length > 0) return list.filter(e => isAudioFile(e.name));
      }
    }

    // 4. Fallback para GitHub API (ghListApi)
    try {
      const api = await (async ()=> { try { return await ghListApi(difficultyPath); } catch(e) { return []; } })();
      list = (api || []).filter(i => i.type !== "dir" && isAudioFile(i.name)).map(i => ({ name: i.name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`) }));
      if (list && list.length > 0) return list;
    } catch(e){}

    try {
      const api = await (async ()=> { try { return await ghListApi(rootFolder); } catch(e) { return []; } })();
      list = (api || []).filter(i => i.type !== "dir" && isAudioFile(i.name)).map(i => ({ name: i.name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`) }));
      if (list && list.length > 0) return list;
    } catch(e){}

    return [];
  }

  async function findJsonFilesWithFallback(rootFolder, difficultyPath) {
    const activeRepo = getActiveRepo();
    const manifest = await loadManifestPreferLocalFor(activeRepo, runtimeScene);
    const baseUrl = getBaseUrl(manifest);
    const allJsonsMap = {};

    // Função auxiliar para processar arquivos encontrados
    function processFiles(files, origin) {
      (files || []).filter(e => isJsonFile(e.name)).forEach(e => {
        if (!allJsonsMap[e.name]) {
          allJsonsMap[e.name] = { name: e.name, url: e.url, origin: origin };
        }
      });
    }

    // 1. Tenta a pasta de dificuldade no manifest (estrutura otimizada)
    processFiles(await getFilesFromManifest(difficultyPath, manifest, baseUrl), difficultyPath);

    // 2. Tenta a pasta raiz no manifest (estrutura otimizada)
    processFiles(await getFilesFromManifest(rootFolder, manifest, baseUrl), rootFolder);

    // 3. Fallback para GitHub API (ghListApi)
    try {
      const api = await (async ()=> { try { return await ghListApi(difficultyPath); } catch(e){ return []; } })();
      (api || []).filter(i=> i.type !== "dir" && isJsonFile(i.name)).forEach(i => {
        const name = i.name;
        if (!allJsonsMap[name]) {
          allJsonsMap[name] = { name: name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`), origin: difficultyPath };
        }
      });
    } catch(e){}

    try {
      const api = await (async ()=> { try { return await ghListApi(rootFolder); } catch(e){ return []; } })();
      (api || []).filter(i=> i.type !== "dir" && isJsonFile(i.name)).forEach(i=> {
        const name = i.name;
        if (!allJsonsMap[name]) {
          allJsonsMap[name] = { name: name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`), origin: rootFolder };
        }
      });
    } catch(e){}

    return Object.values(allJsonsMap);
  }

  // --- Funções de Download e UI (Mantidas) ---
  function attachEndedWatcherToChannel0(){
    const ch0 = window.gdjsChannels && window.gdjsChannels[0];
    if (!ch0) return;
    if (ch0._gdjs_ended_handler) { try{ ch0.removeEventListener('ended', ch0._gdjs_ended_handler); }catch(e){} ch0._gdjs_ended_handler = null; }
    ch0.loop = false;
    const handler = ()=> { setVarNumber("jsmusicfinish", 1); };
    ch0.addEventListener('ended', handler);
    ch0._gdjs_ended_handler = handler;
  }
  async function ensureAudioContext(){
    try {
      if (!window._gdjs_audio_ctx) window._gdjs_audio_ctx = new (window.AudioContext || window.webkitAudioContext)();
      const ctx = window._gdjs_audio_ctx;
      if (ctx.state === "suspended") { try { await ctx.resume(); } catch(e){} }
      Object.keys(window.gdjsChannels).forEach(k=>{
        try {
          const a = window.gdjsChannels[k];
          if (!a) return;
          if (!a._gdjs_connected_to_audioctx) {
            const source = ctx.createMediaElementSource(a);
            const gain = ctx.createGain();
            source.connect(gain);
            gain.connect(ctx.destination);
            a._gdjs_connected_to_audioctx = true; a._gdjs_gain_node = gain;
          } else if (a._gdjs_gain_node) { a._gdjs_gain_node.gain.value = 1.0; }
        } catch(e){}
      });
    } catch(e){}
  }

  async function fetchAsBlob(url, signal){
    const resp = await fetch(url, { signal });
    if (!resp.ok) throw new Error(`Fetch ${url} failed ${resp.status}`);
    return await resp.blob();
  }
  async function fetchAsText(url, signal){
    const resp = await fetch(url, { signal });
    if (!resp.ok) throw new Error(`Fetch ${url} failed ${resp.status}`);
    return await resp.text();
  }

  const OVERLAY_ID = "gdjs-download-overlay";
  function showDownloadOverlay(message){
    try {
      let ov = document.getElementById(OVERLAY_ID);
      if (ov) {
        const msgEl = ov.querySelector(".gdjs-download-msg");
        if (msgEl) msgEl.textContent = message || "Baixando...";
        return;
      }
      ov = document.createElement("div");
      ov.id = OVERLAY_ID;
      Object.assign(ov.style, {
        position: "fixed", left: "0", top: "0", right: "0", bottom: "0",
        zIndex: 2000000, background: "rgba(0,0,0,0.6)",
        display: "flex", alignItems: "center", justifyContent: "center",
        pointerEvents: "auto"
      });
      const box = document.createElement("div");
      Object.assign(box.style, { width: "360px", padding: "16px", borderRadius: "10px", background: "#0b0b0b", color: "#eee", textAlign: "center", boxShadow: "0 12px 40px rgba(0,0,0,0.6)" });
      box.innerHTML = `<div style="font-weight:700;margin-bottom:10px">Baixando...</div>
                       <div class="gdjs-download-msg" style="margin-bottom:12px">` + (message || "Aguarde — baixando recursos") + `</div>
                       <div style="font-size:13px;opacity:0.85">Esta janela fecha automaticamente quando o download terminar.</div>
                       <div style="margin-top:12px"><div class="gdjs-spinner" style="width:36px;height:36px;border-radius:50%;border:4px solid rgba(255,255,255,0.08);border-top-color:rgba(255,255,255,0.5);margin:10px auto;animation:gdjs-spin 1s linear infinite"></div></div>`;
      const style = document.createElement("style");
      style.textContent = `@keyframes gdjs-spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}`;
      document.head.appendChild(style);
      ov.appendChild(box);
      document.body.appendChild(ov);
    } catch(e){}
  }
  function hideDownloadOverlay(){
    try {
      const ov = document.getElementById(OVERLAY_ID);
      if (ov) ov.remove();
    } catch(e){}
  }

  async function downloadAndPrepareFolderFlexible(folderPathOrRoot, outerController, opts){
    const ctrl = outerController;
    const difficultyName = opts && opts.difficultyName ? opts.difficultyName : null;

    try {
      stopAndCleanupAll(true);

      const rootFolder = (() => {
        if (difficultyName) return folderPathOrRoot;
        const parts = (folderPathOrRoot || "").split("/").filter(Boolean);
        if (parts.length >= 3) return parts.slice(0, parts.length - 1).join("/");
        return folderPathOrRoot;
      })();

      let inferredDifficulty = difficultyName;
      if (!inferredDifficulty && (folderPathOrRoot || "").split("/").filter(Boolean).length >= 3) {
        const parts = (folderPathOrRoot || "").split("/").filter(Boolean);
        inferredDifficulty = parts.slice(-1)[0];
      }

      try { setVarString("SongName", basenameNoExt((rootFolder || "").split("/").pop()||"")); } catch(e){}
      try { runtimeScene.getGame().getVariables().get("selectedTrackKey").setString(folderPathOrRoot); } catch(e){}

      setVarNumber("AllLoaded", 0);

      showDownloadOverlay("Preparando download...");

      // --- ALTERAÇÃO PRINCIPAL: Usar as novas funções de listagem ---
      const difficultyPath = (rootFolder? rootFolder + "/" + inferredDifficulty : inferredDifficulty);
      const audioFiles = await findAudioFilesWithFallback(rootFolder, difficultyPath);
      const allJsonsMap = await findJsonFilesWithFallback(rootFolder, difficultyPath);
      // --- FIM ALTERAÇÃO PRINCIPAL ---

      window.gdjsCustomAudio[rootFolder] = window.gdjsCustomAudio[rootFolder] || { audios: {}, rawFiles: {} };
      const dest = window.gdjsCustomAudio[rootFolder];

      let nextChannelIndex = 0;
      for (const f of (audioFiles || [])) {
        if (ctrl.signal.aborted) throw new Error("aborted");
        try {
          showDownloadOverlay(`Baixando áudio: ${f.name} ...`);
          const blob = await fetchAsBlob(f.url, ctrl.signal);
          const blobUrl = URL.createObjectURL(blob);

          const audioEl = new Audio();
          audioEl.preload = "auto";
          audioEl.crossOrigin = "anonymous";
          audioEl.loop = false;

          try { audioEl.src = blobUrl; } catch(e){}
          try { audioEl.pause(); } catch(e){}
          try { audioEl.currentTime = 0; } catch(e){}

          dest.audios[f.name] = { blobUrl, audioEl };
          window.gdjsChannels[nextChannelIndex] = audioEl;
          nextChannelIndex++;
          setVarString("SongName", setVarString || "" );
        } catch(e){
        }
        await sleep(0);
      }

      const ggvars = runtimeScene.getGame().getVariables();
      for (const j of allJsonsMap) {
        if (ctrl.signal.aborted) throw new Error("aborted");
        try {
          showDownloadOverlay(`Baixando chart: ${j.name} ...`);
          const txt = await fetchAsText(j.url, ctrl.signal);
          const storeKey = (j.origin && j.origin !== rootFolder ? (j.origin.split("/").pop() + "/" + j.name) : j.name);
          dest.rawFiles[storeKey] = txt;
          const lname = j.name.toLowerCase();
          if (/metadata|meta/.test(lname)) ggvars.get("metadatajson").setString(txt);
          else if (/(bf|chartbf|chart_bf)/.test(lname)) ggvars.get("BfChartJsonLoader").setString(txt);
          else if (/(dad|opp|opponent)/.test(lname)) ggvars.get("OppChartJsonLoader").setString(txt);
          else {
            try {
              const parsed = JSON.parse(txt);
              if (parsed && parsed.notes) {
                if (!ggvars.get("BfChartJsonLoader").getAsString()) ggvars.get("BfChartJsonLoader").setString(txt);
                else if (!ggvars.get("OppChartJsonLoader").getAsString()) ggvars.get("OppChartJsonLoader").setString(txt);
                else if (!ggvars.get("metadatajson").getAsString()) ggvars.get("metadatajson").setString(txt);
              } else {
                if (!ggvars.get("metadatajson").getAsString()) ggvars.get("metadatajson").setString(txt);
              }
            } catch(e){
              if (!ggvars.get("metadatajson").getAsString()) ggvars.get("metadatajson").setString(txt);
            }
          }
        } catch(e){
        }
        await sleep(0);
      }

      attachEndedWatcherToChannel0();
      await ensureAudioContext();
      setVarNumber("jsmusicfinish", 0);

      setVarNumber("AllLoaded", 1);
      hideDownloadOverlay();

      return { ok:true };
    } catch(err){
      try { stopAndCleanupAll(true); } catch(e){}
      setVarNumber("AllLoaded", 0);
      hideDownloadOverlay();
      return { ok:false, reason: err && err.message ? err.message : String(err) };
    }
  }

  let lastSelected = getVarString("selectedTrackKey") || "";
  let currentDownloadController = null;
  let currentDownloadId = 0;

  async function startIfNeededOnStartup(){
    const sel = getVarString("selectedTrackKey") || "";
    if (sel && sel.trim()) {
      currentDownloadId++;
      const myId = currentDownloadId;
      if (currentDownloadController) { try{ currentDownloadController.abort(); }catch(e){} }
      currentDownloadController = new AbortController();
      downloadAndPrepareFolderFlexible(sel, currentDownloadController, {}).then(res=>{
        if (myId !== currentDownloadId) return;
      }).catch(()=>{});
      lastSelected = sel;
    }
  }
  startIfNeededOnStartup();

  (function pollLoop(){
    try {
      const cur = getVarString("selectedTrackKey") || "";
      if (cur !== lastSelected) {
        lastSelected = cur;
        try { if (currentDownloadController) currentDownloadController.abort(); } catch(e){}
        currentDownloadId++;
        const myId = currentDownloadId;
        currentDownloadController = new AbortController();

        if (!cur || !cur.trim()) {
          stopAndCleanupAll(true);
          setVarNumber("AllLoaded", 1);
        } else {
          (async ()=>{
            setVarNumber("AllLoaded", 0);
            setVarNumber("jsmusicfinish", 0);
            try { setVarString("SongName", basenameNoExt((cur.split("/").pop()||cur))); } catch(e){}
            await downloadAndPrepareFolderFlexible(cur, currentDownloadController, {});
            if (myId === currentDownloadId) {
            }
          })().catch(()=>{});
        }
      }
    } catch(e){}
    requestAnimationFrame(pollLoop);
  })();

  (function rafLoop(){
    try {
      const ch0 = window.gdjsChannels && window.gdjsChannels[0];
      if (ch0) { const cur = ch0.currentTime || 0; setVarNumber("jsmusicoffset", cur); }
      const pauseVal = Number(getVarNumber("Pause") || 0);
      if (pauseVal) {
        Object.keys(window.gdjsChannels||{}).forEach(k=>{ try { const a = window.gdjsChannels[k]; if (a && !a.paused && !a.ended) a.pause(); } catch(e){} });
      } else {
      }
    } catch(e){}
    requestAnimationFrame(rafLoop);
  })();

})(runtimeScene);

};
gdjs.PlayonlineCode.userFunc0x28e4fd8 = function GDJSInlineCode(runtimeScene) {
"use strict";
// skin_watcher_online.js
// Watcher separado: observa SelectedSkin / SelectedDadSkin e aplica apenas quando mudarem.
// Mostra modal preta de baixa opacidade (z-index:1) durante download para bloquear inputs sob ela,
// mas deixa possível que janelas com z-index > 1 continuem sobre ela.

(function(){
  const JSDELIVR_PREFIX = "https://cdn.jsdelivr.net/gh";
  const DEFAULT_CDN_OWNER = "LucyYuih";
  const DEFAULT_CDN_REPO = "gdev-custom-skins";
  const DEFAULT_CDN_BRANCH = "main";

  function log(...s){ try { console.log("[skin-watcher]", ...s); } catch(e){} }
  function warn(...s){ try { console.warn("[skin-watcher]", ...s); } catch(e){} }
  function safeParseJson(s){ try { return JSON.parse(s); } catch(e){ return null; } }

  function encodePathForCdn(p){ return String(p).replace(/^\.\//,'').replace(/\\/g,'/').replace(/ /g,'%20'); }
  function buildCdnUrl(owner, repo, branch, path){ if (!owner || !repo) return null; const br = branch || "main"; return `${JSDELIVR_PREFIX}/${owner}/${repo}@${br}/${encodePathForCdn(path)}`; }

  async function fetchCdnFirst(pathOrUrl, as="arraybuffer", cdnBase=null){
    const isAbs = typeof pathOrUrl === "string" && (pathOrUrl.startsWith("http://") || pathOrUrl.startsWith("https://"));
    const tries = [];
    if (isAbs) tries.push(pathOrUrl);
    if (!isAbs && cdnBase && cdnBase.owner && cdnBase.repo){
      const c = buildCdnUrl(cdnBase.owner, cdnBase.repo, cdnBase.branch, pathOrUrl);
      if (c) tries.push(c);
    }
    tries.push(pathOrUrl);
    tries.push("resources/" + pathOrUrl);
    tries.push("./" + pathOrUrl);
    if (typeof pathOrUrl === "string"){
      const enc = pathOrUrl.replace(/ /g,"%20");
      tries.push(enc); tries.push("resources/" + enc); tries.push("./" + enc);
    }

    let lastErr = null;
    for (const u of tries){
      if (!u) continue;
      try {
        log("fetch try ->", u);
        const r = await fetch(u);
        if (!r.ok) throw new Error("Fetch failed " + r.status + " for " + u);
        if (as === "json") return await r.json();
        if (as === "blob") return await r.blob();
        return await r.arrayBuffer();
      } catch(e){
        lastErr = e;
        warn("fetch failed for", u, e && e.message ? e.message : e);
      }
    }
    throw lastErr || new Error("All fetch attempts failed");
  }

  // Helpers multiplayer (copiados/adaptados)
  function getPlayerOnlineValue(runtimeScene){
    try { const gv = runtimeScene.getGame().getVariables(); if (gv && gv.has("PlayerOnline")) { const n = gv.get("PlayerOnline").getAsNumber(); if (typeof n === 'number' && !isNaN(n)) return n; } } catch(e){}
    try { const sv = runtimeScene.getVariables(); if (sv && sv.has("PlayerOnline")) { const n = sv.get("PlayerOnline").getAsNumber(); if (typeof n === 'number' && !isNaN(n)) return n; } } catch(e){}
    try { if (typeof gdjs !== 'undefined' && gdjs.multiplayer && typeof gdjs.multiplayer.getCurrentPlayerNumber === 'function'){ const pn = gdjs.multiplayer.getCurrentPlayerNumber(); if (typeof pn === 'number') return pn === 1 ? 1 : 2; } } catch(e){}
    return 0;
  }
  function isLobbyRunning(runtimeScene){
    try { if (typeof gdjs !== 'undefined' && gdjs.multiplayer && typeof gdjs.multiplayer.isLobbyGameRunning === 'function') return !!gdjs.multiplayer.isLobbyGameRunning(runtimeScene); } catch(e){}
    try { const gv = runtimeScene.getGame().getVariables(); if (gv && gv.has("IsLobbyGameRunning")) return !!gv.get("IsLobbyGameRunning").getAsNumber(); if (gv && gv.has("LobbyGameIsRunning")) return !!gv.get("LobbyGameIsRunning").getAsNumber(); } catch(e){}
    try { const sv = runtimeScene.getVariables(); if (sv && sv.has("IsLobbyGameRunning")) return !!sv.get("IsLobbyGameRunning").getAsNumber(); } catch(e){}
    return false;
  }

  // Modal UI: baixa opacidade, bloqueia clique, z-index baixo (1)
  function createBlockingModal(){
    // evita duplicados
    if (document.getElementById("skin-watcher-modal")) return document.getElementById("skin-watcher-modal");

    const modal = document.createElement("div");
    modal.id = "skin-watcher-modal";
    modal.style.position = "fixed";
    modal.style.inset = "0";
    modal.style.background = "rgba(0,0,0,0.65)"; // baixa opacidade preta
    modal.style.display = "flex";
    modal.style.alignItems = "center";
    modal.style.justifyContent = "center";
    modal.style.zIndex = "1"; // INTENCIONAL: muito baixo para não sobrescrever outras janelas com z-index maior
    modal.style.pointerEvents = "auto"; // bloqueia toques abaixo
    modal.style.userSelect = "none";

    const panel = document.createElement("div");
    panel.style.padding = "14px 18px";
    panel.style.borderRadius = "8px";
    panel.style.background = "rgba(0,0,0,0.4)";
    panel.style.color = "#fff";
    panel.style.fontFamily = "Arial, sans-serif";
    panel.style.fontSize = "14px";
    panel.style.boxShadow = "0 6px 18px rgba(0,0,0,0.6)";
    panel.textContent = "Baixando skin...";

    const spinner = document.createElement("div");
    spinner.style.width = "36px";
    spinner.style.height = "36px";
    spinner.style.border = "4px solid rgba(255,255,255,0.2)";
    spinner.style.borderTopColor = "#fff";
    spinner.style.borderRadius = "50%";
    spinner.style.marginTop = "8px";
    spinner.style.animation = "skinWatcherSpin 1s linear infinite";

    const style = document.createElement("style");
    style.textContent = "@keyframes skinWatcherSpin { to { transform: rotate(360deg); } }";
    document.head.appendChild(style);

    panel.appendChild(spinner);
    modal.appendChild(panel);
    return modal;
  }
  function showBlockingModal(){
    const existing = document.getElementById("skin-watcher-modal");
    if (existing) return existing;
    const m = createBlockingModal();
    // inserir primeiro no body para z-index ser baixo (ninguém deve sobrescrever body content order)
    document.body.insertBefore(m, document.body.firstChild);
    return m;
  }
  function hideBlockingModal(){
    const m = document.getElementById("skin-watcher-modal");
    if (m && m.parentNode) m.parentNode.removeChild(m);
  }

  // Faz o download do zip (a partir de zip_cdn/zip) e aplica via GD_SKIN_PLAYER
  async function fetchAndApplySelection(runtimeScene, selStr, applyOpts){
    if (!selStr) return null;
    const parsed = safeParseJson(selStr);
    if (!parsed) return null;

    const candidates = [];
    if (parsed.zip_cdn) candidates.push(parsed.zip_cdn);
    if (parsed.zip) { candidates.push(parsed.zip); candidates.push("resources/" + parsed.zip); candidates.push("./" + parsed.zip); candidates.push(parsed.zip.replace(/ /g,"%20")); candidates.push("resources/" + parsed.zip.replace(/ /g,"%20")); }

    // tenter base via manifest se disponível
    try {
      let manifest = null;
      try { const r = await fetch("resources/manifestskins.json"); if (r.ok) manifest = await r.json(); } catch(e){}
      if (!manifest){
        const cdnTry = buildCdnUrl(DEFAULT_CDN_OWNER, DEFAULT_CDN_REPO, DEFAULT_CDN_BRANCH, "manifestskins.json");
        try { const r2 = await fetch(cdnTry); if (r2.ok) manifest = await r2.json(); } catch(e){}
      }
      if (manifest && manifest._base && parsed.zip){
        try {
          const [ownerRepo, branch] = manifest._base.split("@");
          const [owner, repo] = ownerRepo.split("/");
          const cdnBuilt = buildCdnUrl(owner, repo, branch || "main", parsed.zip);
          if (cdnBuilt) candidates.unshift(cdnBuilt);
        } catch(e){}
      }
    } catch(e){ warn("manifest detection failed:", e); }

    // cdn base fallback
    const cdnBase = { owner: DEFAULT_CDN_OWNER, repo: DEFAULT_CDN_REPO, branch: DEFAULT_CDN_BRANCH };

    let lastErr = null;
    for (const c of candidates){
      try {
        log("watcher fetching candidate ->", c);
        const arr = await fetchCdnFirst(c, "arraybuffer", cdnBase);
        if (!arr) throw new Error("Empty arrayBuffer");
        // show modal while applying
        showBlockingModal();
        try {
          if (!window.GD_SKIN_PLAYER || typeof window.GD_SKIN_PLAYER.loadFromArrayBuffer !== "function" || typeof window.GD_SKIN_PLAYER.applyPackageToScene !== "function"){
            throw new Error("GD_SKIN_PLAYER missing required functions");
          }
          const pkg = await window.GD_SKIN_PLAYER.loadFromArrayBuffer(runtimeScene, arr);
          const inst = await window.GD_SKIN_PLAYER.applyPackageToScene(runtimeScene, pkg, applyOpts || {});
          log("watcher applied package from", c);
          return inst;
        } finally {
          // always hide modal depois do attempt (se erro ou sucesso)
          hideBlockingModal();
        }
      } catch(e){
        lastErr = e;
        warn("watcher candidate failed", e && e.message ? e.message : e);
      }
    }
    warn("watcher: all candidates failed", lastErr);
    return null;
  }

  // Watcher principal (só executa ações quando variáveis mudarem)
  function createSkinWatcher(runtimeScene, opts){
    opts = opts || {};
    const pollInterval = (typeof opts.interval === "number") ? Math.max(150, opts.interval) : 600; // ms
    let last = { SelectedSkin: null, SelectedDadSkin: null };

    let intervalHandle = null;
    let running = false;

    async function tick(){
      try {
        const gv = runtimeScene.getGame().getVariables();
        if (!gv) return;

        // garante variáveis existam
        if (!gv.has('SelectedSkin')) gv.pushNew('SelectedSkin').setString('');
        if (!gv.has('SelectedDadSkin')) gv.pushNew('SelectedDadSkin').setString('');

        const cur = {
          SelectedSkin: gv.get('SelectedSkin').getAsString(),
          SelectedDadSkin: gv.get('SelectedDadSkin').getAsString()
        };

        const playerOnline = getPlayerOnlineValue(runtimeScene);
        const lobbyRunning = isLobbyRunning(runtimeScene);

        // SelectedSkin => BF (host); se local não for owner (playerOnline !== 1) então aplica a skin detectada do host
        if ((cur.SelectedSkin || '') !== (last.SelectedSkin || '')){
          log("Detected SelectedSkin change.");
          // Se local for host (playerOnline===1) normalmente não precisa rebaixar; mas se for player 2, deve baixar host's BF.
          if (playerOnline !== 1){
            // aplica BF localmente
            try {
              await fetchAndApplySelection(runtimeScene, cur.SelectedSkin, { targetName: "BF", targetAnimVar: "BFAnim" });
            } catch(e){ warn("Failed applying SelectedSkin via watcher", e); }
          } else {
            log("Local is player 1 -> SelectedSkin changed locally (no download needed).");
          }
          last.SelectedSkin = cur.SelectedSkin;
        }

        // SelectedDadSkin => Opponent (player2). If local is NOT player2, apply the opponent skin.
        if ((cur.SelectedDadSkin || '') !== (last.SelectedDadSkin || '')){
          log("Detected SelectedDadSkin change.");
          // If lobby is running and local is host (playerOnline === 1) skip applying opponent because in lobby host controls BF only.
          if (playerOnline === 1 && lobbyRunning){
            log("Lobby running + local host -> skipping SelectedDadSkin apply to avoid conflict.");
          } else {
            if (playerOnline !== 2){
              try {
                await fetchAndApplySelection(runtimeScene, cur.SelectedDadSkin, { targetName: "BFPixel", targetAnimVar: "OPPAnim" });
              } catch(e){ warn("Failed applying SelectedDadSkin via watcher", e); }
            } else {
              log("Local is player 2 -> SelectedDadSkin changed locally (no download needed).");
            }
          }
          last.SelectedDadSkin = cur.SelectedDadSkin;
        }
      } catch(e){
        warn("skinWatcher tick error:", e);
      }
    }

    function start(){
      if (running) return;
      // snapshot initial values to avoid immediate re-apply
      try {
        const gv = runtimeScene.getGame().getVariables();
        if (gv) {
          last.SelectedSkin = gv.has('SelectedSkin') ? gv.get('SelectedSkin').getAsString() : '';
          last.SelectedDadSkin = gv.has('SelectedDadSkin') ? gv.get('SelectedDadSkin').getAsString() : '';
        }
      } catch(e){}
      intervalHandle = setInterval(() => { tick().catch(e=>warn("tick outer:", e)); }, pollInterval);
      running = true;
      log("skin watcher started (pollInterval:", pollInterval, "ms)");
    }

    function stop(){
      if (!running) return;
      if (intervalHandle) clearInterval(intervalHandle);
      intervalHandle = null;
      running = false;
      log("skin watcher stopped");
    }

    return { start, stop, tickOnce: tick };
  }

  // Auto-start when runtimeScene fornecido (integração simples)
  // Para uso: inclua este arquivo e chame runtimeScene na inicialização da cena.
  window.__gd_skin_watcher = window.__gd_skin_watcher || {};
  window.__gd_skin_watcher._created = true;
  window.__gd_skin_watcher.createForScene = function(runtimeScene, options){
    if (!runtimeScene) throw new Error("runtimeScene required");
    // evita criar múltiplos watchers para a mesma cena
    if (window.__gd_skin_watcher._instance && window.__gd_skin_watcher._instance.running) return window.__gd_skin_watcher._instance;
    const w = createSkinWatcher(runtimeScene, options || {});
    w.start();
    window.__gd_skin_watcher._instance = w;
    return w;
  };

  // auto-boot if runtimeScene global pointer exists (convenience)
  try {
    if (typeof runtimeScene !== "undefined" && runtimeScene) {
      try { window.__gd_skin_watcher.createForScene(runtimeScene, { interval: 600 }); } catch(e){ warn("auto-create watcher failed", e); }
    } else if (window.__gd_runtimeScene_for_skin) {
      try { window.__gd_skin_watcher.createForScene(window.__gd_runtimeScene_for_skin, { interval: 600 }); } catch(e){ warn("auto-create watcher failed", e); }
    } else {
      log("skin-watcher loaded but no runtimeScene found. Call window.__gd_skin_watcher.createForScene(runtimeScene) to start.");
    }
  } catch(e){ warn("startup error", e); }

})();

};
gdjs.PlayonlineCode.eventsList0 = function(runtimeScene) {

{


gdjs.PlayonlineCode.userFunc0x1be96a8(runtimeScene);

}


{


gdjs.PlayonlineCode.userFunc0x28e4fd8(runtimeScene);

}


};gdjs.PlayonlineCode.eventsList1 = function(runtimeScene) {

{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = !(gdjs.multiplayer.isCurrentPlayerHost());
if (isConditionTrue_0) {
gdjs.copyArray(runtimeScene.getObjects("Start"), gdjs.PlayonlineCode.GDStartObjects1);
{for(var i = 0, len = gdjs.PlayonlineCode.GDStartObjects1.length ;i < len;++i) {
    gdjs.PlayonlineCode.GDStartObjects1[i].deleteFromScene(runtimeScene);
}
}

{ //Subevents
gdjs.PlayonlineCode.eventsList0(runtimeScene);} //End of subevents
}

}


};gdjs.PlayonlineCode.eventsList2 = function(runtimeScene) {

{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.playerAuthentication.isAuthenticated();
if (isConditionTrue_0) {
{gdjs.multiplayer.openLobbiesWindow(runtimeScene);
}
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = !(gdjs.playerAuthentication.isAuthenticated());
if (isConditionTrue_0) {
{gdjs.playerAuthentication.openAuthenticationWindow(runtimeScene);
}
}

}


};gdjs.PlayonlineCode.eventsList3 = function(runtimeScene) {

{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.playerAuthentication.isAuthenticated();
if (isConditionTrue_0) {
{gdjs.multiplayer.authenticateAndQuickJoinLobby(runtimeScene, true, true);
}
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = !(gdjs.playerAuthentication.isAuthenticated());
if (isConditionTrue_0) {
{gdjs.playerAuthentication.openAuthenticationWindow(runtimeScene);
}
}

}


};gdjs.PlayonlineCode.eventsList4 = function(runtimeScene) {

{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isCurrentPlayerHost();
if (isConditionTrue_0) {
{runtimeScene.getGame().getVariables().getFromIndex(17).setNumber(1);
}
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = !(gdjs.multiplayer.isCurrentPlayerHost());
if (isConditionTrue_0) {
gdjs.copyArray(runtimeScene.getObjects("selesongtext"), gdjs.PlayonlineCode.GDselesongtextObjects2);
{for(var i = 0, len = gdjs.PlayonlineCode.GDselesongtextObjects2.length ;i < len;++i) {
    gdjs.PlayonlineCode.GDselesongtextObjects2[i].deleteFromScene(runtimeScene);
}
}
{runtimeScene.getGame().getVariables().getFromIndex(17).setNumber(2);
}
}

}


{


let isConditionTrue_0 = false;
{
{gdjs.evtTools.camera.setCameraX(runtimeScene, gdjs.evtTools.camera.getCameraX(runtimeScene, "", 0) + (2220), "", 0);
}
{runtimeScene.getGame().getVariables().getFromIndex(63).getChild(2).setString("NoBotplay");
}
{gdjs.evtTools.storage.writeStringInJSONFile("Modifiers", "Botplay", "NoBotplay");
}
{runtimeScene.getGame().getVariables().getFromIndex(63).getChild(3).setString("NoMissesChallenge");
}
{gdjs.evtTools.storage.writeStringInJSONFile("Modifiers", "MissChallenge", "NoMissChallenge");
}
}

}


};gdjs.PlayonlineCode.userFunc0x19fb198 = function GDJSInlineCode(runtimeScene) {
"use strict";
// skin player
(function(){
  // --- CONFIGURAÇÃO GLOBAL E CACHE ---
  if (!window.GD_SKIN_CACHE) {
    window.GD_SKIN_CACHE = {
        zips: {},     
        textures: []  
    };
  }

  const JSZIP_CDN = "https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js";
  const JSDELIVR_PREFIX = "https://cdn.jsdelivr.net/gh";
  const PLAYER_GLOBAL = "__gd_skin_player"; 

  function log(...s){ console.log("[gd-skin-player]", ...s); }
  function warn(...s){ console.warn("[gd-skin-player]", ...s); }

  // --- SINGLETON DEFINITION ---
  if (!window.GD_SKIN_PLAYER_DEFINED) {
      
      async function ensureJSZip(){
        if (window.JSZip) return window.JSZip;
        if (window.JSZipLoadingPromise) return window.JSZipLoadingPromise;
        window.JSZipLoadingPromise = new Promise((res, rej) => {
          const s = document.createElement("script");
          s.src = JSZIP_CDN;
          s.onload = () => { window.JSZipLoadingPromise = null; res(window.JSZip); };
          s.onerror = () => { window.JSZipLoadingPromise = null; rej(new Error("Failed to load JSZip")); };
          document.head.appendChild(s);
        });
        return window.JSZipLoadingPromise;
      }

      function safeParseJson(s){ try { return JSON.parse(s); } catch(e){ return null; } }
      function encodePathForCdn(p){ return String(p).replace(/^\.\//,'').replace(/\\/g,'/').replace(/ /g,'%20'); }
      function buildCdnUrl(owner, repo, branch, path){ if(!owner||!repo) return null; const br = branch||"main"; return `${JSDELIVR_PREFIX}/${owner}/${repo}@${br}/${encodePathForCdn(path)}`; }

      function getObjectSize(obj){
        try {
          if (!obj) return {w:0,h:0};
          if (typeof obj.getWidth === "function" && typeof obj.getHeight === "function") return { w: obj.getWidth(), h: obj.getHeight() };
          const ro = obj.getRendererObject && obj.getRendererObject();
          if (ro) {
            if (typeof ro.width === "number" && typeof ro.height === "number") return { w: ro.width, h: ro.height };
            if (ro.getBounds && typeof ro.getBounds === "function") { const b = ro.getBounds(); return { w: b.width || 0, h: b.height || 0 }; }
          }
          return { w: 0, h: 0 };
        } catch(e){ return {w:0,h:0}; }
      }
      
      function getTexturePixelSize(tex){
        try {
          if (!tex) return {w:0,h:0};
          if (tex.frame) {
            if (tex.frame.width && tex.frame.height) return { w: tex.frame.width, h: tex.frame.height };
            if (tex.frame.realWidth && tex.frame.realHeight) return { w: tex.frame.realWidth, h: tex.frame.realHeight };
          }
          if (tex.baseTexture) {
            if (tex.baseTexture.realWidth && tex.baseTexture.realHeight) return { w: tex.baseTexture.realWidth, h: tex.baseTexture.realHeight };
            if (tex.baseTexture.width && tex.baseTexture.height) return { w: tex.baseTexture.width, h: tex.baseTexture.height };
          }
          if (typeof tex.width === "number" && typeof tex.height === "number") return { w: tex.width, h: tex.height };
          return {w:0,h:0};
        } catch(e){ return {w:0,h:0}; }
      }

      function findJsonAndBasePath(zip){
        const entries = Object.keys(zip.files);
        const candidates = [];
        for (const name of entries) {
          if (name.toLowerCase().endsWith(".json")) {
            const f = zip.files[name];
            const ts = (f && f.date && f.date instanceof Date) ? f.date.getTime() : 0;
            candidates.push({ name, ts });
          }
        }
        if (candidates.length === 0) throw new Error("Metadata JSON not found in ZIP");
        const metaMatches = candidates.filter(c => { const n = c.name.toLowerCase(); return n.endsWith("/metadata.json") || n.endsWith("metadata.json") || n.includes("metadata"); });
        let chosen;
        if (metaMatches.length) { metaMatches.sort((a,b) => b.ts - a.ts); chosen = metaMatches[0]; } 
        else { candidates.sort((a,b) => b.ts - a.ts); chosen = candidates[0]; }
        const parts = chosen.name.split("/");
        const baseFolderPrefix = parts.slice(0, parts.length - 1).join("/");
        return { jsonEntryName: chosen.name, baseFolderPrefix };
      }

      function groupImageEntries(entries, baseFolderPrefix, metadata){
        const groups = {};
        const animNames = (metadata && Array.isArray(metadata.animations)) ? metadata.animations.map(a=>a.anim) : [];
        if (animNames.length === 0) groups["idle"] = [];
        for (const anim of animNames) groups[anim] = [];
        for (const e of entries){
          let rel = e;
          if (baseFolderPrefix && e.startsWith(baseFolderPrefix + "/")) rel = e.slice(baseFolderPrefix.length + 1);
          for (const anim of animNames){
            const folderCheck1 = rel.startsWith(anim + "/");
            const folderCheck2 = metadata && metadata.image && rel.startsWith(metadata.image + "/" + anim + "/");
            const filename = rel.split("/").pop();
            const nameCheck = filename.toLowerCase().startsWith(anim.toLowerCase() + "_");
            if ((folderCheck1 || folderCheck2 || nameCheck) && /\.(png|jpg|jpeg|gif)$/i.test(filename)){
              groups[anim].push(e);
            }
          }
          if (animNames.length === 0 && /\.(png|jpg|jpeg|gif)$/i.test(e.split("/").pop())){ groups["idle"].push(e); }
        }
        for (const k of Object.keys(groups)) groups[k].sort((a,b)=>a.localeCompare(b, undefined, { numeric: true }));
        return groups;
      }

      async function loadTexturesFromZipEntries(zip, entryNames){
        const textures = [];
        for (const n of entryNames){
          try {
            const file = zip.file(n);
            if (!file) continue;
            const blob = await file.async("blob");
            const url = URL.createObjectURL(blob);
            const tex = PIXI.Texture.from(url);
            
            if(window.GD_SKIN_CACHE && window.GD_SKIN_CACHE.textures) window.GD_SKIN_CACHE.textures.push({ tex, url });

            await new Promise((resolve, reject) => {
              if (tex.baseTexture && tex.baseTexture.valid) return resolve();
              const checkValid = () => {
                if (tex.baseTexture && tex.baseTexture.valid) resolve();
                else setTimeout(checkValid, 10);
              };
              setTimeout(() => { if (tex.baseTexture && tex.baseTexture.valid) resolve(); else reject(new Error("Timeout texture")); }, 3000);
              checkValid();
            });
            textures.push({ tex, blobUrl: url, entryName: n });
          } catch(e){ warn("Failed load entry", n, e); }
        }
        return textures;
      }

      async function loadFromArrayBuffer(runtimeScene, arrayBuffer, opts = {}) {
        await ensureJSZip();
        const zip = await window.JSZip().loadAsync(arrayBuffer);
        let jsonEntryName, baseFolderPrefix;
        try { 
            const found = findJsonAndBasePath(zip); 
            jsonEntryName = found.jsonEntryName; baseFolderPrefix = found.baseFolderPrefix;
        } catch(e){ throw new Error("Metadata JSON not found: " + (e && e.message)); }

        let metadata;
        try { metadata = JSON.parse(await zip.file(jsonEntryName).async("string")); } 
        catch(e){ throw new Error("Failed reading metadata: " + (e && e.message)); }

        if (!window.GD_SKIN_PLAYER) window.GD_SKIN_PLAYER = {};
        window.GD_SKIN_PLAYER.lastDownloadedMetadata = metadata;

        const allEntries = Object.keys(zip.files);
        const groups = groupImageEntries(allEntries, baseFolderPrefix, metadata);
        const animations = {};
        
        for (const am of (metadata.animations || [])){
          animations[am.anim] = { name: am.anim, fps: am.fps||24, frames: [], loaded: false, loop: am.anim === "idle" };
        }
        if (Object.keys(animations).length === 0) animations["idle"] = { name:"idle", fps:24, frames:[], loaded:false, loop:true };
        
        // --- PRE-WARM ---
        for (const key of Object.keys(animations)){
          const entryNames = groups[key] || [];
          if (!entryNames.length) { animations[key].loaded = true; animations[key].frames = []; continue; }
          
          const loaded = await loadTexturesFromZipEntries(zip, entryNames);
          animations[key].frames = loaded.map(o => o.tex);
          animations[key].loaded = true;
          animations[key]._blobUrls = loaded.map(o => o.blobUrl);
          
          loaded.forEach(obj => {
             if(obj.tex && obj.tex.baseTexture) {
                 obj.tex.baseTexture.update(); 
             }
          });
        }
        log("Todas as animações foram pré-carregadas.");
        return { 
          animations, metadata, 
          _createdBlobUrls: (function collect(){ const arr=[]; for(const k of Object.keys(animations)){ const a=animations[k]; if (a._blobUrls) arr.push(...a._blobUrls); } return arr; })() 
        };
      }

      function computeCenterAndFeetForObject(obj){
        const size = getObjectSize(obj);
        const ro = (obj.getRendererObject && obj.getRendererObject()) || null;
        let anchorX = 0.5, anchorY = 0;
        try {
          if (ro) {
            if (ro.anchor && typeof ro.anchor.x === "number") { anchorX = ro.anchor.x; anchorY = ro.anchor.y; }
            else if (ro.pivot && typeof ro.pivot.x === "number" && typeof ro.width === "number") { anchorX = ro.pivot.x / (ro.width || 1); anchorY = ro.pivot.y / (ro.height || 1); }
          }
        } catch(e){}
        const gx = (typeof obj.getX === "function") ? obj.getX() : 0;
        const gy = (typeof obj.getY === "function") ? obj.getY() : 0;
        const centerX = gx + (0.5 - anchorX) * (size.w || 0);
        const feetY = gy + (1 - (typeof anchorY === "number" ? anchorY : 0)) * (size.h || 0);
        let pixelToSceneOriginal = 1;
        try {
          const tex = ro && (ro.texture || (ro.sprite && ro.sprite.texture));
          if (tex) { const texPx = getTexturePixelSize(tex); if (texPx && texPx.h > 0 && size.h > 0) pixelToSceneOriginal = size.h / texPx.h; }
        } catch(e){ }
        return { centerX, feetY, anchorX, anchorY, size, originalX: gx, originalY: gy, pixelToSceneOriginal };
      }

      async function applyPackageToScene(runtimeScene, packageObj, opts = {}) {
        const TARGET_NAME = (opts && opts.targetName) ? opts.targetName : "BF";
        
        // Anti-Flicker: Mata player anterior
        if (window[PLAYER_GLOBAL] && window[PLAYER_GLOBAL][TARGET_NAME]) {
            try { window[PLAYER_GLOBAL][TARGET_NAME].cleanup(); } catch(e){}
            window[PLAYER_GLOBAL][TARGET_NAME] = null;
        }

        const TARGET_ANIM_VAR = (opts && opts.targetAnimVar) ? opts.targetAnimVar : "BFAnim";
        const invertOffsetY = (typeof opts.invertOffsetY === "boolean") ? opts.invertOffsetY : false;
        const coordinateMode = (opts.coordinateMode === "raw") ? "raw" : "psych";

        const animations = packageObj.animations || {};
        const targetObjects = runtimeScene.getObjects(TARGET_NAME);
        if (!targetObjects || targetObjects.length === 0) { warn(TARGET_NAME + " not found."); return null; }

        const targetInfos = [];
        for (const obj of targetObjects) {
          try {
            const info = computeCenterAndFeetForObject(obj);
            let originalScaleX = 1;
            try {
              const ro = obj.getRendererObject && obj.getRendererObject();
              if (ro) {
                if (ro.scale && typeof ro.scale.x === "number") originalScaleX = ro.scale.x;
                else if (typeof ro.scaleX === "number") originalScaleX = ro.scaleX;
              }
            } catch(e){}
            const originalAbsScaleX = Math.abs(typeof originalScaleX === "number" && isFinite(originalScaleX) ? originalScaleX : 1) || 1;
            targetInfos.push({ 
              obj, centerX: info.centerX, feetY: info.feetY, anchorX: info.anchorX, anchorY: info.anchorY, 
              originalScaleX, originalAbsScaleX, pixelToSceneOriginal: (typeof info.pixelToSceneOriginal === "number" && isFinite(info.pixelToSceneOriginal)) ? info.pixelToSceneOriginal : 1
            });
          } catch(e){ }
        }

        const state = {
          current: "idle", frameIndex: 0, elapsed: 0, lastAnimValue: "", lastTick: performance.now(),
          _idleBeatTimeout: null, _returnToIdleTimeout: null, _createdBlobUrls: packageObj._createdBlobUrls || [], 
          _isPlayingSingAnimation: false, _idleTimerRunning: false, _watchdogCounter: 0
        };
        const meta = packageObj.metadata || {};
        
        let invertSideGlobal = false;
        const parseBoolean = (v) => {
          if (typeof v === "boolean") return v;
          if (typeof v === "number") return v !== 0;
          if (typeof v === "string") {
             const s = v.trim().toLowerCase();
             return (s === "true" || s === "1" || s === "yes");
          }
          return Boolean(v);
        };
        const oppSideBool = parseBoolean(meta.OPPSide);
        invertSideGlobal = (TARGET_NAME === "BFPixel") ? !oppSideBool : oppSideBool;

        function mapAnimToKey(rawAnim, invertSide){
          if (!rawAnim) return "";
          const v = rawAnim.toLowerCase();
          if (invertSide) {
            if (v.includes("left")) return "singRIGHT";
            if (v.includes("right")) return "singLEFT";
          } else {
            if (v.includes("left")) return "singLEFT";
            if (v.includes("right")) return "singRIGHT";
          }
          if (v.includes("down")) return "singDOWN";
          if (v.includes("up")) return "singUP";
          return rawAnim;
        }

        function applyFrameToAllObjects(tex){
          if (!targetInfos || targetInfos.length === 0) return;
          const texPixel = getTexturePixelSize(tex);
          for (const info of targetInfos) {
            const obj = info.obj;
            try {
              const ro = obj.getRendererObject && obj.getRendererObject();
              if (ro && ro.texture !== undefined) ro.texture = tex;
              else { try { obj.getRendererObject().texture = tex; } catch(e){} }

              const pixelToScene = (coordinateMode === "psych") ? ((typeof info.pixelToSceneOriginal === "number" && info.pixelToSceneOriginal > 0) ? info.pixelToSceneOriginal : 1) : 1;
              const scaledTexWidth = (texPixel.w || 0) * pixelToScene;
              const scaledTexHeight = (texPixel.h || 0) * pixelToScene;
              const targetFeetY = info.feetY;
              const targetCenterX = info.centerX;
              const anchorX = (typeof info.anchorX === "number") ? info.anchorX : 0.5;
              const anchorY = (typeof info.anchorY === "number") ? info.anchorY : 0;
              
              const targetObjX = targetCenterX - (0.5 - anchorX) * scaledTexWidth;
              const targetObjY = targetFeetY - (1 - anchorY) * scaledTexHeight;
              
              if (typeof obj.setX === "function") obj.setX(targetObjX);
              if (typeof obj.setY === "function") obj.setY(targetObjY);

              if (ro) {
                  const baseScale = (typeof info.originalAbsScaleX === "number" && info.originalAbsScaleX > 0) ? info.originalAbsScaleX : 1;
                  const wantScaleX = invertSideGlobal ? -baseScale : baseScale;
                  if (ro.scale && typeof ro.scale.x === "number") ro.scale.x = wantScaleX;
                  else if (typeof ro.scaleX === "number") ro.scaleX = wantScaleX;
              }
            } catch(e){ console.error("Error applying frame:", e); }
          }
        }

        if (animations.idle && animations.idle.frames && animations.idle.frames[0]) {
          applyFrameToAllObjects(animations.idle.frames[0]);
        }

        let rafHandle = null;
        function clearAllTimeouts(){ 
          if (state._idleBeatTimeout){ clearTimeout(state._idleBeatTimeout); state._idleBeatTimeout=null; } 
          if (state._returnToIdleTimeout){ clearTimeout(state._returnToIdleTimeout); state._returnToIdleTimeout=null; } 
          state._idleTimerRunning = false;
        }
        
        function animValueIsEmpty(s){
          if (s === null || s === undefined) return true;
          try { const st = String(s).trim().toLowerCase(); return st === "" || st === "idle"; } catch(e){ return true; }
        }

        function scheduleReturnToIdle(delayMs = 150){
          if (state._returnToIdleTimeout) clearTimeout(state._returnToIdleTimeout);
          state._idleTimerRunning = true;
          state._returnToIdleTimeout = setTimeout(()=>{
            state._returnToIdleTimeout = null;
            state._idleTimerRunning = false;
            state.current = "idle";
            state.frameIndex = 0;
            state.elapsed = 0;
            state._isPlayingSingAnimation = false;
            if (animations.idle && animations.idle.frames && animations.idle.frames[0]) {
              applyFrameToAllObjects(animations.idle.frames[0]);
            }
          }, delayMs);
        }

        let watchdogLastFrameIndex = null;
        let watchdogCounter = 0;
        const WATCHDOG_MAX_TICKS = 40;

        function tick(now){
          const dt = Math.min(60, now - (state.lastTick || now));
          state.lastTick = now;
          let currentAnim = "";
          try {
            const sv = runtimeScene.getVariables();
            const gv = runtimeScene.getGame().getVariables();
            if (sv && sv.has && sv.has(TARGET_ANIM_VAR)) currentAnim = sv.get(TARGET_ANIM_VAR).getAsString();
            else if (gv && gv.has && gv.has(TARGET_ANIM_VAR)) currentAnim = gv.get(TARGET_ANIM_VAR).getAsString();
          } catch(e){ currentAnim = ""; }
          
          if (!animValueIsEmpty(currentAnim) && currentAnim !== state.lastAnimValue){
            clearAllTimeouts();
            const key = mapAnimToKey(currentAnim, invertSideGlobal);
            if (animations[key] && animations[key].frames && animations[key].frames.length > 0){
              state.current = key; state.frameIndex = 0; state.elapsed = 0; 
              state._isPlayingSingAnimation = true; state._idleTimerRunning = false;
              watchdogLastFrameIndex = 0; watchdogCounter = 0;
              applyFrameToAllObjects(animations[key].frames[0]); 
            } else { scheduleReturnToIdle(120); }
          } else if (animValueIsEmpty(currentAnim) && state.current !== "idle" && !state._idleTimerRunning){
            scheduleReturnToIdle(150);
          }
          
          if (state._idleTimerRunning && !animValueIsEmpty(currentAnim)){ clearAllTimeouts(); }
          
          state.lastAnimValue = currentAnim;
          
          const anim = animations[state.current];
          if (anim && anim.frames && anim.frames.length > 0){
            const msPerFrame = 1000 / (anim.fps || 24);
            state.elapsed += dt;
            let frameChanged = false;
            while (state.elapsed >= msPerFrame && !frameChanged){
              state.elapsed -= msPerFrame;
              state.frameIndex++; 
              frameChanged = true;
              if (state.frameIndex >= anim.frames.length){
                if (anim.loop){
                   // --- CORREÇÃO DO LOOP IMEDIATO ---
                   // Mantém o último frame e espera um tempo (simulando beat) antes de reiniciar
                   state.frameIndex = anim.frames.length - 1; 
                   if (!state._idleBeatTimeout) {
                       const beatDelay = 650; // Ajuste este valor para mais rápido/lento (ms)
                       state._idleBeatTimeout = setTimeout(() => {
                           state._idleBeatTimeout = null;
                           state.current = "idle";
                           state.frameIndex = 0;
                           state.elapsed = 0;
                           if (animations.idle) applyFrameToAllObjects(animations.idle.frames[0]);
                       }, beatDelay);
                   }
                } else {
                  state.frameIndex = anim.frames.length - 1; 
                  if (state._isPlayingSingAnimation){ state._isPlayingSingAnimation = false; }
                }
              }
            }
            if (frameChanged){
              const tex = anim.frames[state.frameIndex];
              if (tex) applyFrameToAllObjects(tex);
              
              if (state.current !== "idle"){
                if (watchdogLastFrameIndex === state.frameIndex) watchdogCounter++;
                else watchdogCounter = 0;
                watchdogLastFrameIndex = state.frameIndex;
                if (watchdogCounter > WATCHDOG_MAX_TICKS){
                  clearAllTimeouts(); state.current = "idle"; state.frameIndex = 0; state.elapsed = 0;
                  if (animations.idle) applyFrameToAllObjects(animations.idle.frames[0]);
                }
              } else { watchdogCounter = 0; }
            }
          } else {
            if (state.current !== "idle") scheduleReturnToIdle(120);
          }
          rafHandle = requestAnimationFrame(tick);
        }
        rafHandle = requestAnimationFrame(tick);

        function cleanup(){
          if (rafHandle) cancelAnimationFrame(rafHandle);
          clearAllTimeouts();
          try { for (const b of state._createdBlobUrls){ try{ URL.revokeObjectURL(b); }catch(e){} } } catch(e){}
        }

        const instance = { animations, state, cleanup, target: TARGET_NAME };
        if (!window[PLAYER_GLOBAL]) window[PLAYER_GLOBAL] = {};
        window[PLAYER_GLOBAL][TARGET_NAME] = instance; 
        
        return instance;
      }

      function clearCache(){
          if(window.GD_SKIN_CACHE){
              window.GD_SKIN_CACHE.textures.forEach(item => {
                  try { if(item.tex) item.tex.destroy(true); if(item.url) URL.revokeObjectURL(item.url); } catch(e){}
              });
              window.GD_SKIN_CACHE.textures = [];
              window.GD_SKIN_CACHE.zips = {};
          }
          if(window[PLAYER_GLOBAL]){
             Object.keys(window[PLAYER_GLOBAL]).forEach(key => {
                 try{ if(window[PLAYER_GLOBAL][key]) window[PLAYER_GLOBAL][key].cleanup(); }catch(e){}
             });
          }
      }

      async function fetchAndCacheZip(url){
        if (window.GD_SKIN_CACHE && window.GD_SKIN_CACHE.zips[url]) return window.GD_SKIN_CACHE.zips[url];
        const r = await fetch(url);
        if (!r.ok) throw new Error("Fetch failed " + r.status);
        const arr = await r.arrayBuffer();
        if (window.GD_SKIN_CACHE) window.GD_SKIN_CACHE.zips[url] = arr;
        return arr;
      }

      async function autoApplySelectedSkin(runtimeScene, opts = {}) {
        let selStr = null;
        try { const gv = runtimeScene.getGame().getVariables(); if (gv.has("SelectedSkin")) selStr = gv.get("SelectedSkin").getAsString(); } catch(e){}
        if ((!selStr || selStr.trim() === "") && window.localStorage) try { selStr = localStorage.getItem("gd_selected_skin"); } catch(e){}
        if (!selStr) return null;
        const parsed = safeParseJson(selStr); if (!parsed) return null;

        const candidates = [];
        if (parsed.zip_cdn) candidates.push(parsed.zip_cdn);
        if (parsed.zip) { candidates.push(parsed.zip); candidates.push("resources/" + parsed.zip); candidates.push("./" + parsed.zip); }
        
        for (const c of candidates) {
          try {
            const arr = await fetchAndCacheZip(c);
            const pkg = await loadFromArrayBuffer(runtimeScene, arr);
            return await applyPackageToScene(runtimeScene, pkg, opts);
          } catch(err){}
        }
        return null;
      }

      async function autoApplySelectedDadSkin(runtimeScene, opts = {}) {
        let selStr = null;
        try { const gv = runtimeScene.getGame().getVariables(); if (gv.has("SelectedDadSkin")) selStr = gv.get("SelectedDadSkin").getAsString(); } catch(e){}
        if ((!selStr || selStr.trim() === "") && window.localStorage) try { selStr = localStorage.getItem("gd_selected_dad_skin"); } catch(e){}
        if (!selStr) return null;
        const parsed = safeParseJson(selStr); if (!parsed) return null;

        const candidates = [];
        if (parsed.zip_cdn) candidates.push(parsed.zip_cdn);
        if (parsed.zip) { candidates.push(parsed.zip); candidates.push("resources/" + parsed.zip); candidates.push("./" + parsed.zip); }
        
        for (const c of candidates) {
          try {
            const arr = await fetchAndCacheZip(c);
            const pkg = await loadFromArrayBuffer(runtimeScene, arr);
            return await applyPackageToScene(runtimeScene, pkg, { ...opts, targetName: "BFPixel", targetAnimVar: "OPPAnim" });
          } catch(err){}
        }
        return null;
      }

      window.GD_SKIN_PLAYER = Object.assign(window.GD_SKIN_PLAYER || {}, { 
        autoApplySelectedSkin, autoApplySelectedDadSkin, loadFromArrayBuffer, applyPackageToScene, clearCache, cleanup: clearCache 
      });
      window.GD_SKIN_PLAYER_DEFINED = true;
  }

  // --- AUTO EXECUÇÃO ---
  (async ()=>{
    try {
      let rs = null;
      try { if (typeof runtimeScene !== "undefined") rs = runtimeScene; } catch(e){}
      if (!rs && window.__gd_runtimeScene_for_skin) rs = window.__gd_runtimeScene_for_skin;
      if (!rs) return;

      await window.GD_SKIN_PLAYER.autoApplySelectedSkin(rs, { extraDefaults: { owner:"LucyYuih", repo:"gdev-custom-skins", branch:"main" } });
      await window.GD_SKIN_PLAYER.autoApplySelectedDadSkin(rs, { extraDefaults: { owner:"LucyYuih", repo:"gdev-custom-skins", branch:"main" } });
    } catch(e){}
  })();
})();
};
gdjs.PlayonlineCode.eventsList5 = function(runtimeScene) {

{


gdjs.PlayonlineCode.userFunc0x19fb198(runtimeScene);

}


};gdjs.PlayonlineCode.userFunc0x1c43458 = function GDJSInlineCode(runtimeScene) {
"use strict";
// skin loader
(async function(runtimeScene) {
  // --- CONSTANTES E UTILITÁRIOS ---
  const MANIFEST_NAME = "manifestskins.json";
  const JSDELIVR_PREFIX = "https://cdn.jsdelivr.net/gh";
  // URLs para fallback do manifesto
  const GITHUB_RAW_URL = `https://raw.githubusercontent.com/LucyYuih/gdev-custom-skins/main/${MANIFEST_NAME}`;
  const LOCAL_STORAGE_KEY = "skin_loader_manifest";

  function log(...s){ console.log("[skin-loader-multi]", ...s); }
  function warn(...s){ console.warn("[skin-loader-multi]", ...s); }

  // --- 1. FUNÇÕES DE LIMPEZA E CACHE (OTIMIZAÇÃO) ---
  function clearPixiTextureCache(skinName) {
    if (!window.PIXI) return;
    try {
        let count = 0;
        // Limpa TextureCache
        for (const key in PIXI.utils.TextureCache) {
            if (key.includes(skinName)) {
                try {
                    PIXI.utils.TextureCache[key].destroy(true);
                    delete PIXI.utils.TextureCache[key];
                    count++;
                } catch(e) {}
            }
        }
        // Limpa BaseTextureCache
        for (const key in PIXI.utils.BaseTextureCache) {
             if (key.includes(skinName)) {
                try { delete PIXI.utils.BaseTextureCache[key]; } catch(e) {}
            }           
        }
        log(`Cache PIXI limpo para "${skinName}". Texturas removidas: ${count}`);
    } catch (e) {
        warn("Erro ao limpar cache PIXI:", e);
    }
  }

  // --- 2. NETWORK HELPERS ---
  function encodePathForCdn(p){ return String(p).replace(/^\.\//,'').replace(/\\/g,'/').replace(/ /g,'%20'); }
  function buildCdnUrl(owner, repo, branch, path){ if (!owner || !repo) return null; const br = branch || "main"; return `${JSDELIVR_PREFIX}/${owner}/${repo}@${br}/${encodePathForCdn(path)}`; }

  async function fetchCdnFirst(pathOrUrl, as="json", cdnBase=null){
    const isAbs = typeof pathOrUrl === "string" && (pathOrUrl.startsWith("http://") || pathOrUrl.startsWith("https://"));
    const tries = [];
    if (isAbs) tries.push(pathOrUrl);
    if (!isAbs && cdnBase && cdnBase.owner && cdnBase.repo) {
      const c = buildCdnUrl(cdnBase.owner, cdnBase.repo, cdnBase.branch, pathOrUrl);
      if (c) tries.push(c);
    }
    tries.push(pathOrUrl);
    tries.push("resources/" + pathOrUrl);
    tries.push("./" + pathOrUrl);
    if (typeof pathOrUrl === "string") {
      const enc = pathOrUrl.replace(/ /g,"%20");
      tries.push(enc); tries.push("resources/" + enc);
    }

    let lastErr = null;
    for (const u of tries) {
      try {
        const r = await fetch(u);
        if (!r.ok) throw new Error("Fetch failed " + r.status + " for " + u);
        if (as === "json") return await r.json();
        if (as === "arraybuffer") return await r.arrayBuffer();
        if (as === "blob") return await r.blob();
        return await r.text();
      } catch (e) { lastErr = e; }
    }
    throw new Error("All loader fetch attempts failed");
  }

  function getSkinName(sk) {
    if (!sk) return "";
    if (sk.name && typeof sk.name === "string" && sk.name.trim() !== "") return sk.name;
    if (sk.path && typeof sk.path === "string") {
      const parts = sk.path.replace(/\\/g,'/').split('/');
      return parts[parts.length - 1] || "";
    }
    return "";
  }

  function buildFilePathFromSkin(sk, field) {
    if (!sk) return "";
    const v = sk[field] || "";
    if (!v) return "";
    if (typeof v !== "string") return "";
    if (v.startsWith("http://") || v.startsWith("https://")) return v;
    if (v.indexOf('/') !== -1) return v.replace(/\\/g,'/');
    if (sk.path && typeof sk.path === "string") {
      return sk.path.replace(/\\/g,'/') + "/" + v;
    }
    return v;
  }

  // --- 3. UI LOADING HELPERS ---
  function createLoadingModal() {
    const modal = document.createElement("div");
    modal.id = "skin-download-loading";
    modal.style.cssText = `position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; z-index: 100000; color: white; font-family: Arial, sans-serif; flex-direction: column; gap: 16px;`;
    const spinner = document.createElement("div");
    spinner.style.cssText = `width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3); border-radius: 50%; border-top-color: #1976d2; animation: spin 1s linear infinite;`;
    const text = document.createElement("div"); text.textContent = "Baixando skin..."; text.style.fontSize = "16px";
    modal.appendChild(spinner); modal.appendChild(text);
    const style = document.createElement("style"); style.textContent = `@keyframes spin { to { transform: rotate(360deg); } }`;
    document.head.appendChild(style);
    return modal;
  }
  function showLoadingModal() {
    const existing = document.getElementById("skin-download-loading");
    if (existing) return existing;
    const modal = createLoadingModal();
    document.body.appendChild(modal);
    return modal;
  }
  function hideLoadingModal() {
    const modal = document.getElementById("skin-download-loading");
    if (modal && modal.parentNode) modal.parentNode.removeChild(modal);
  }

  // --- 4. MULTIPLAYER HELPERS ---
  function getPlayerOnlineValue(runtimeScene){
    try { const gv = runtimeScene.getGame().getVariables(); if (gv && gv.has("PlayerOnline")) return gv.get("PlayerOnline").getAsNumber(); } catch(e){}
    try { const sv = runtimeScene.getVariables(); if (sv && sv.has("PlayerOnline")) return sv.get("PlayerOnline").getAsNumber(); } catch(e){}
    try { if (typeof gdjs !== 'undefined' && gdjs.multiplayer && typeof gdjs.multiplayer.getCurrentPlayerNumber === 'function'){ const pn = gdjs.multiplayer.getCurrentPlayerNumber(); if (typeof pn === 'number') return pn === 1 ? 1 : 2; } } catch(e){}
    return 0; // 0 = Offline/Testing (Exibe ambos os botões)
  }

  // --- 5. LOGICA DE DOWNLOAD E APLICAÇÃO ---
  let modalOwner = null, modalRepo = null, modalBranch = null;
  let globalManifest = null;

  function findSkinInManifest(manifest, modName, skinName){
    if (!manifest || !modName || !skinName) return null;
    const arr = manifest[modName] || [];
    for (const s of arr) if (getSkinName(s).toString() === skinName.toString()) return s;
    return null;
  }

  async function downloadAndSaveOnly(modName, skinObj, auto=false, target="BF"){
    if (downloadAndSaveOnly._busy) return;
    downloadAndSaveOnly._busy = true;

    let zipPath = buildFilePathFromSkin(skinObj, "zip") || (skinObj.zip || "");
    if (!zipPath) {
      const found = findSkinInManifest(globalManifest, modName, getSkinName(skinObj));
      if (found) zipPath = buildFilePathFromSkin(found, "zip") || (found.zip || "");
    }
    if (!zipPath) { downloadAndSaveOnly._busy = false; return; }

    const loadingModal = showLoadingModal();
    try {
      const cdnBase = { owner: modalOwner||"LucyYuih", repo: modalRepo||"gdev-custom-skins", branch: modalBranch||"main" };
      const cdnCandidate = (zipPath.startsWith("http://")||zipPath.startsWith("https://")) ? zipPath : buildCdnUrl(cdnBase.owner, cdnBase.repo, cdnBase.branch, zipPath);
      
      // Verifica e baixa (cache)
      await fetchCdnFirst(cdnCandidate || zipPath, "arraybuffer", cdnBase);
      
      const sel = { mod: modName, name: getSkinName(skinObj), zip: zipPath || null, thumb: buildFilePathFromSkin(skinObj, "thumb") || (skinObj.thumb || null) };
      if (typeof cdnCandidate === "string" && cdnCandidate.trim() !== "") sel.zip_cdn = cdnCandidate;
      else sel.zip_cdn = (zipPath && (zipPath.startsWith("http://")||zipPath.startsWith("https://"))) ? zipPath : null;
      
      // Define variáveis corretas para Multiplayer
      const varName = target === "BF" ? "SelectedSkin" : "SelectedDadSkin";
      const storageKey = target === "BF" ? "gd_selected_skin" : "gd_selected_dad_skin";
      
      const gv = runtimeScene.getGame().getVariables();
      if (gv.has(varName)) gv.get(varName).setString(JSON.stringify(sel));
      else runtimeScene.getGame().getVariables().pushNew(varName).setString(JSON.stringify(sel));
      try { localStorage.setItem(storageKey, JSON.stringify(sel)); } catch(e){}
      
      log("Saved " + varName);
    } catch(e){
      console.error("Download failed:", e);
    } finally {
      hideLoadingModal();
      downloadAndSaveOnly._busy = false;
    }
  }

  async function applyNow(modName, skinObj, target){
    if (applyNow._busy) return;
    applyNow._busy = true;
    
    let zipPath = buildFilePathFromSkin(skinObj, "zip") || (skinObj.zip || "");
    if (!zipPath) {
      const found = findSkinInManifest(globalManifest, modName, getSkinName(skinObj));
      if (found) zipPath = buildFilePathFromSkin(found, "zip") || (found.zip || "");
    }
    if (!zipPath) { applyNow._busy = false; return; }

    const loadingModal = showLoadingModal();
    try {
      const cdnBase = { owner: modalOwner||"LucyYuih", repo: modalRepo||"gdev-custom-skins", branch: modalBranch||"main" };
      const cdnCandidate = (zipPath.startsWith("http://")||zipPath.startsWith("https://")) ? zipPath : buildCdnUrl(cdnBase.owner, cdnBase.repo, cdnBase.branch, zipPath);
      
      const arrbuf = await fetchCdnFirst(cdnCandidate || zipPath, "arraybuffer", cdnBase);
      
      const sel = { mod: modName, name: getSkinName(skinObj), zip: zipPath || null, thumb: buildFilePathFromSkin(skinObj, "thumb") || (skinObj.thumb || null) };
      if (typeof cdnCandidate === "string" && cdnCandidate.trim() !== "") sel.zip_cdn = cdnCandidate;
      else sel.zip_cdn = (zipPath && (zipPath.startsWith("http://")||zipPath.startsWith("https://"))) ? zipPath : null;

      // Limpa cache PIXI antes de aplicar
      clearPixiTextureCache(getSkinName(skinObj));

      const varName = target === "BF" ? "SelectedSkin" : "SelectedDadSkin";
      const storageKey = target === "BF" ? "gd_selected_skin" : "gd_selected_dad_skin";
      
      const gv = runtimeScene.getGame().getVariables();
      if (gv.has(varName)) gv.get(varName).setString(JSON.stringify(sel));
      else runtimeScene.getGame().getVariables().pushNew(varName).setString(JSON.stringify(sel));
      try { localStorage.setItem(storageKey, JSON.stringify(sel)); } catch(e){}

      if (window.GD_SKIN_PLAYER && typeof window.GD_SKIN_PLAYER.loadFromArrayBuffer === "function") {
          const pkg = await window.GD_SKIN_PLAYER.loadFromArrayBuffer(runtimeScene, arrbuf, { targetName: target === "BF" ? "BF" : "BFPixel" });
          await window.GD_SKIN_PLAYER.applyPackageToScene(runtimeScene, pkg, { 
            targetName: target === "BF" ? "BF" : "BFPixel",
            targetAnimVar: target === "BF" ? "BFAnim" : "OPPAnim"
          });
      }
    } catch(e){
      console.error("applyNow failed:", e);
    } finally {
      hideLoadingModal();
      applyNow._busy = false;
    }
  }

  async function resetAndRedownload(modName, skinObj, auto=false){
    if (resetAndRedownload._busy) return;
    resetAndRedownload._busy = true;

    if(!auto && !confirm("Resetar esta skin? Isso limpará o cache local.")) { resetAndRedownload._busy = false; return; }

    const skinName = typeof skinObj === "object" ? getSkinName(skinObj) : skinObj;

    const loadingModal = showLoadingModal();
    try {
        // 1. Limpa variáveis
        try {
          const gv = runtimeScene.getGame().getVariables();
          if (gv.has("SelectedSkin")) { const cur = gv.get("SelectedSkin").getAsString(); if (cur.includes(skinName)) gv.get("SelectedSkin").setString(""); }
          if (gv.has("SelectedDadSkin")) { const cur = gv.get("SelectedDadSkin").getAsString(); if (cur.includes(skinName)) gv.get("SelectedDadSkin").setString(""); }
        } catch(e2){}
        try {
          const ls1 = localStorage.getItem("gd_selected_skin"); if (ls1 && ls1.includes(skinName)) localStorage.removeItem("gd_selected_skin");
          const ls2 = localStorage.getItem("gd_selected_dad_skin"); if (ls2 && ls2.includes(skinName)) localStorage.removeItem("gd_selected_dad_skin");
        } catch(e2){}

        // 2. Limpa Cache Player
        if (window.GD_SKIN_PLAYER && typeof window.GD_SKIN_PLAYER.clearCache === "function") {
           await window.GD_SKIN_PLAYER.clearCache();
        }
        
        // 3. Limpa Cache PIXI (CRÍTICO)
        clearPixiTextureCache(skinName);
        
        log("Reset concluído para " + skinName);
        if(!auto) alert("Skin resetada. Recarregue a cena.");

    } catch(e){
      console.error("Reset failed:", e);
    } finally {
      hideLoadingModal();
      resetAndRedownload._busy = false;
    }
  }

  // --- 6. UI CREATION (HTML/CSS) ---
  function createModal(defaultOwner, defaultRepo, defaultBranch) {
    const css = `
      :root { --modal-gap:12px; --panel-bg:#0f0f11; --panel-radius:12px; --accent:#1976d2; --muted:#999; }
      .skin-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; z-index:99999; padding:20px; box-sizing: border-box; }
      .skin-panel { width: min(1100px,98%); max-width:1100px; height: min(86vh,820px); background:var(--panel-bg); color:#eee; border-radius:var(--panel-radius); display:grid; grid-template-columns:300px 1fr; gap:var(--modal-gap); overflow:hidden; font-family:Arial, sans-serif; box-shadow: 0 12px 32px rgba(0,0,0,0.6); }
      @media (max-width:720px){ .skin-panel{ grid-template-columns:1fr; height:calc(100vh-36px); width:100%; } .skin-left{ order:0; max-height:160px; overflow:auto; } .skin-right{ order:1; } }
      .skin-left{ padding:14px; border-right:1px solid rgba(255,255,255,0.05); overflow:auto; min-width:180px; box-sizing:border-box;}
      .skin-right{ padding:14px; display:flex; flex-direction:column; overflow:auto; box-sizing:border-box; }
      .skin-left-header{ display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; gap:8px;}
      .skin-toggle-btn{ background:transparent; border:1px solid rgba(255,255,255,0.04); padding:6px 8px; border-radius:6px; color:#ddd; cursor:pointer; font-size:13px;}
      .skin-mod{ padding:8px; margin:6px 0; background:rgba(255,255,255,0.02); border-radius:8px; cursor:pointer; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; user-select:none;}
      .skin-mod:hover { background: rgba(255,255,255,0.03); }
      .skin-top{ display:flex; flex-direction:column; gap:8px;}
      .skin-title-row{ display:flex; justify-content:space-between; align-items:center; gap:8px;}
      .skin-title{ font-weight:700; font-size:1rem; }
      .skin-controls{ display:flex; gap:8px; align-items:center; margin-top:6px; flex-wrap:wrap; }
      .skin-btn{ padding:8px 10px; border-radius:8px; background: var(--accent); color:white; border:none; cursor:pointer; font-size:13px;}
      .skin-btn.opponent{ background:#d32f2f; } .skin-btn.bf{ background:#1976d2; }
      .cdn-inputs{ display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap;}
      .cdn-inputs input{ background:#0b0b0b; color:#ddd; border:1px solid rgba(255,255,255,0.04); padding:7px 8px; border-radius:6px; min-width:100px; }
      .skin-loading{ color:var(--muted); font-size:13px; margin:6px 0; }
      .skin-list{ display:flex; flex-wrap:wrap; gap:10px; overflow:auto; padding:6px; align-content:flex-start; }
      .skin-card{ width: clamp(110px,22%,160px); min-width:110px; background: rgba(255,255,255,0.02); border-radius:8px; padding:8px; text-align:center; cursor:pointer; box-sizing:border-box; display:flex; flex-direction:column; gap:8px; user-select:none; }
      .skin-card img{ width:100%; height:90px; object-fit:contain; background:#222; border-radius:6px; pointer-events:none; transition: opacity 0.3s; opacity: 0; }
      .skin-card img.loaded { opacity: 1; }
      .skin-card .label{ font-size:13px; color:#ddd; white-space:nowrap; text-overflow:ellipsis; overflow:hidden; }
      .skin-card .card-footer{ display:flex; gap:6px; justify-content:center; align-items:center; flex-direction: column; }
      .skin-card button.skin-btn{ padding:6px 8px; font-size:12px; border-radius:6px; width:100%; }
    `;
    const style = document.createElement("style"); style.className = "skin-loader-style"; style.textContent = css; document.head.appendChild(style);

    const modal = document.createElement("div"); modal.className = "skin-modal";
    const panel = document.createElement("div"); panel.className = "skin-panel";
    const left = document.createElement("div"); left.className = "skin-left";
    const leftList = document.createElement("div"); leftList.className = "skin-left-list";
    const right = document.createElement("div"); right.className = "skin-right";

    const leftHeader = document.createElement("div"); leftHeader.className = "skin-left-header";
    const leftTitle = document.createElement("div"); leftTitle.textContent = "Mods"; leftTitle.style.fontWeight = "700";
    const toggleBtn = document.createElement("button"); toggleBtn.className = "skin-toggle-btn"; toggleBtn.textContent = "Toggle";
    leftHeader.appendChild(leftTitle); leftHeader.appendChild(toggleBtn);
    left.appendChild(leftList); left.insertBefore(leftHeader, leftList);

    const top = document.createElement("div"); top.className = "skin-top";
    const titleRow = document.createElement("div"); titleRow.className = "skin-title-row";
    const title = document.createElement("div"); title.className = "skin-title"; title.textContent = "Skins";
    const controls = document.createElement("div"); controls.className = "skin-controls";
    const closeBtn = document.createElement("button"); closeBtn.className = "skin-btn"; closeBtn.textContent = "Fechar";
    controls.appendChild(closeBtn);
    titleRow.appendChild(title); titleRow.appendChild(controls);

    const cdnRow = document.createElement("div"); cdnRow.className = "cdn-inputs";
    const ownerIn = document.createElement("input"); ownerIn.placeholder = "Owner"; ownerIn.value = defaultOwner;
    const repoIn = document.createElement("input"); repoIn.placeholder = "Repo"; repoIn.value = defaultRepo;
    const branchIn = document.createElement("input"); branchIn.placeholder = "Branch"; branchIn.value = defaultBranch;
    cdnRow.appendChild(ownerIn); cdnRow.appendChild(repoIn); cdnRow.appendChild(branchIn);
    
    const info = document.createElement("div"); info.className = "skin-loading"; info.textContent = "Selecione um mod à esquerda.";
    const skinListWrap = document.createElement("div"); skinListWrap.style.flex = "1"; skinListWrap.style.overflow = "auto";

    top.appendChild(titleRow); top.appendChild(cdnRow);
    right.appendChild(top); right.appendChild(info); right.appendChild(skinListWrap);
    panel.appendChild(left); panel.appendChild(right); modal.appendChild(panel); document.body.appendChild(modal);

    return { modal, panel, left, leftList, right, ownerIn, repoIn, branchIn, closeBtn, info, skinListWrap, toggleBtn, styleEl: style, controlsEl: controls };
  }

  // --- 7. MAIN LOGIC (SINGLETON & UI) ---
  let thumbsCache = {};
  
  async function openSkinSelector(manifest){
    // SINGLETON CHECK (Otimização)
    if (document.querySelector(".skin-modal")) {
        const m = document.querySelector(".skin-modal");
        m.style.display = "flex";
        try { document.documentElement.style.overflow = 'hidden'; } catch(e){}
        return;
    }

    globalManifest = manifest || { "": [] };
    let baseOwner=null, baseRepo=null, baseBranch=null;
    if (manifest && typeof manifest._base === "string") {
      try { const [ownerRepo, branch] = manifest._base.trim().split("@"); const [owner, repo] = ownerRepo.split("/"); baseOwner = owner; baseRepo = repo; baseBranch = branch || "main"; } catch(e){}
    }

    const ui = createModal(baseOwner||"LucyYuih", baseRepo||"gdev-custom-skins", baseBranch||"main");
    const { modal, left, leftList, ownerIn, repoIn, branchIn, closeBtn, info, skinListWrap, toggleBtn, controlsEl } = ui;
    
    modalOwner = ownerIn.value; modalRepo = repoIn.value; modalBranch = branchIn.value;
    let currentMod = null;

    // LAZY LOAD OBSERVER
    const lazyObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const img = entry.target;
                const src = img.dataset.src;
                if (src) {
                    const cdnBase = JSON.parse(img.dataset.cdnBase);
                    fetchCdnFirst(src, "blob", cdnBase).then(blob => {
                        const url = URL.createObjectURL(blob);
                        img.src = url;
                        img.classList.add("loaded");
                        if(img.dataset.modName && thumbsCache[img.dataset.modName]){
                             const cacheItem = thumbsCache[img.dataset.modName].find(x => x.imgEl === img);
                             if(cacheItem) cacheItem.blobUrl = url;
                        }
                    }).catch(e => warn("Thumb lazy fail", src));
                }
                observer.unobserve(img);
            }
        });
    }, { root: skinListWrap, rootMargin: "100px" });

    // RESET GLOBAL BUTTON
    const resetSelectedBtn = document.createElement("button");
    resetSelectedBtn.className = "skin-btn";
    resetSelectedBtn.textContent = "Reset Selected";
    resetSelectedBtn.onclick = async () => {
      try {
        let selStr = null;
        try { const gv = runtimeScene.getGame().getVariables(); if (gv.has("SelectedSkin")) selStr = gv.get("SelectedSkin").getAsString(); } catch(e){}
        if (!selStr && window.localStorage) selStr = localStorage.getItem("gd_selected_skin");
        if (!selStr) return;
        const parsed = JSON.parse(selStr);
        await resetAndRedownload(parsed.mod||"", { name: parsed.name||"", zip: parsed.zip||parsed.zip_cdn }, true);
      } catch(e){}
    };
    controlsEl.insertBefore(resetSelectedBtn, controlsEl.firstChild);

    // Populate Mods
    const mods = manifest[""] || [];
    if (!Array.isArray(mods) || mods.length === 0) leftList.textContent = "No mods found";
    else {
      for (const m of mods) {
        const el=document.createElement("div"); el.className="skin-mod"; el.textContent=m;
        el.onclick=()=>selectMod(m);
        leftList.appendChild(el);
      }
    }

    // Toggles & Close
    let leftHidden = false;
    toggleBtn.onclick = ()=> { leftHidden = !leftHidden; left.style.display = leftHidden ? 'none' : 'block'; };
    closeBtn.onclick = () => { modal.style.display = 'none'; try { document.documentElement.style.overflow = ''; } catch(e){} };

    async function selectMod(modName){
      if (currentMod === modName) return;
      // Limpa blobs anteriores para liberar memoria
      if (currentMod && thumbsCache[currentMod]) {
         thumbsCache[currentMod].forEach(x => { if(x.blobUrl) URL.revokeObjectURL(x.blobUrl); });
         delete thumbsCache[currentMod];
      }

      currentMod = modName; skinListWrap.innerHTML=""; info.textContent="Carregando...";
      const skins = manifest[modName] || [];
      if (!skins.length) { info.textContent = "Nenhuma skin aqui."; return; }
      
      info.textContent=""; 
      const list=document.createElement("div"); list.className="skin-list"; skinListWrap.appendChild(list);
      thumbsCache[modName]=[];
      const cdnBase={ owner: ownerIn.value, repo: repoIn.value, branch: branchIn.value };
      
      const playerOnline = getPlayerOnlineValue(runtimeScene);
      // 0: Offline/Host (Mostra tudo), 1: Player 1 (Mostra BF), 2: Player 2 (Mostra Opponent)
      const showBF = (playerOnline === 0 || playerOnline === 1);
      const showOpp = (playerOnline === 0 || playerOnline === 2);

      for (const sk of skins){
        const card=document.createElement("div"); card.className="skin-card";
        const img=document.createElement("img"); img.alt=getSkinName(sk); img.draggable = false;
        
        // Lazy Load setup
        let thumbPath = buildFilePathFromSkin(sk, "thumb");
        if(thumbPath) {
            const candidate = (thumbPath.startsWith("http")) ? thumbPath : buildCdnUrl(cdnBase.owner, cdnBase.repo, cdnBase.branch, thumbPath);
            img.dataset.src = candidate || thumbPath;
            img.dataset.cdnBase = JSON.stringify(cdnBase);
            img.dataset.modName = modName;
            lazyObserver.observe(img);
        } else { img.style.background = "#333"; }

        const lbl=document.createElement("div"); lbl.className="label"; lbl.textContent=getSkinName(sk);
        const footer = document.createElement("div"); footer.className="card-footer";

        if(showBF){
            const btn = document.createElement("button"); btn.className = "skin-btn bf"; btn.textContent = "BF";
            btn.onclick = (e)=>{ e.stopPropagation(); applyNow(modName, sk, "BF"); };
            footer.appendChild(btn);
        }
        if(showOpp){
            const btn = document.createElement("button"); btn.className = "skin-btn opponent"; btn.textContent = "Opp";
            btn.onclick = (e)=>{ e.stopPropagation(); applyNow(modName, sk, "Opponent"); };
            footer.appendChild(btn);
        }
        const rst = document.createElement("button"); rst.className = "skin-btn"; rst.textContent = "Rst";
        rst.onclick = (e)=>{ e.stopPropagation(); resetAndRedownload(modName, sk, false); };
        footer.appendChild(rst);

        card.appendChild(img); card.appendChild(lbl); card.appendChild(footer);
        // Clique no card aplica automático pro seu slot
        card.onclick = () => downloadAndSaveOnly(modName, sk, false, (playerOnline === 2 ? "Opponent" : "BF"));
        
        list.appendChild(card);
        thumbsCache[modName].push({ skin: sk, imgEl: img, blobUrl: null });
      }
    }
  }

  // --- 8. WATCHER (SYNC MULTIPLAYER) ---
  let _skinWatcherInterval = null;
  let _skinWatcherLast = { SelectedSkin: null, SelectedDadSkin: null };

  async function applySelectionString(runtimeScene, selStr, opts = {}){ 
    if (!selStr || !selStr.trim()) return null;
    let parsed = null; try { parsed = JSON.parse(selStr); } catch(e){ return null; }
    
    // Tenta baixar usando o fetchCdnFirst otimizado
    const zipUrl = parsed.zip_cdn || parsed.zip;
    if(!zipUrl) return;

    try {
        // Tenta usar o cache do GD_SKIN_PLAYER (ram) se disponível
        let arr = null;
        if(window.GD_SKIN_CACHE && window.GD_SKIN_CACHE.zips[zipUrl]) {
             arr = window.GD_SKIN_CACHE.zips[zipUrl];
        } else {
             const r = await fetch(zipUrl); // Fetch simples se não for cdn complexa, ou melhorar aqui se necessário
             if(r.ok) arr = await r.arrayBuffer();
        }

        if(arr && window.GD_SKIN_PLAYER){
            const pkg = await window.GD_SKIN_PLAYER.loadFromArrayBuffer(runtimeScene, arr);
            return window.GD_SKIN_PLAYER.applyPackageToScene(runtimeScene, pkg, opts);
        }
    } catch(e){ warn("Watcher apply error", e); }
  }

  async function skinWatcherTick(runtimeScene){
    try{
      const gv = runtimeScene.getGame().getVariables();
      if (!gv) return;
      if (!gv.has('SelectedSkin')) gv.pushNew('SelectedSkin').setString('');
      if (!gv.has('SelectedDadSkin')) gv.pushNew('SelectedDadSkin').setString('');

      const cur = { SelectedSkin: gv.get('SelectedSkin').getAsString(), SelectedDadSkin: gv.get('SelectedDadSkin').getAsString() };
      const playerOnline = getPlayerOnlineValue(runtimeScene);

      // Se eu NÃO sou Player 1, aplico as mudanças do BF (SelectedSkin)
      if ((cur.SelectedSkin || '') !== (_skinWatcherLast.SelectedSkin || '')){
        if (playerOnline !== 1){
           if (cur.SelectedSkin && cur.SelectedSkin.trim() !== ''){
             log("Watcher: Host mudou BF skin -> aplicando localmente");
             await applySelectionString(runtimeScene, cur.SelectedSkin, { targetName: "BF", targetAnimVar: "BFAnim" });
           }
        }
      }

      // Se eu NÃO sou Player 2, aplico as mudanças do Dad (SelectedDadSkin)
      if ((cur.SelectedDadSkin || '') !== (_skinWatcherLast.SelectedDadSkin || '')){
        if (playerOnline !== 2){
           if (cur.SelectedDadSkin && cur.SelectedDadSkin.trim() !== ''){
             log("Watcher: P2 mudou Dad skin -> aplicando localmente");
             await applySelectionString(runtimeScene, cur.SelectedDadSkin, { targetName: "BFPixel", targetAnimVar: "OPPAnim" });
           }
        }
      }

      _skinWatcherLast.SelectedSkin = cur.SelectedSkin;
      _skinWatcherLast.SelectedDadSkin = cur.SelectedDadSkin;
    } catch(e){ }
  }

  function startSkinWatcher(runtimeScene){
    if (_skinWatcherInterval) return;
    _skinWatcherInterval = setInterval(()=> skinWatcherTick(runtimeScene), 700);
    log("Skin watcher started.");
  }

  // --- 9. BOOTSTRAP ---
  async function loadManifestWithFallback(){
    let manifest = null;
    try {
      // 1. GitHub
      const r = await fetch(GITHUB_RAW_URL);
      if(r.ok) {
         manifest = await r.json();
         localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(manifest));
      } else throw new Error("GH Fail");
    } catch(e) {
      // 2. LocalStorage
      try { manifest = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY)); } catch(e2){}
      // 3. Fallback Local
      if(!manifest) {
          try { manifest = await fetchCdnFirst(MANIFEST_NAME, "json"); } catch(e3){}
      }
    }
    return manifest || { "": [] };
  }

  try {
    const manifest = await loadManifestWithFallback();
    await openSkinSelector(manifest);
    startSkinWatcher(runtimeScene);
  } catch(e){
    console.error("Skin loader startup failed:", e);
  }

})(runtimeScene);
};
gdjs.PlayonlineCode.eventsList6 = function(runtimeScene) {

{


gdjs.PlayonlineCode.userFunc0x1c43458(runtimeScene);

}


};gdjs.PlayonlineCode.userFunc0x28a95e8 = function GDJSInlineCode(runtimeScene) {
"use strict";
// SCRIPT A — CORRIGIDO (Manifest: GitHub Raw -> LocalStorage -> Fallbacks) + Multiplayer Watcher Support
(function () {
  // SINGLETON CHECK: Impede execução duplicada
  if (document.getElementById("gdjs-mod-list-ui-final")) {
      const existing = document.getElementById("gdjs-mod-list-ui-final");
      existing.style.display = "flex";
      return;
  }

  // --- REPO STORAGE / HELPERS ---
  const REPO_STORAGE_KEY = "gdjs_repo_list_v1";
  const ACTIVE_REPO_KEY = "gdjs_active_repo_id_v1";
  const FAVORITES_STORAGE_KEY = "gdjs_fav_songs_v1";
  const MANIFEST_CACHE_PREFIX = "gdjs_manifest_cache_"; // Prefixo para salvar manifests no localStorage [cite: 53]

  function defaultRepoEntry() {
    return { id: "official", name: "oficial (LucyYuih/gdev-custom-charts)", owner: "LucyYuih", repo: "gdev-custom-charts", branch: "main", enabled: true };
  }

  function loadRepoList() {
    try {
      const raw = localStorage.getItem(REPO_STORAGE_KEY);
      if (!raw) { 
        const list = [defaultRepoEntry()]; localStorage.setItem(REPO_STORAGE_KEY, JSON.stringify(list)); return list; 
      }
      return JSON.parse(raw);
    } catch (e) { const list = [defaultRepoEntry()]; localStorage.setItem(REPO_STORAGE_KEY, JSON.stringify(list)); return list; }
  }

  function saveRepoList(list) {
    try { localStorage.setItem(REPO_STORAGE_KEY, JSON.stringify(list || [])); } catch(e){}
  }

  function getActiveRepo() {
    try {
      const id = localStorage.getItem(ACTIVE_REPO_KEY);
      const list = loadRepoList();
      let pick = list.find(r => r.id === id && r.enabled);
      if (!pick) pick = list.find(r => r.enabled) || list[0];
      return pick || defaultRepoEntry();
    } catch(e){ return defaultRepoEntry(); }
  }

  function setActiveRepoById(id) { try { localStorage.setItem(ACTIVE_REPO_KEY, String(id)); } catch(e){} }

  function makeRepoId() { return "r_" + Math.random().toString(36).slice(2,10); }

  function parseRepoInput(input) {
    if (!input) return null;
    input = input.trim();
    if (/manifest\.json/.test(input) || /^https?:\/\//.test(input)) {
      const m = input.match(/cdn\.jsdelivr\.net\/gh\/([^\/]+)\/([^@\/]+)@([^\/]+)\/.*manifest\.json/i);
      if (m) return { owner: m[1], repo: m[2], branch: m[3], manifestUrl: input };
      return { owner: "", repo: "", branch: "", manifestUrl: input };
    }
    const m2 = input.match(/^([^\/\s]+)\/([^@\/\s]+)(?:@(.+))?$/);
    if (m2) {
      return { owner: m2[1], repo: m2[2], branch: m2[3] || "main" };
    }
    return null;
  }

  function buildManifestCdnUrl(entry) {
    if (!entry) return null;
    if (entry.manifestUrl) return entry.manifestUrl;
    if (entry.owner && entry.repo) return `https://cdn.jsdelivr.net/gh/${entry.owner}/${entry.repo}@${entry.branch}/manifest.json`;
    return null;
  }

  // Novo Helper: URL Raw do GitHub (evita cache de CDN)
  function buildManifestRawUrl(entry) {
    if (!entry) return null;
    if (entry.manifestUrl) return entry.manifestUrl; // Se for URL direta customizada, usa ela
    if (entry.owner && entry.repo) {
        // Usa raw.githubusercontent.com para pegar a versão mais fresca
        return `https://raw.githubusercontent.com/${entry.owner}/${entry.repo}/${entry.branch || "main"}/manifest.json`;
    }
    return null;
  }

  // --- small util helpers ---
  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
  function isAudioFile(name){ return /\.(mp3|ogg|wav|aac|m4a)$/i.test(name); }
  function isJsonFile(name){ return /\.json$/i.test(name); }
  function basenameNoExt(p){ if(!p) return "";
    const s = p.split("/").pop(); return s.replace(/\.[^.]+$/, ""); }

  // --- FUNÇÕES PARA MANIFEST OTIMIZADO COM ÁUDIOS ---
  function getBaseUrl(manifest) {
    if (manifest && manifest._base) {
      return `https://cdn.jsdelivr.net/gh/${manifest._base}/`;
    }
    // Fallback para manifest legado
    const activeRepo = getActiveRepo();
    return `https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/`;
  }

  // monta url final a partir de baseUrl, folderPath e filePath (respeita URLs e caminhos já completos)
  function buildFileUrl(baseUrl, folderPath, filePath) {
    if (!filePath) return null;
    if (filePath.startsWith("http://") || filePath.startsWith("https://")) return filePath;
    // se filePath já contém '/', assume caminho relativo ao repo root -> baseUrl + filePath
    if (filePath.indexOf('/') !== -1) {
      return baseUrl + filePath.replace(/^\/+/,'');
    }
    // senao: é só o nome do arquivo -> junta folderPath
    if (folderPath && folderPath !== "") {
      return baseUrl + folderPath.replace(/^\/+|\/+$/g,'') + "/" + filePath;
    }
    return baseUrl + filePath;
  }

  function parseManifestEntry(entry, baseUrl = "", folderPath = "") {
    if (!entry) return null;
    // Se for array de strings (diretórios ou arquivos)
    if (Array.isArray(entry) && entry.length > 0 && typeof entry[0] === "string") {
      const firstItem = entry[0];
      // Se o primeiro item contém '.' (arquivo) ou contém '/' -> consideramos arquivos.
      if (firstItem.includes('.') || firstItem.includes('/')) {
        // São arquivos (nova estrutura otimizada ou antiga)
        return {
          type: 'files',
          value: entry.map(filePath => {
            const fileName = filePath.split('/').pop();
            const url = buildFileUrl(baseUrl, folderPath, filePath);
            return {
              name: fileName,
              type: "file",
              url: url
            };
          })
        };
      } else {
        // São subdiretórios
        return {
          type: 'subdirs',
          value: entry.slice()
        };
      }
    }

    // Se for objeto com subdirs e files (nova estrutura)
    if (typeof entry === 'object' && entry !== null && !Array.isArray(entry)) {
      if (entry.subdirs && entry.files) {
        return {
          type: 'folder',
          subdirs: entry.subdirs,
          files: entry.files.map(filePath => {
            const fileName = filePath.split('/').pop();
            const url = buildFileUrl(baseUrl, folderPath, filePath);
            return {
              name: fileName,
              type: "file",
              url: url
            };
          })
        };
      }
    }

    // Se for array de objetos (estrutura legada)
    if (Array.isArray(entry) && entry.length > 0 && typeof entry[0] === "object") {
      return {
        type: 'files',
        value: entry.map(item => {
          const name = item.n || item.name;
          const urlRaw = item.u || item.url || "";
          // urlRaw pode ser relativo (path) ou completo; se for relativo e não contém '/', assumimos folderPath + '/' + urlRaw
          let url;
          if (!urlRaw) {
            url = buildFileUrl(baseUrl, folderPath, name);
          } else if (urlRaw.startsWith("http://") || urlRaw.startsWith("https://") || urlRaw.indexOf('/') !== -1) {
            url = urlRaw.startsWith("http") ? urlRaw : baseUrl + urlRaw.replace(/^\/+/,'');
          } else {
            url = buildFileUrl(baseUrl, folderPath, urlRaw);
          }
          return {
            name: name,
            type: "file",
            url: url
          };
        })
      };
    }

    return null;
  }

  // --- MANIFEST / GITHUB helpers ---
  async function tryManifestFromGameVar(runtimeScene) {
    try {
      if (typeof runtimeScene !== "undefined" && runtimeScene.getGame) {
        const gg = runtimeScene.getGame().getVariables();
        if (gg.has("manifestjson")) {
          const s = gg.get("manifestjson").getAsString();
          if (s && s.trim()) {
            try { return JSON.parse(s); } catch(e) { return null; }
          }
        }
      }
    } catch(e){}
    return null;
  }

  async function tryManifestFromProjectResource() {
    try {
      const tries = ["manifest.json","resources/manifest.json","res/manifest.json","./manifest.json"];
      for (const p of tries) {
        try { const r = await fetch(p, {cache:"no-cache"});
        if (r.ok) { try { return await r.json(); } catch(e){} } } catch(e){}
      }
    } catch(e){}
    return null;
  }

  async function tryManifestFromCdnOf(entry) {
    try {
      const url = buildManifestCdnUrl(entry);
      if (!url) return null;
      const r = await fetch(url, {cache:"no-cache"});
      if (r.ok) return await r.json();
    } catch(e){}
    return null;
  }

  // NOVA FUNÇÃO: Tenta pegar o manifest raw (Network)
  async function tryManifestFromRawNetwork(entry) {
    try {
        const url = buildManifestRawUrl(entry);
        if(!url) return null;
        // Adicionando timestamp para evitar qualquer cache residual
        const r = await fetch(url + "?t=" + Date.now()); 
        if(r.ok) return await r.json();
    } catch(e){}
    return null;
  }

  async function tryManifestFromGithubApiFor(entry, path="") {
    if (!entry || (!entry.owner || !entry.repo)) throw new Error("Invalid repo entry");
    const apiUrl = `https://api.github.com/repos/${entry.owner}/${entry.repo}/contents/${encodeURIComponent(path)}?ref=${entry.branch || "main"}`;
    let token = "";
    try { token = localStorage.getItem("gdjs_github_token") || ""; } catch(e){}
    const headers = token ? { "Authorization": "token " + token } : {};
    const r = await fetch(apiUrl, { headers });
    if (!r.ok) throw new Error(`GitHub API: ${r.status}`);
    const json = await r.json();
    return json.map(item => ({ name: item.name, path: item.path, type: item.type, download_url: item.download_url || null }));
  }

  const _manifest_cache_by_repo = {};

  // --- LÓGICA DE CARREGAMENTO DO MANIFEST MODIFICADA ---
  async function loadManifestPreferLocalFor(entry, runtimeScene) {
    const repoId = (entry && entry.id) ? entry.id : "__default__";
    
    // Se já estiver em memória RAM nesta sessão, retorna direto
    if (typeof _manifest_cache_by_repo[repoId] !== "undefined" && _manifest_cache_by_repo[repoId] !== null) {
        return _manifest_cache_by_repo[repoId];
    }

    const storageKey = MANIFEST_CACHE_PREFIX + repoId;

    // 1. TENTATIVA: Network (GitHub Raw / API fake via raw file)
    // Objetivo: Sempre tentar pegar o mais atual
    const fromNetwork = await tryManifestFromRawNetwork(entry);
    if (fromNetwork) {
        // Se deu certo baixar, salva no localStorage e retorna
        try {
            localStorage.setItem(storageKey, JSON.stringify(fromNetwork));
        } catch(e) {
            console.warn("Falha ao salvar manifest no localStorage (quota excedida?)", e);
        }
        _manifest_cache_by_repo[repoId] = fromNetwork;
        return fromNetwork;
    }

    // 2. TENTATIVA: LocalStorage (Offline ou Falha de Rede)
    try {
        const localRaw = localStorage.getItem(storageKey);
        if (localRaw) {
            const parsed = JSON.parse(localRaw);
            if (parsed) {
                _manifest_cache_by_repo[repoId] = parsed;
                return parsed;
            }
        }
    } catch(e) {}

    // 3. TENTATIVA: Variáveis de Jogo (GameVar)
    const fromVar = await tryManifestFromGameVar(runtimeScene);
    if (fromVar) { _manifest_cache_by_repo[repoId] = fromVar; return fromVar; }

    // 4. TENTATIVA: Recursos do Projeto
    const fromRes = await tryManifestFromProjectResource();
    if (fromRes) { _manifest_cache_by_repo[repoId] = fromRes; return fromRes; }

    // 5. TENTATIVA: Fallback para CDN JsDelivr (se o Raw falhou, talvez o CDN funcione, embora improvável se for erro de rede)
    const fromCdn = await tryManifestFromCdnOf(entry);
    if (fromCdn) { _manifest_cache_by_repo[repoId] = fromCdn; return fromCdn; }

    _manifest_cache_by_repo[repoId] = null;
    return null;
  }

  async function ghListForFolderUsingEntry(entry, path="") {
    if (!entry || (!entry.owner || !entry.repo)) {
      throw new Error("No GitHub owner/repo specified for ghList");
    }
    return await tryManifestFromGithubApiFor(entry, path);
  }

  // --- UI: main container (full screen) ---
  const container = document.createElement("div");
  container.id = "gdjs-mod-list-ui-final";
  Object.assign(container.style, {
    position: "fixed", left: "0", top: "0", right: "0", bottom: "0",
    zIndex: 9999999, fontFamily: "Inter, system-ui, Arial", color: "#eee",
    overflow: "hidden", display: "flex", flexDirection: "column",
    background: "linear-gradient(180deg, rgba(12,12,12,0.98), rgba(8,8,8,0.95))"
  });
  // Header
  const header = document.createElement("div");
  Object.assign(header.style, { padding: "10px", display: "flex", gap: "8px", alignItems: "center", borderBottom: "1px solid rgba(255,255,255,0.04)", flex: "0 0 auto" });
  header.innerHTML = `
    <div style="display:flex;gap:8px;align-items:center">
      <div style="font-weight:700">Mods</div>
      <select id="gdjs-repo-select" style="padding:6px;border-radius:6px;background:#0b0b0b;color:#eee;border:1px solid rgba(255,255,255,0.06)"></select>
      <button id="gdjs-repo-manage" style="padding:6px;border-radius:6px">Gerenciar Repos</button>
      <button id="gdjs-repo-refresh" style="padding:6px;border-radius:6px">Atualizar</button>
      <button id="gdjs-repo-cache" style="padding:6px;border-radius:6px">Ver Cache</button>
    </div>
    <input id="gdjs-final-search" placeholder="Pesquisar mods / músicas..." style="margin-left:8px;flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:#0b0b0b;color:#eee" />
    <button id="gdjs-final-close" style="margin-left:8px;padding:6px;border-radius:6px">Fechar</button>
  `;
  // Main split
  const main = document.createElement("div");
  Object.assign(main.style, { display: "flex", gap: "10px", padding: "10px", flex: "1 1 auto", minHeight: 0, overflow: "hidden" });
  const leftPane = document.createElement("div");
  Object.assign(leftPane.style, { width: "38%", minWidth: "260px", maxWidth: "640px", overflowY: "auto", borderRight: "1px solid rgba(255,255,255,0.03)", paddingRight: "8px" });
  const rightPane = document.createElement("div");
  Object.assign(rightPane.style, { flex: "1 1 auto", overflowY: "auto", paddingLeft: "8px" });

  const footer = document.createElement("div");
  Object.assign(footer.style, { padding: "10px", borderTop: "1px solid rgba(255,255,255,0.04)", display: "flex", gap: "12px", alignItems: "center", flex: "0 0 auto" });
  footer.innerHTML = `<div id="gdjs-final-status" style="font-size:13px;opacity:0.9"></div><div id="gdjs-final-last" style="margin-left:auto;font-size:13px;opacity:0.85"></div>`;

  container.appendChild(header);
  main.appendChild(leftPane); main.appendChild(rightPane);
  container.appendChild(main); container.appendChild(footer);
  document.body.appendChild(container);

  // refs
  const repoSelect = document.getElementById("gdjs-repo-select");
  const btnManage = document.getElementById("gdjs-repo-manage");
  const btnRefresh = document.getElementById("gdjs-repo-refresh");
  const btnCache = document.getElementById("gdjs-repo-cache");
  const btnClose = document.getElementById("gdjs-final-close");
  const searchInput = document.getElementById("gdjs-final-search");
  const statusEl = document.getElementById("gdjs-final-status");
  const lastEl = document.getElementById("gdjs-final-last");

  function setStatus(s){ statusEl.textContent = s || ""; }
  function setLast(s){ lastEl.textContent = s || ""; }

  // state
  let currentModPath = "";
  let modsList = [];
  let songsList = [];
  let modElementMap = {};
  let songElementMap = {};
  let favorites = loadFavorites();
  // array of { path, name, repoId }

  // --- Favorites helpers ---
  function loadFavorites() {
    try {
      const raw = localStorage.getItem(FAVORITES_STORAGE_KEY);
      if (!raw) return [];
      return JSON.parse(raw) || [];
    } catch(e){ return []; }
  }
  function saveFavorites() {
    try { localStorage.setItem(FAVORITES_STORAGE_KEY, JSON.stringify(favorites || [])); } catch(e){}
    // also push to game variable so "entra no jogo ja com eles"
    try {
      if (window.runtimeScene && window.runtimeScene.getGame) {
        runtimeScene.getGame().getVariables().get("FavoriteSongs").setString(JSON.stringify(favorites || []));
      }
    } catch(e){}
  }
  function isFavorite(path) {
    if (!path) return false;
    return favorites.some(f => f.path === path);
  }
  function addFavorite(path, name) {
    if (!path) return;
    if (isFavorite(path)) return;
    const entry = { path: path, name: name || basenameNoExt(path.split("/").pop()||path), repoId: getActiveRepo().id || null };
    favorites.push(entry);
    saveFavorites();
  }
  function removeFavorite(path) {
    if (!path) return;
    favorites = (favorites || []).filter(f => f.path !== path);
    saveFavorites();
  }
  function toggleFavorite(path, name) {
    if (isFavorite(path)) removeFavorite(path);
    else addFavorite(path, name);
    // refresh UI icon for this song item if exists
    if (songElementMap[path] && songElementMap[path].favIcon) {
      try { songElementMap[path].favIcon.textContent = isFavorite(path) ? "★" : "☆"; } catch(e){}
    }
    // If Favorites pane open, refresh
    if (currentModPath === "__favorites__") openMod("__favorites__");
  }

  // --- REPO UI / MANAGEMENT ---
  function renderRepoSelect() {
    const list = loadRepoList();
    repoSelect.innerHTML = "";
    for (const r of list) {
      const opt = document.createElement("option");
      opt.value = r.id;
      opt.textContent = (r.enabled ? "● " : "○ ") + (r.name || (r.owner? (r.owner + "/" + r.repo + (r.branch? "@" + r.branch : "")) : r.manifestUrl || "custom"));
      repoSelect.appendChild(opt);
    }
    const active = getActiveRepo();
    setActiveRepoById(active.id);
    try { repoSelect.value = active.id; } catch(e){}
  }

  function showRepoManagerModal() {
    const overlay = document.createElement("div");
    Object.assign(overlay.style, { position: "fixed", left: "0", top: "0", right: "0", bottom: "0", background: "rgba(0,0,0,0.6)", zIndex: 10000000, display: "flex", alignItems: "center", justifyContent: "center" });
    const box = document.createElement("div");
    Object.assign(box.style, { width: "720px", maxHeight: "80vh", overflowY: "auto", background: "#0f0f10", borderRadius: "8px", padding: "12px", boxShadow: "0 12px 40px rgba(0,0,0,0.6)", color: "#eee" });
    box.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><div style="font-weight:700">Gerenciar Repositórios</div><div style="margin-left:auto;font-size:13px;opacity:0.85">Formato: owner/repo@branch ou URL do manifest</div></div><div style="margin-top:10px" id="gdjs-repo-list-area"></div>
      <div style="margin-top:10px;display:flex;gap:8px">
        <input id="gdjs-repo-input" placeholder="ex: LucyYuih/gdev-custom-charts@main" style="flex:1;padding:8px;border-radius:6px;background:#0b0b0b;color:#eee;border:1px solid rgba(255,255,255,0.06)"/>
        <button id="gdjs-repo-add" style="padding:8px;border-radius:6px">Adicionar</button>
      </div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end">
        <button id="gdjs-repo-close" style="padding:8px;border-radius:6px">Fechar</button>
      </div>`;
    overlay.appendChild(box); document.body.appendChild(overlay);

    const listArea = box.querySelector("#gdjs-repo-list-area");
    function renderListArea() {
      const lst = loadRepoList();
      listArea.innerHTML = "";
      for (const r of lst) {
        const row = document.createElement("div");
        Object.assign(row.style, { display: "flex", gap: "8px", alignItems: "center", padding: "6px", borderRadius: "6px", background: "linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))", marginBottom: "6px" });
        const label = document.createElement("div"); label.style.flex = "1"; label.innerHTML = `<div style="font-weight:600">${r.name || (r.owner? (r.owner + "/" + r.repo) : r.manifestUrl)}</div><div style="font-size:12px;opacity:0.8">${r.owner? (r.owner + "/" + r.repo + (r.branch? "@" + r.branch : "")) : r.manifestUrl}</div>`;
        const controls = document.createElement("div"); controls.style.display = "flex"; controls.style.gap = "6px";
        const toggle = document.createElement("button"); toggle.textContent = r.enabled ? "Ativo" : "Desativar"; toggle.style.padding = "6px"; toggle.style.borderRadius = "6px";
        toggle.onclick = () => { r.enabled = !r.enabled; saveRepoList(lst); renderListArea(); renderRepoSelect(); };
        const setActiveBtn = document.createElement("button"); setActiveBtn.textContent = "Selecionar"; setActiveBtn.style.padding = "6px"; setActiveBtn.style.borderRadius = "6px";
        setActiveBtn.onclick = () => { setActiveRepoById(r.id); renderRepoSelect(); loadFolder(""); overlay.remove(); };
        const del = document.createElement("button"); del.textContent = "Excluir"; del.style.padding = "6px"; del.style.borderRadius = "6px";
        del.onclick = () => { const idx = lst.findIndex(x=>x.id===r.id); if (idx>=0) { lst.splice(idx,1); saveRepoList(lst); renderListArea(); renderRepoSelect(); } };
        controls.appendChild(toggle); controls.appendChild(setActiveBtn);
        controls.appendChild(del);
        row.appendChild(label); row.appendChild(controls); listArea.appendChild(row);
      }
      if ((lst||[]).length === 0) listArea.innerHTML = "<div style='opacity:0.8'>Nenhum repositório adicionado.</div>";
    }
    renderListArea();

    const input = box.querySelector("#gdjs-repo-input");
    const addBtn = box.querySelector("#gdjs-repo-add");
    addBtn.onclick = () => {
      const v = input.value.trim();
      if (!v) return;
      const parsed = parseRepoInput(v);
      if (!parsed) { alert("Formato inválido"); return; }
      const list = loadRepoList();
      const entry = { id: makeRepoId(), name: parsed.owner? (parsed.owner + "/" + parsed.repo + (parsed.branch? "@" + parsed.branch : "")) : (parsed.manifestUrl || v), owner: parsed.owner||"", repo: parsed.repo||"", branch: parsed.branch||"main", manifestUrl: parsed.manifestUrl||null, enabled: true };
      list.push(entry); saveRepoList(list); input.value = ""; renderListArea(); renderRepoSelect();
    };

    box.querySelector("#gdjs-repo-close").onclick = () => overlay.remove();
  }

  // --- CACHE manager modal ---
  function showCacheManager() {
    const overlay = document.createElement("div");
    Object.assign(overlay.style, { position: "fixed", left: "0", top: "0", right: "0", bottom: "0", background: "rgba(0,0,0,0.6)", zIndex: 10000000, display: "flex", alignItems: "center", justifyContent: "center" });
    const box = document.createElement("div");
    Object.assign(box.style, { width: "760px", maxHeight: "80vh", overflowY: "auto", background: "#0f0f10", borderRadius: "8px", padding: "12px", boxShadow: "0 12px 40px rgba(0,0,0,0.6)", color: "#eee" });
    box.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><div style="font-weight:700">Cache de Músicas</div><div style="margin-left:auto;font-size:13px;opacity:0.85">Gerencie músicas baixadas</div></div>
      <div id="gdjs-cache-list" style="margin-top:10px"></div>
      <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end">
        <button id="gdjs-cache-clear" style="padding:8px;border-radius:6px">Limpar Tudo</button>
        <button id="gdjs-cache-close" style="padding:8px;border-radius:6px">Fechar</button>
      </div>`;
    overlay.appendChild(box); document.body.appendChild(overlay);

    const listArea = box.querySelector("#gdjs-cache-list");
    function renderCache() {
      const keys = Object.keys(window.gdjsCustomAudio || {});
      listArea.innerHTML = "";
      if (!keys || keys.length === 0) { listArea.innerHTML = "<div style='opacity:0.8'>Nenhuma música em cache.</div>"; return; }
      for (const k of keys) {
        const row = document.createElement("div");
        Object.assign(row.style, { display: "flex", gap: "8px", alignItems: "center", padding: "8px", borderRadius: "6px", marginBottom: "6px", background: "linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))" });
        const label = document.createElement("div"); label.style.flex = "1"; label.innerHTML = `<div style="font-weight:600">${k}</div><div style="font-size:12px;opacity:0.8">${Object.keys((window.gdjsCustomAudio[k] && window.gdjsCustomAudio[k].audios) || {}).length} audios • ${Object.keys((window.gdjsCustomAudio[k] && window.gdjsCustomAudio[k].rawFiles) || {}).length} jsons</div>`;
        const btns = document.createElement("div"); btns.style.display = "flex"; btns.style.gap = "6px";
        const del = document.createElement("button"); del.textContent = "Deletar"; del.style.padding = "6px";
        del.style.borderRadius = "6px";
        del.onclick = () => { 
            // CORREÇÃO DE CLEANUP: Revogar blob URLs antes de deletar a referência
            try { 
                const data = window.gdjsCustomAudio[k];
                if (data && data.audios) {
                    Object.values(data.audios).forEach(a => {
                        if (a.blobUrl) URL.revokeObjectURL(a.blobUrl);
                    });
                }
            } catch(e){} 
            delete window.gdjsCustomAudio[k];
            renderCache(); 
        };
        const openBtn = document.createElement("button"); openBtn.textContent = "Abrir pasta";
        openBtn.style.padding = "6px"; openBtn.style.borderRadius = "6px";
        openBtn.onclick = () => { showCacheDetails(k); };
        btns.appendChild(openBtn); btns.appendChild(del);
        row.appendChild(label); row.appendChild(btns); listArea.appendChild(row);
      }
    }

    function showCacheDetails(key) {
      const data = window.gdjsCustomAudio && window.gdjsCustomAudio[key];
      const modal = document.createElement("div");
      Object.assign(modal.style, { position: "fixed", left: "0", top: "0", right: "0", bottom: "0", background: "rgba(0,0,0,0.6)", zIndex: 10000001, display: "flex", alignItems: "center", justifyContent: "center" });
      const b = document.createElement("div"); Object.assign(b.style, { width: "720px", maxHeight: "80vh", overflowY: "auto", background: "#0f0f10", borderRadius: "8px", padding: "12px", color: "#eee" });
      b.innerHTML = `<div style="font-weight:700;margin-bottom:8px">${key}</div><div id="gdjs-cache-detail-list" style="display:flex;flex-direction:column;gap:6px"></div><div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px"><button id="gdjs-cache-detail-close" style="padding:8px;border-radius:6px">Fechar</button></div>`;
      modal.appendChild(b); document.body.appendChild(modal);
      const listEl = b.querySelector("#gdjs-cache-detail-list");
      const audios = (data && data.audios) ? Object.keys(data.audios) : [];
      const raws = (data && data.rawFiles) ? Object.keys(data.rawFiles) : [];
      if (audios.length === 0 && raws.length === 0) listEl.innerHTML = "<div style='opacity:0.8'>Vazio</div>";
      for (const a of audios) {
        const row = document.createElement("div"); row.style.display = "flex";
        row.style.justifyContent = "space-between"; row.style.alignItems = "center";
        row.innerHTML = `<div>${a}</div>`;
        const btn = document.createElement("button"); btn.textContent = "Deletar"; btn.style.padding = "6px";
        btn.style.borderRadius = "6px";
        btn.onclick = () => { 
            try { 
                // Revoke single blob
                if(data.audios[a] && data.audios[a].blobUrl) URL.revokeObjectURL(data.audios[a].blobUrl);
                delete data.audios[a]; 
            } catch(e){} 
            row.remove(); 
        };
        row.appendChild(btn); listEl.appendChild(row);
      }
      for (const r of raws) {
        const row = document.createElement("div");
        row.style.display = "flex"; row.style.justifyContent = "space-between"; row.style.alignItems = "center";
        row.innerHTML = `<div>${r}</div>`;
        const btn = document.createElement("button"); btn.textContent = "Deletar";
        btn.style.padding = "6px"; btn.style.borderRadius = "6px";
        btn.onclick = () => { try { delete data.rawFiles[r]; } catch(e){} row.remove(); };
        row.appendChild(btn);
        listEl.appendChild(row);
      }
      b.querySelector("#gdjs-cache-detail-close").onclick = () => modal.remove();
    }

    box.querySelector("#gdjs-cache-clear").onclick = () => {
      if (!confirm("Deletar todo o cache de músicas?")) return;
      // Revogar tudo antes de zerar
      try {
          if (window.gdjsCustomAudio) {
              Object.values(window.gdjsCustomAudio).forEach(folder => {
                  if(folder.audios) {
                      Object.values(folder.audios).forEach(a => {
                          if(a.blobUrl) URL.revokeObjectURL(a.blobUrl);
                      });
                  }
              });
          }
      } catch(e){}
      try { window.gdjsCustomAudio = {}; } catch(e){}
      renderCache();
    };

    box.querySelector("#gdjs-cache-close").onclick = () => overlay.remove();

    renderCache();
  }

  // --- rendering of mods (left) and songs (right) ---
  function renderModsList(items) {
    leftPane.innerHTML = "";
    modElementMap = {};
    // Insert Favorites fake item as first entry
    const favCount = (favorites || []).length;
    const favRow = document.createElement("div");
    Object.assign(favRow.style, {
      padding: "10px",
      borderRadius: "8px",
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      gap: "8px",
      marginBottom: "8px",
      cursor: "pointer",
      background: "linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))"
    });
    const leftFav = document.createElement("div"); leftFav.style.display = "flex"; leftFav.style.flexDirection = "column"; leftFav.innerHTML = `<div style="font-weight:600">Favorites</div><div style="font-size:12px;opacity:0.8">${favCount} músicas</div>`;
    favRow.appendChild(leftFav);
    favRow.onclick = ()=> openMod("__favorites__");
    leftPane.appendChild(favRow);
    modElementMap["__favorites__"] = { element: favRow, data: { name: "Favorites", path: "__favorites__" } };
    if (!items || items.length === 0) { const e = document.createElement("div"); e.textContent = "Nenhum mod encontrado."; e.style.opacity = "0.8"; leftPane.appendChild(e);
    return; }
    for (const item of items) {
      const row = document.createElement("div");
      Object.assign(row.style, {
        padding: "10px",
        borderRadius: "8px",
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        gap: "8px",
        marginBottom: "8px",
        cursor: "pointer",
        background: "linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))",
        transition: "transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease"
      });

      // hover animation (lift + scale + subtle shadow)
      row.addEventListener('mouseenter', ()=> {
        try {
          row.style.transform = "translateY(-4px) scale(1.02)";
          row.style.boxShadow = "0 10px 30px rgba(0,0,0,0.45)";
          row.style.background = "linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.008))";
        } catch(e){}
      });
      row.addEventListener('mouseleave', ()=> {
        try {
          row.style.transform = "translateY(0) scale(1)";
          row.style.boxShadow = "none";
          row.style.background = "linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))";
        } catch(e){}
      });
      const left = document.createElement("div"); left.style.display = "flex"; left.style.flexDirection = "column"; left.innerHTML = `<div style="font-weight:600">${item.name}</div>`;
      row.appendChild(left);

      row.onclick = ()=> openMod(item.path);

      leftPane.appendChild(row);
      modElementMap[item.path] = { element: row, data: item };
    }
  }

  function renderSongsList(items) {
    rightPane.innerHTML = "";
    songElementMap = {};
    if (!items || items.length === 0) { const e = document.createElement("div");
      e.textContent = "Selecione um mod à esquerda."; e.style.opacity = "0.8"; rightPane.appendChild(e); return;
    }
    for (const item of items) {
      const row = document.createElement("div");
      Object.assign(row.style, { padding: "10px", borderRadius: "8px", display: "flex", justifyContent: "space-between", alignItems: "center", gap: "8px", marginBottom: "8px", background: "linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))" });
      // left column: name only (removed path below name)
      const left = document.createElement("div");
      left.style.display = "flex"; left.style.flexDirection = "column"; left.innerHTML = `<div style="font-weight:600">${item.name}</div>`;
      const right = document.createElement("div"); right.style.display = "flex"; right.style.gap = "8px";
      right.style.alignItems = "center";
      // star favorite icon
      const favIcon = document.createElement("div");
      favIcon.textContent = isFavorite(item.path) ? "★" : "☆";
      favIcon.title = isFavorite(item.path) ? "Remover dos favoritos" : "Adicionar aos favoritos";
      Object.assign(favIcon.style, { cursor: "pointer", fontSize: "18px", userSelect: "none" });
      favIcon.onclick = (ev) => { ev.stopPropagation(); toggleFavorite(item.path, item.name); };
      // action buttons container
      const checkBtn = document.createElement("button"); checkBtn.textContent = "Checando..."; checkBtn.disabled = true; checkBtn.style.padding="6px";
      checkBtn.style.borderRadius="6px";
      right.appendChild(favIcon);
      right.appendChild(checkBtn);
      row.appendChild(left); row.appendChild(right); rightPane.appendChild(row);
      songElementMap[item.path] = { element: row, data: item, rightContainer: right, placeholderBtn: checkBtn, name: item.name, favIcon: favIcon };
    }
    startBackgroundCheckOnSongs(items);
  }

  // --- background check ---
  let bgController = null;
  const hasSubCache = {};

  function startBackgroundCheckOnSongs(items) {
    if (bgController && typeof bgController.abort === "function") try { bgController.abort();
    } catch(e){}
    bgController = { aborted:false, abort(){ this.aborted=true; } };
    const list = items || [];
    const concurrency = 3;
    let idx = 0;
    const activeRepo = getActiveRepo();
    async function worker() {
      while(!bgController.aborted) {
        if (idx >= list.length) break;
        const p = list[idx++].path;
        try {
          if (typeof hasSubCache[p] !== "undefined") { updateButtonsForDecisionFromCache(p, hasSubCache[p]);
          await sleep(0); continue; }
          const manifest = await loadManifestPreferLocalFor(activeRepo, window.runtimeScene || undefined);
          let hasSubdirs = false;
          
          if (manifest && manifest.hasOwnProperty(p)) {
            const baseUrl = getBaseUrl(manifest);
            const parsed = parseManifestEntry(manifest[p], baseUrl, p);
            
            if (parsed && (parsed.type === 'subdirs' || (parsed.type === 'folder' && parsed.subdirs && parsed.subdirs.length > 0))) {
              hasSubdirs = true;
            } else {
              hasSubdirs = false;
            }
          } else {
            // Se não está no manifest, tenta GitHub API
            try {
              const api = await ghListForFolderUsingEntry(activeRepo, p).catch(()=>[]);
              hasSubdirs = Array.isArray(api) && api.some(x=>x.type==="dir");
            } catch(e) {
              hasSubdirs = false;
            }
          }
          
          hasSubCache[p] = hasSubdirs;
          updateButtonsForDecisionFromCache(p, hasSubdirs);
        } catch(e){}
        await sleep(40);
      }
    }
    for (let i=0;i<concurrency;i++) worker();
  }

  function updateButtonsForDecisionFromCache(path, hasSubdirs) {
    const el = songElementMap[path];
    if (!el) return;
    const right = el.rightContainer;
    right.innerHTML = "";
    const itemName = el.name || path.split("/").pop();

    // favorite icon (recreate to keep consistent)
    const favIcon = document.createElement("div");
    favIcon.textContent = isFavorite(path) ? "★" : "☆";
    favIcon.title = isFavorite(path) ? "Remover dos favoritos" : "Adicionar aos favoritos";
    Object.assign(favIcon.style, { cursor: "pointer", fontSize: "18px", userSelect: "none" });
    favIcon.onclick = (ev) => { ev.stopPropagation(); toggleFavorite(path, itemName); };
    if (hasSubdirs) {
      const pickBtn = document.createElement("button"); pickBtn.textContent = "Selecionar difficulty"; pickBtn.style.padding="6px"; pickBtn.style.borderRadius="6px";
      pickBtn.onclick = async ()=>{ 
        try {
          setStatus("Carregando difficulties de " + itemName + "...");
          const activeRepo = getActiveRepo();
          const subdirs = await fetchSubdirsUsingEntry(activeRepo, path);
          if (!subdirs || subdirs.length === 0) { setStatus("Nenhuma difficulty encontrada.");
          return; }
          showDifficultyChooser(path, subdirs);
          setStatus("");
        } catch(e){ setStatus("Erro listando difficulties.");
        }
      };
      right.appendChild(favIcon);
      right.appendChild(pickBtn);
    } else {
      const dlBtn = document.createElement("button");
      dlBtn.textContent = "Selecionar e baixar"; dlBtn.style.padding="6px"; dlBtn.style.borderRadius="6px";
      dlBtn.onclick = ()=> downloadSongFolder(path);
      right.appendChild(favIcon);
      right.appendChild(dlBtn);
    }
    // update map ref
    if (songElementMap[path]) songElementMap[path].favIcon = favIcon;
  }

  async function fetchSubdirsUsingEntry(entry, folderPath) {
    try {
      const manifest = await loadManifestPreferLocalFor(entry, window.runtimeScene || undefined);
      if (manifest && manifest.hasOwnProperty(folderPath)) {
        const baseUrl = getBaseUrl(manifest);
        const parsed = parseManifestEntry(manifest[folderPath], baseUrl, folderPath);
        if (parsed && parsed.type === 'subdirs') {
          return parsed.value.slice();
        } else if (parsed && parsed.type === 'folder' && parsed.subdirs) {
          return parsed.subdirs.slice();
        }
      }
    } catch(e){}
    try {
      const api = await ghListForFolderUsingEntry(entry, folderPath);
      const dirs = (api || []).filter(i=> i.type === "dir").map(i=> i.name);
      return dirs;
    } catch(e){ return []; }
  }

  async function loadFolder(path="") {
    try {
      setStatus("Carregando pasta...");
      const activeRepo = getActiveRepo();
      for (const d of (modsList||[])) delete hasSubCache[d.path];
      const manifest = await loadManifestPreferLocalFor(activeRepo, window.runtimeScene || undefined);
      let items = [];
      if (manifest && manifest.hasOwnProperty(path)) {
        const baseUrl = getBaseUrl(manifest);
        const parsed = parseManifestEntry(manifest[path], baseUrl, path);
        if (parsed && (parsed.type === 'subdirs' || (parsed.type === 'folder' && parsed.subdirs))) {
          const subdirs = parsed.type === 'subdirs' ?
          parsed.value : parsed.subdirs;
          items = subdirs.map(name => ({ name, path: (path? path + "/" + name : name), type: "dir" }));
        }
      } else {
        try {
          const api = await ghListForFolderUsingEntry(activeRepo, path);
          items = (api || []).filter(it => it.type === "dir").map(it => ({ name: it.name, path: it.path, type: "dir" }));
        } catch(e){
          items = [];
        }
      }
      modsList = items || [];
      currentModPath = "";
      renderModsList(modsList);
      renderSongsList([]);
      setStatus(((path||"Mods")) + ` — ${modsList.length} mods`);
      setTimeout(()=> startBackgroundCheckOnSongs(modsList), 10);
      // update saved favorites variable in runtime scene
      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("FavoriteSongs").setString(JSON.stringify(favorites || []));
      } catch(e){}
    } catch (err) {
      modsList = []; renderModsList(modsList);
      setStatus("Erro carregando pasta: " + (err && err.message ? err.message : err));
    }
  }

  async function openMod(path) {
    try {
      setStatus("Abrindo " + path + "...");
      currentModPath = path;

      // Special handling for Favorites
      if (path === "__favorites__") {
        const items = (favorites || []).map(f => ({ name: f.name || basenameNoExt(f.path.split("/").pop()||f.path), path: f.path }));
        songsList = items;
        renderSongsList(songsList);
        setStatus(`Favorites — ${songsList.length} músicas`);
        return;
      }

      const activeRepo = getActiveRepo();
      const manifest = await loadManifestPreferLocalFor(activeRepo, window.runtimeScene || undefined);
      let items = [];
      if (manifest && manifest.hasOwnProperty(path)) {
        const baseUrl = getBaseUrl(manifest);
        const parsed = parseManifestEntry(manifest[path], baseUrl, path);
        if (parsed && (parsed.type === 'subdirs' || (parsed.type === 'folder' && parsed.subdirs))) {
          const subdirs = parsed.type === 'subdirs' ?
          parsed.value : parsed.subdirs;
          items = subdirs.map(name => ({ name, path: (path? path + "/" + name : name), type: "dir" }));
        } else if (parsed && parsed.type === 'files') {
          // If manifest path directly lists files, treat each file as an item (name = filename, path = path/filename)
          items = (parsed.value || []).map(f => ({ name: f.name, path: (path? path + "/" + f.name : f.name) }));
        }
      } else {
        try {
          const api = await ghListForFolderUsingEntry(activeRepo, path);
          items = (api || []).filter(it => it.type === "dir").map(it => ({ name: it.name, path: it.path, type: "dir" }));
        } catch(e){ items = []; }
      }
      songsList = items || [];
      renderSongsList(songsList);
      setStatus(`${path} — ${songsList.length} músicas`);
    } catch(e){
      setStatus("Erro ao abrir mod: " + (e && e.message ? e.message : e));
    }
  }

  // --- FUNÇÕES DE DOWNLOAD CORRIGIDAS ---
  async function getFilesFromManifest(path) {
    try {
      const activeRepo = getActiveRepo();
      const manifest = await loadManifestPreferLocalFor(activeRepo, window.runtimeScene || undefined);
      if (!manifest || !manifest.hasOwnProperty(path)) return null;
      
      const baseUrl = getBaseUrl(manifest);
      const parsed = parseManifestEntry(manifest[path], baseUrl, path);
      
      if (!parsed) return null;
      if (parsed.type === 'files') {
        return parsed.value;
      } else if (parsed.type === 'folder' && parsed.files) {
        return parsed.files;
      }
      
      return null;
    } catch(e){}
    return null;
  }

  async function audioListFromManifestPath(p) {
    try {
      const files = await getFilesFromManifest(p);
      if (!files) return [];
      return files.filter(e => isAudioFile(e.name)).map(e => ({ 
        name: e.name, 
        url: e.url 
      }));
    } catch(e){}
    return [];
  }

  function stopAndCleanupPrevious(options){
    options = options || {};
    const revokeBlobUrls = options.revokeBlobUrls === true;
    try {
      if (window.gdjsChannels) {
        Object.keys(window.gdjsChannels).forEach(k=>{
          try {
            const a = window.gdjsChannels[k];
            if (!a) return;
            try { a.pause(); } catch(e){}
            try { a.currentTime = 0; } catch(e){}
            if (a._gdjs_ended_handler) { try { a.removeEventListener('ended', a._gdjs_ended_handler); } catch(e){} a._gdjs_ended_handler = null; }
            try { if (revokeBlobUrls && a.src && a.src.startsWith('blob:')) URL.revokeObjectURL(a.src); } catch(e){}
          } catch(e){}
        });
      }

      if (window.gdjsCustomAudio) {
        Object.keys(window.gdjsCustomAudio).forEach(folder=>{
          try {
            const entry = window.gdjsCustomAudio[folder] || {};
            const audios = entry.audios || {};
            Object.keys(audios).forEach(name=>{
              try {
                const info = audios[name] || {};
                if (info && info.blobUrl && revokeBlobUrls) {
                  try { URL.revokeObjectURL(info.blobUrl); } catch(e){}
                }
              } catch(e){}
            });
            try { delete window.gdjsCustomAudio[folder]; } catch(e){}
          } catch(e){}
        });
      }

      window.gdjsChannels = {};
    } catch(e){}
  }

  async function findAudioFilesWithFallback(rootFolder, difficultyPath) {
    const activeRepo = getActiveRepo();
    const manifest = await loadManifestPreferLocalFor(activeRepo, window.runtimeScene || undefined);

    async function audioListFromManifestPathLocal(p) {
      try {
        const files = await getFilesFromManifest(p);
        if (!files) return [];
        return files.filter(e => isAudioFile(e.name)).map(e => ({ name: e.name, url: e.url }));
      } catch(e){}
      return [];
    }

    async function audioListFromGithubPath(p) {
      try {
        const api = await ghListForFolderUsingEntry(activeRepo, p).catch(()=>[]);
        return (api || []).filter(i => i.type !== "dir" && isAudioFile(i.name)).map(i => ({ name: i.name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`) }));
      } catch(e){}
      return [];
    }

    // 1. Primeiro tenta na pasta da difficulty
    try {
      let list = await audioListFromManifestPathLocal(difficultyPath);
      if (list && list.length>0) return list;
      list = await audioListFromGithubPath(difficultyPath);
      if (list && list.length>0) return list;
    } catch(e){}

    // 2. Se não achou, tenta na pasta da música (rootFolder)
    try {
      let list = await audioListFromManifestPathLocal(rootFolder);
      if (list && list.length>0) return list;
      list = await audioListFromGithubPath(rootFolder);
      if (list && list.length>0) return list;
    } catch(e){}

    // 3. Se não achou, tenta na pasta do mod (pai da rootFolder)
    try {
      const parts = (rootFolder || "").split("/").filter(Boolean);
      if (parts.length >= 2) {
        const modFolder = parts.slice(0, parts.length - 1).join("/");
        if (modFolder) {
          let list = await audioListFromManifestPathLocal(modFolder);
          if (list && list.length>0) return list;
          list = await audioListFromGithubPath(modFolder);
          if (list && list.length>0) return list;
        }
      }
    } catch(e){}
    
    return [];
  }

  async function downloadDifficultyKeepAudioRoot(rootFolder, difficultyName) {
    const difficultyPath = (rootFolder? rootFolder + "/" + difficultyName : difficultyName);
    try { btnClose.disabled = true; } catch(e){}
    try {
      stopAndCleanupPrevious({ revokeBlobUrls: true });
      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("selectedTrackKey").setString(rootFolder); } catch(e){}
      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("SongName").setString(basenameNoExt(rootFolder.split("/").pop()||rootFolder));
      } catch(e){}
      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("SongDifficulty").setString(difficultyName);
      } catch(e){}

      setStatus("Listando arquivos (procura áudios: difficulty -> song -> mod)...");
      const audioFiles = await findAudioFilesWithFallback(rootFolder, difficultyPath);

      let chartFiles = [];
      const activeRepo = getActiveRepo();
      const files = await getFilesFromManifest(difficultyPath);
      if (files) {
        chartFiles = files.filter(e => isJsonFile(e.name)).map(e => ({ name: e.name, url: e.url }) );
      } else {
        try {
          const api = await ghListForFolderUsingEntry(activeRepo, difficultyPath);
          chartFiles = (api || []).filter(i => i.type !== "dir" && isJsonFile(i.name)).map(i => ({ name: i.name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`) }));
        } catch(e){}
      }

      let rootJsons = [];
      const rootFiles = await getFilesFromManifest(rootFolder);
      if (rootFiles) {
        rootJsons = rootFiles.filter(e => isJsonFile(e.name)).map(e => ({ name: e.name, url: e.url }) );
      } else {
        try {
          const api = await ghListForFolderUsingEntry(activeRepo, rootFolder);
          rootJsons = (api || []).filter(i => i.type !== "dir" && isJsonFile(i.name)).map(i => ({ name: i.name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`) }));
        } catch(e){}
      }

      const allJsonsMap = {};
      rootJsons.forEach(j => { allJsonsMap[j.name] = j; });
      chartFiles.forEach(j => { allJsonsMap[j.name] = j; });

      window.gdjsCustomAudio = window.gdjsCustomAudio || {};
      window.gdjsCustomAudio[rootFolder] = window.gdjsCustomAudio[rootFolder] || { audios: {}, rawFiles: {} };
      const dest = window.gdjsCustomAudio[rootFolder];

      let nextChannelIndex = 0;
      const unlockQueue = [];
      for (const f of (audioFiles || [])) {
        try {
          setStatus("Baixando áudio: " + f.name + "...");
          const resp = await fetch(f.url);
          if (!resp.ok) continue;
          const blob = await resp.blob();
          const blobUrl = URL.createObjectURL(blob);
          const audioEl = new Audio(blobUrl);
          audioEl.preload = "auto"; audioEl.crossOrigin = "anonymous"; audioEl.loop = false;
          dest.audios[f.name] = { blobUrl, audioEl };
          window.gdjsChannels[nextChannelIndex] = audioEl;
          nextChannelIndex++;
          try {
            const p = audioEl.play();
            if (p && typeof p.then === "function") {
              p.then(()=>{ try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }).catch(()=>{ unlockQueue.push({audioEl, name: f.name}); });
            } else { try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }
          } catch(e){ unlockQueue.push({audioEl, name: f.name});
          }
        } catch(e){}
        await sleep(0);
      }

      for (const name in allJsonsMap) {
        try {
          const j = allJsonsMap[name];
          setStatus("Baixando chart: " + name + "...");
          const r = await fetch(j.url);
          if (!r.ok) continue;
          const txt = await r.text();
          const key = difficultyName + "/" + name;
          dest.rawFiles[key] = txt;
          const lname = name.toLowerCase();
          const gg = (window.runtimeScene && window.runtimeScene.getGame) ? runtimeScene.getGame().getVariables() : null;
          if (gg) {
            if (/metadata|meta/.test(lname)) gg.get("metadatajson").setString(txt);
            else if (/(bf|chartbf|chart_bf)/.test(lname)) gg.get("BfChartJsonLoader").setString(txt);
            else if (/(dad|opp|opponent)/.test(lname)) gg.get("OppChartJsonLoader").setString(txt);
            else {
              try {
                const parsed = JSON.parse(txt);
                if (parsed && parsed.notes) {
                  if (!gg.get("BfChartJsonLoader").getAsString()) gg.get("BfChartJsonLoader").setString(txt);
                  else if (!gg.get("OppChartJsonLoader").getAsString()) gg.get("OppChartJsonLoader").setString(txt);
                  else if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                } else {
                  if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                }
              } catch(e){
                if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
              }
            }
          }
        } catch(e){}
        await sleep(0);
      }

      if (unlockQueue.length > 0) {
        const unlock = async () => { for (const it of unlockQueue) { try { await it.audioEl.play();
        it.audioEl.pause(); it.audioEl.currentTime = 0; } catch(e){} } window.removeEventListener('pointerdown', unlock); };
        window.addEventListener('pointerdown', unlock, { once: true });
      }

      setStatus('Download concluído para "' + rootFolder + '" (difficulty: ' + difficultyName + ').');
    } catch(e){
      setStatus("Erro ao baixar: " + (e && e.message ? e.message : e));
    } finally {
      try { btnClose.disabled = false;
      } catch(e){}
    }
  }

  async function downloadAllDifficulties(rootFolder, subdirs) {
    try { btnClose.disabled = true;
    } catch(e){}
    try {
      stopAndCleanupPrevious({ revokeBlobUrls: true });
      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("selectedTrackKey").setString(rootFolder); } catch(e){}
      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("SongName").setString(basenameNoExt(rootFolder.split("/").pop()||rootFolder));
      } catch(e){}
      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("SongDifficulty").setString(difficultyName);
      } catch(e){}

      setStatus("Procurando áudios (difficulty -> song -> mod)...");
      const hintDifficulty = (subdirs && subdirs.length>0) ? (rootFolder + "/" + subdirs[0]) : rootFolder;
      const audioFiles = await findAudioFilesWithFallback(rootFolder, hintDifficulty);
      window.gdjsCustomAudio = window.gdjsCustomAudio || {};
      window.gdjsCustomAudio[rootFolder] = window.gdjsCustomAudio[rootFolder] || { audios: {}, rawFiles: {} };
      const dest = window.gdjsCustomAudio[rootFolder];
      let nextChannelIndex = 0;
      const unlockQueue = [];
      for (const f of (audioFiles || [])) {
        try {
          setStatus("Baixando áudio: " + f.name + "...");
          const resp = await fetch(f.url);
          if (!resp.ok) continue;
          const blob = await resp.blob();
          const blobUrl = URL.createObjectURL(blob);
          const audioEl = new Audio(blobUrl);
          audioEl.preload = "auto"; audioEl.crossOrigin = "anonymous"; audioEl.loop = false;
          dest.audios[f.name] = { blobUrl, audioEl };
          window.gdjsChannels[nextChannelIndex] = audioEl;
          nextChannelIndex++;
          try {
            const p = audioEl.play();
            if (p && typeof p.then === "function") {
              p.then(()=>{ try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }).catch(()=>{ unlockQueue.push({audioEl, name: f.name}); });
            } else { try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }
          } catch(e){ unlockQueue.push({audioEl, name: f.name});
          }
        } catch(e){}
        await sleep(0);
      }

      const activeRepo = getActiveRepo();
      for (const d of subdirs) {
        try {
          setStatus("Baixando charts: " + d + " ...");
          let chartFiles = [];
          const difficultyPath = (rootFolder? rootFolder + "/" + d : d);
          const files = await getFilesFromManifest(difficultyPath);
          if (files) {
            chartFiles = files.filter(e => isJsonFile(e.name)).map(e => ({ name: e.name, url: e.url }) );
          } else {
            try {
              const api = await ghListForFolderUsingEntry(activeRepo, difficultyPath);
              chartFiles = (api || []).filter(i => i.type !== "dir" && isJsonFile(i.name)).map(i => ({ name: i.name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`) }));
            } catch(e){}
          }
          for (const j of chartFiles) {
            try {
              const r = await fetch(j.url);
              if (!r.ok) continue;
              const txt = await r.text();
              const key = d + "/" + j.name;
              dest.rawFiles[key] = txt;
              const lname = j.name.toLowerCase();
              const gg = (window.runtimeScene && window.runtimeScene.getGame) ? runtimeScene.getGame().getVariables() : null;
              if (gg) {
                if (/metadata|meta/.test(lname)) gg.get("metadatajson").setString(txt);
                else if (/(bf|chartbf|chart_bf)/.test(lname)) gg.get("BfChartJsonLoader").setString(txt);
                else if (/(dad|opp|opponent)/.test(lname)) gg.get("OppChartJsonLoader").setString(txt);
                else {
                  try {
                    const parsed = JSON.parse(txt);
                    if (parsed && parsed.notes) {
                      if (!gg.get("BfChartJsonLoader").getAsString()) gg.get("BfChartJsonLoader").setString(txt);
                      else if (!gg.get("OppChartJsonLoader").getAsString()) gg.get("OppChartJsonLoader").setString(txt);
                      else if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                    } else {
                      if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                    }
                  } catch(e){
                    if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                  }
                }
              }
            } catch(e){}
            await sleep(0);
          }
        } catch(e){}
      }

      if (unlockQueue.length > 0) {
        const unlock = async () => { for (const it of unlockQueue) { try { await it.audioEl.play();
        it.audioEl.pause(); it.audioEl.currentTime = 0; } catch(e){} } window.removeEventListener('pointerdown', unlock); };
        window.addEventListener('pointerdown', unlock, { once: true });
      }

      setStatus('Download concluído para "' + rootFolder + '" (todas difficulties).');
    } catch(e){
      setStatus("Erro ao baixar: " + (e && e.message ? e.message : e));
    } finally {
      try { btnClose.disabled = false;
      } catch(e){}
    }
  }

  async function downloadSongFolder(folderPath) {
    try { btnClose.disabled = true;
    } catch(e){}
    try {
      stopAndCleanupPrevious({ revokeBlobUrls: true });
      setStatus("Listando arquivos em " + folderPath + "...");

      let files = await getFilesFromManifest(folderPath);
      if (!files) {
        // Fallback para GitHub API
        const activeRepo = getActiveRepo();
        try {
          const apiList = await ghListForFolderUsingEntry(activeRepo, folderPath);
          files = (apiList || []).map(i => ({ 
            name: i.name, 
            url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`), 
            type: i.type 
          }));
          files = files.filter(x => x.type !== "dir");
        } catch(e){
          files = [];
        }
      }

      if (!Array.isArray(files) || files.length === 0) { setStatus("Pasta vazia.");
      return; }

      window.gdjsCustomAudio = window.gdjsCustomAudio || {};
      window.gdjsCustomAudio[folderPath] = window.gdjsCustomAudio[folderPath] || {audios:{}, rawFiles:{}};
      const dest = window.gdjsCustomAudio[folderPath];

      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("selectedTrackKey").setString(folderPath);
      } catch(e){}
      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("SongName").setString(basenameNoExt(folderPath.split("/").pop()||folderPath));
      } catch(e){}

      const totalFiles = files.length;
      let processed = 0;
      let nextChannelIndex = (window.gdjsChannels) ?
      Object.keys(window.gdjsChannels).length : 0;
      const unlockQueue = [];

      for (const f of files) {
        processed++;
        setStatus(`${processed} / ${totalFiles}`);
        const fname = f.name;
        const url = f.url;
        if (!url) continue;
        if (isJsonFile(fname)) {
          try {
            const txtResp = await fetch(url);
            if (txtResp.ok) {
              const txt = await txtResp.text();
              dest.rawFiles[fname] = txt;
              const lname = fname.toLowerCase();
              const gg = (window.runtimeScene && window.runtimeScene.getGame) ? runtimeScene.getGame().getVariables() : null;
              if (gg) {
                if (/metadata|meta/.test(lname)) gg.get("metadatajson").setString(txt);
                else if (/(bf|chartbf|chart_bf)/.test(lname)) gg.get("BfChartJsonLoader").setString(txt);
                else if (/(dad|opp|opponent)/.test(lname)) gg.get("OppChartJsonLoader").setString(txt);
                else {
                  try {
                    const parsed = JSON.parse(txt);
                    if (parsed && parsed.notes) {
                      if (!gg.get("BfChartJsonLoader").getAsString()) gg.get("BfChartJsonLoader").setString(txt);
                      else if (!gg.get("OppChartJsonLoader").getAsString()) gg.get("OppChartJsonLoader").setString(txt);
                      else if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                    } else {
                      if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                    }
                  } catch(e) {
                    if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                  }
                }
              }
            }
          } catch(e){}
        } else if (isAudioFile(fname)) {
          try {
            setStatus("Baixando áudio: " + fname + "...");
            const resp = await fetch(url);
            if (!resp.ok) continue;
            const blob = await resp.blob();
            const blobUrl = URL.createObjectURL(blob);
            const audioEl = new Audio(blobUrl);
            audioEl.preload = "auto"; audioEl.crossOrigin = "anonymous"; audioEl.loop = false;
            dest.audios[fname] = { blobUrl, audioEl, audioElRef: audioEl };
            window.gdjsChannels = window.gdjsChannels || {};
            window.gdjsChannels[nextChannelIndex] = audioEl;
            nextChannelIndex++;
            try {
              const p = audioEl.play();
              if (p && typeof p.then === "function") {
                p.then(()=>{ try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }).catch(()=>{ unlockQueue.push({audioEl, name: fname}); });
              } else { try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }
            } catch(e){ unlockQueue.push({audioEl, name: fname});
            }
            try { const gg = (window.runtimeScene && window.runtimeScene.getGame) ?
            runtimeScene.getGame().getVariables() : null; if (gg && !gg.get("SongName").getAsString()) gg.get("SongName").setString(basenameNoExt(fname)); } catch(e){}
          } catch(e){}
        }
        await sleep(0);
      }

      if (unlockQueue.length > 0) {
        const unlock = async () => { for (const it of unlockQueue) { try { await it.audioEl.play();
        it.audioEl.pause(); it.audioEl.currentTime = 0; } catch(e){} } window.removeEventListener('pointerdown', unlock); };
        window.addEventListener('pointerdown', unlock, { once: true });
      }

      setStatus('Download concluído para "' + folderPath + '".');
    } catch(e){
      setStatus("Erro ao baixar pasta: " + (e && e.message ? e.message : e));
    } finally {
      try { btnClose.disabled = false;
      } catch(e){}
    }
  }

  // --- difficulty chooser modal ---
  function showDifficultyChooser(rootFolder, subdirs) {
    const overlay = document.createElement("div");
    Object.assign(overlay.style, { position: "fixed", left: "0", top: "0", right: "0", bottom: "0", background: "rgba(0,0,0,0.6)", zIndex: 10000010, display: "flex", alignItems: "center", justifyContent: "center", pointerEvents: "auto" });
    const box = document.createElement("div");
    Object.assign(box.style, { width: "420px", maxHeight: "70vh", overflowY: "auto", background: "#0f0f10", borderRadius: "8px", padding: "12px", boxShadow: "0 12px 40px rgba(0,0,0,0.6)", color: "#eee" });
    box.innerHTML = `<div style="font-weight:700;margin-bottom:8px">Escolha uma difficulty para:</div><div style="margin-bottom:8px;color:#bbb">${rootFolder}</div>`;
    const list = document.createElement("div"); list.style.display = "flex"; list.style.flexDirection = "column";
    list.style.gap = "6px";
    for (const d of subdirs) {
      const b = document.createElement("button");
      b.textContent = d;
      b.style.padding="8px"; b.style.borderRadius="6px";
      b.onclick = ()=> { overlay.remove(); downloadDifficultyKeepAudioRoot(rootFolder, d); };
      list.appendChild(b);
    }
    const cancel = document.createElement("button"); cancel.textContent = "Cancelar"; cancel.style.marginTop="10px"; cancel.style.padding="8px"; cancel.style.borderRadius="6px";
    cancel.onclick = ()=> overlay.remove();
    box.appendChild(list); box.appendChild(cancel);
    overlay.appendChild(box);
    document.body.appendChild(overlay);
    setTimeout(()=> { try { overlay.focus(); } catch(e){} }, 0);
  }

  // --- events wiring ---
  btnClose.onclick = ()=> container.remove();
  btnManage.onclick = ()=> showRepoManagerModal();
  btnCache.onclick = ()=> showCacheManager();
  btnRefresh.onclick = async ()=> {
    try { setStatus("Atualizando...");
    } catch(e){}
    try { for (const it of modsList) delete hasSubCache[it.path];
    } catch(e){}
    try { Object.keys(_manifest_cache_by_repo).forEach(k=> delete _manifest_cache_by_repo[k]);
    } catch(e){}

    // Limpa do localstorage o manifest do repo ativo para forçar download novo
    try {
        const active = getActiveRepo();
        if(active && active.id) localStorage.removeItem(MANIFEST_CACHE_PREFIX + active.id);
    } catch(e){}

    // guarda qual mod estava aberto antes do refresh
    const prevOpen = currentModPath;
    // Recarrega a lista raiz (evita transformar songs em mods)
    await loadFolder("");
    // tenta reabrir o mod antigo (se ainda existir)
    try {
      if (prevOpen && prevOpen === "__favorites__") {
        openMod("__favorites__");
      } else if (prevOpen) {
        // pequeno delay para garantir que modsList foi populada
        setTimeout(()=>{
          try {
            const found = modsList.find(m => m.path === prevOpen);
            if (found) openMod(prevOpen);
          } catch(e){}
        }, 60);
      }
    } catch(e){}
  };

  // Substitua o handler de troca de repo (repoSelect.onchange) por este
  repoSelect.onchange = ()=> {
    try { setActiveRepoById(repoSelect.value);
    } catch(e){}
    try { Object.keys(_manifest_cache_by_repo).forEach(k=> delete _manifest_cache_by_repo[k]); } catch(e){}
    const prevOpen = currentModPath;
    // recarrega raiz e tenta reabrir o mod (se existir)
    loadFolder("").then(()=>{
      try {
        if (prevOpen && prevOpen === "__favorites__") {
          openMod("__favorites__");
        } else if (prevOpen) {
          const found = modsList.find(m => m.path === prevOpen);
          if (found) openMod(prevOpen);
        }
      } 
      catch(e){}
    }).catch(()=>{});
  };

  // SEARCH: agora impacta ambas as listas
  searchInput.addEventListener("input", ()=> {
    const q = searchInput.value.trim().toLowerCase();
    if (!q) {
      renderModsList(modsList);
      setStatus((currentModPath||"Mods")+` — ${modsList.length}`);
      // if a mod is open, re-open it to show all songs
      if (currentModPath) {
        if (currentModPath === "__favorites__") openMod("__favorites__");
        else openMod(currentModPath);
      } else {
        renderSongsList([]);
      }
      setTimeout(()=> startBackgroundCheckOnSongs(modsList), 10);
      return;
    }
    // filter mods by name
    const filteredMods = modsList.filter(it => (it.name || "").toLowerCase().includes(q));
    renderModsList(filteredMods);
    // also filter songs: if a mod is selected, filter its songs; if favorites selected, filter favorites
    if (currentModPath === "__favorites__") {
      const favItems = (favorites || []).map(f => ({ name: f.name || basenameNoExt(f.path.split("/").pop()||f.path), path: f.path 
      }));
      const filteredSongs = favItems.filter(s => (s.name || "").toLowerCase().includes(q));
      renderSongsList(filteredSongs);
      setStatus(`Resultado: ${filteredSongs.length} / ${favItems.length} (favorites)`);
    } else if (currentModPath) {
      // filter songsList (if current open)
      const filteredSongs = (songsList || []).filter(s => (s.name || "").toLowerCase().includes(q));
      renderSongsList(filteredSongs);
      setStatus(`Resultado: ${filteredSongs.length} / ${songsList.length}`);
      setTimeout(()=> startBackgroundCheckOnSongs(filteredSongs), 10);
    } else {
      // no mod open: just inform mods results
      setStatus(`Resultado: ${filteredMods.length} / ${modsList.length}`);
    }
  });

  (function init() {
    const list = loadRepoList();
    if (!list || list.length === 0) { saveRepoList([defaultRepoEntry()]); }
    renderRepoSelect();
    loadFolder("");
    // expose runtimeScene if exists
    try { if (typeof runtimeScene !== "undefined") window.runtimeScene = runtimeScene; } catch(e){}
    // push favorites to runtime variable on init
    try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("FavoriteSongs").setString(JSON.stringify(favorites || [])); } catch(e){}
  })();
})();
};
gdjs.PlayonlineCode.eventsList7 = function(runtimeScene) {

{


gdjs.PlayonlineCode.userFunc0x28a95e8(runtimeScene);

}


};gdjs.PlayonlineCode.mapOfGDgdjs_9546PlayonlineCode_9546GDStartObjects1Objects = Hashtable.newFrom({"Start": gdjs.PlayonlineCode.GDStartObjects1});
gdjs.PlayonlineCode.eventsList8 = function(runtimeScene) {

{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.evtTools.runtimeScene.sceneJustBegins(runtimeScene);
if (isConditionTrue_0) {
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(28));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(29));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(30));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(31));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(32));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(33));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(34));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(35));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(26));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(60));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(58));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(89).getChild("BestScore"));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(89).getChild("SongsBestScore"));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(89).getChild("Points"));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(89).getChild("PointsMessage"));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(89).getChild("Pfcs"));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(62).getChild(4));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(58));
}
{gdjs.evtTools.runtimeScene.prioritizeLoadingOfScene(runtimeScene, "Play");
}
{runtimeScene.getGame().getVariables().getFromIndex(10).setNumber(1);
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(15));
}
{gdjs.multiplayerVariablesManager.setPlayerVariableOwnership(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(8), 2);
}
{gdjs.multiplayerVariablesManager.setPlayerVariableOwnership(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(9), 2);
}
{gdjs.multiplayerVariablesManager.setPlayerVariableOwnership(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(6), 1);
}
{gdjs.multiplayerVariablesManager.setPlayerVariableOwnership(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(7), 1);
}

{ //Subevents
gdjs.PlayonlineCode.eventsList1(runtimeScene);} //End of subevents
}

}


{

gdjs.copyArray(runtimeScene.getObjects("Join"), gdjs.PlayonlineCode.GDJoinObjects1);

let isConditionTrue_0 = false;
isConditionTrue_0 = false;
for (var i = 0, k = 0, l = gdjs.PlayonlineCode.GDJoinObjects1.length;i<l;++i) {
    if ( gdjs.PlayonlineCode.GDJoinObjects1[i].IsClicked(null) ) {
        isConditionTrue_0 = true;
        gdjs.PlayonlineCode.GDJoinObjects1[k] = gdjs.PlayonlineCode.GDJoinObjects1[i];
        ++k;
    }
}
gdjs.PlayonlineCode.GDJoinObjects1.length = k;
if (isConditionTrue_0) {
isConditionTrue_0 = false;
{isConditionTrue_0 = runtimeScene.getOnceTriggers().triggerOnce(31389148);
}
}
if (isConditionTrue_0) {

{ //Subevents
gdjs.PlayonlineCode.eventsList2(runtimeScene);} //End of subevents
}

}


{

gdjs.copyArray(runtimeScene.getObjects("Join2"), gdjs.PlayonlineCode.GDJoin2Objects1);

let isConditionTrue_0 = false;
isConditionTrue_0 = false;
for (var i = 0, k = 0, l = gdjs.PlayonlineCode.GDJoin2Objects1.length;i<l;++i) {
    if ( gdjs.PlayonlineCode.GDJoin2Objects1[i].IsClicked(null) ) {
        isConditionTrue_0 = true;
        gdjs.PlayonlineCode.GDJoin2Objects1[k] = gdjs.PlayonlineCode.GDJoin2Objects1[i];
        ++k;
    }
}
gdjs.PlayonlineCode.GDJoin2Objects1.length = k;
if (isConditionTrue_0) {
isConditionTrue_0 = false;
{isConditionTrue_0 = runtimeScene.getOnceTriggers().triggerOnce(36067948);
}
}
if (isConditionTrue_0) {

{ //Subevents
gdjs.PlayonlineCode.eventsList3(runtimeScene);} //End of subevents
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isLobbyGameRunning();
if (isConditionTrue_0) {
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isPlayerConnected(2);
if (isConditionTrue_0) {
isConditionTrue_0 = false;
{isConditionTrue_0 = runtimeScene.getOnceTriggers().triggerOnce(36057052);
}
}
}
if (isConditionTrue_0) {
gdjs.copyArray(runtimeScene.getObjects("Player1text"), gdjs.PlayonlineCode.GDPlayer1textObjects1);
gdjs.copyArray(runtimeScene.getObjects("Player2text"), gdjs.PlayonlineCode.GDPlayer2textObjects1);
{for(var i = 0, len = gdjs.PlayonlineCode.GDPlayer1textObjects1.length ;i < len;++i) {
    gdjs.PlayonlineCode.GDPlayer1textObjects1[i].getBehavior("Text").setText(gdjs.multiplayer.getPlayerUsername(1) + gdjs.evtTools.string.newLine() + "v");
}
}
{for(var i = 0, len = gdjs.PlayonlineCode.GDPlayer2textObjects1.length ;i < len;++i) {
    gdjs.PlayonlineCode.GDPlayer2textObjects1[i].getBehavior("Text").setText(gdjs.multiplayer.getPlayerUsername(2) + gdjs.evtTools.string.newLine() + "v");
}
}

{ //Subevents
gdjs.PlayonlineCode.eventsList4(runtimeScene);} //End of subevents
}

}


{


let isConditionTrue_0 = false;
{
{runtimeScene.getGame().getVariables().getFromIndex(9).setString(runtimeScene.getGame().getVariables().getFromIndex(8).getAsString());
}
{runtimeScene.getGame().getVariables().getFromIndex(7).setString(runtimeScene.getGame().getVariables().getFromIndex(6).getAsString());
}
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isLobbyGameRunning();
if (isConditionTrue_0) {
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isPlayerConnected(2);
if (isConditionTrue_0) {
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isCurrentPlayerHost();
}
}
if (isConditionTrue_0) {
{runtimeScene.getGame().getVariables().getFromIndex(17).setNumber(1);
}
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isLobbyGameRunning();
if (isConditionTrue_0) {
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isPlayerConnected(2);
if (isConditionTrue_0) {
isConditionTrue_0 = false;
isConditionTrue_0 = !(gdjs.multiplayer.isCurrentPlayerHost());
}
}
if (isConditionTrue_0) {
{runtimeScene.getGame().getVariables().getFromIndex(17).setNumber(2);
}
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.evtTools.runtimeScene.sceneJustBegins(runtimeScene);
if (isConditionTrue_0) {

{ //Subevents
gdjs.PlayonlineCode.eventsList5(runtimeScene);} //End of subevents
}

}


{

gdjs.copyArray(runtimeScene.getObjects("Hard"), gdjs.PlayonlineCode.GDHardObjects1);

let isConditionTrue_0 = false;
isConditionTrue_0 = false;
for (var i = 0, k = 0, l = gdjs.PlayonlineCode.GDHardObjects1.length;i<l;++i) {
    if ( gdjs.PlayonlineCode.GDHardObjects1[i].getBehavior("MultitouchButton").IsJustPressed(null) ) {
        isConditionTrue_0 = true;
        gdjs.PlayonlineCode.GDHardObjects1[k] = gdjs.PlayonlineCode.GDHardObjects1[i];
        ++k;
    }
}
gdjs.PlayonlineCode.GDHardObjects1.length = k;
if (isConditionTrue_0) {
isConditionTrue_0 = false;
{isConditionTrue_0 = runtimeScene.getOnceTriggers().triggerOnce(36048428);
}
}
if (isConditionTrue_0) {

{ //Subevents
gdjs.PlayonlineCode.eventsList6(runtimeScene);} //End of subevents
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isLobbyGameRunning();
if (isConditionTrue_0) {
isConditionTrue_0 = false;
isConditionTrue_0 = !(gdjs.multiplayer.isPlayerConnected(2));
}
if (isConditionTrue_0) {
{gdjs.multiplayer.endLobbyGame();
}
}

}


{

gdjs.copyArray(runtimeScene.getObjects("selesongtext"), gdjs.PlayonlineCode.GDselesongtextObjects1);

let isConditionTrue_0 = false;
isConditionTrue_0 = false;
for (var i = 0, k = 0, l = gdjs.PlayonlineCode.GDselesongtextObjects1.length;i<l;++i) {
    if ( gdjs.PlayonlineCode.GDselesongtextObjects1[i].getBehavior("ButtonFSM").IsClicked(null) ) {
        isConditionTrue_0 = true;
        gdjs.PlayonlineCode.GDselesongtextObjects1[k] = gdjs.PlayonlineCode.GDselesongtextObjects1[i];
        ++k;
    }
}
gdjs.PlayonlineCode.GDselesongtextObjects1.length = k;
if (isConditionTrue_0) {
isConditionTrue_0 = false;
{isConditionTrue_0 = runtimeScene.getOnceTriggers().triggerOnce(15937164);
}
}
if (isConditionTrue_0) {

{ //Subevents
gdjs.PlayonlineCode.eventsList7(runtimeScene);} //End of subevents
}

}


{



}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isCurrentPlayerHost();
if (isConditionTrue_0) {
isConditionTrue_0 = false;
{isConditionTrue_0 = runtimeScene.getOnceTriggers().triggerOnce(15938964);
}
}
if (isConditionTrue_0) {
gdjs.PlayonlineCode.GDStartObjects1.length = 0;

{gdjs.evtTools.object.createObjectOnScene(runtimeScene, gdjs.PlayonlineCode.mapOfGDgdjs_9546PlayonlineCode_9546GDStartObjects1Objects, 3058, 651, "");
}
}

}


{


let isConditionTrue_0 = false;
{
gdjs.copyArray(runtimeScene.getObjects("songselectedtext"), gdjs.PlayonlineCode.GDsongselectedtextObjects1);
{for(var i = 0, len = gdjs.PlayonlineCode.GDsongselectedtextObjects1.length ;i < len;++i) {
    gdjs.PlayonlineCode.GDsongselectedtextObjects1[i].getBehavior("Text").setText("Song Selected: " + runtimeScene.getGame().getVariables().getFromIndex(5).getAsString());
}
}
}

}


{



}


{

gdjs.copyArray(runtimeScene.getObjects("Start"), gdjs.PlayonlineCode.GDStartObjects1);

let isConditionTrue_0 = false;
isConditionTrue_0 = false;
for (var i = 0, k = 0, l = gdjs.PlayonlineCode.GDStartObjects1.length;i<l;++i) {
    if ( gdjs.PlayonlineCode.GDStartObjects1[i].IsClicked(null) ) {
        isConditionTrue_0 = true;
        gdjs.PlayonlineCode.GDStartObjects1[k] = gdjs.PlayonlineCode.GDStartObjects1[i];
        ++k;
    }
}
gdjs.PlayonlineCode.GDStartObjects1.length = k;
if (isConditionTrue_0) {
isConditionTrue_0 = false;
{isConditionTrue_0 = (runtimeScene.getGame().getVariables().getFromIndex(5).getAsString() != "None");
}
}
if (isConditionTrue_0) {
{gdjs.evtTools.runtimeScene.replaceScene(runtimeScene, "Play", false);
}
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayerMessageManager.hasAnyPlayerJustLeft();
if (isConditionTrue_0) {
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.evtTools.camera.getCameraX(runtimeScene, "", 0) == 2220 + 960;
}
if (isConditionTrue_0) {
{gdjs.evtTools.camera.setCameraX(runtimeScene, 960, "", 0);
}
}

}


{

gdjs.copyArray(runtimeScene.getObjects("PauseButton"), gdjs.PlayonlineCode.GDPauseButtonObjects1);

let isConditionTrue_0 = false;
isConditionTrue_0 = false;
for (var i = 0, k = 0, l = gdjs.PlayonlineCode.GDPauseButtonObjects1.length;i<l;++i) {
    if ( gdjs.PlayonlineCode.GDPauseButtonObjects1[i].getBehavior("ButtonFSM").IsClicked(null) ) {
        isConditionTrue_0 = true;
        gdjs.PlayonlineCode.GDPauseButtonObjects1[k] = gdjs.PlayonlineCode.GDPauseButtonObjects1[i];
        ++k;
    }
}
gdjs.PlayonlineCode.GDPauseButtonObjects1.length = k;
if (isConditionTrue_0) {
{gdjs.evtTools.runtimeScene.replaceScene(runtimeScene, "Inicio", false);
}
}

}


};

gdjs.PlayonlineCode.func = function(runtimeScene) {
runtimeScene.getOnceTriggers().startNewFrame();

gdjs.PlayonlineCode.GDJoinObjects1.length = 0;
gdjs.PlayonlineCode.GDJoinObjects2.length = 0;
gdjs.PlayonlineCode.GDJoinObjects3.length = 0;
gdjs.PlayonlineCode.GDbackObjects1.length = 0;
gdjs.PlayonlineCode.GDbackObjects2.length = 0;
gdjs.PlayonlineCode.GDbackObjects3.length = 0;
gdjs.PlayonlineCode.GDBFObjects1.length = 0;
gdjs.PlayonlineCode.GDBFObjects2.length = 0;
gdjs.PlayonlineCode.GDBFObjects3.length = 0;
gdjs.PlayonlineCode.GDPlayer2textObjects1.length = 0;
gdjs.PlayonlineCode.GDPlayer2textObjects2.length = 0;
gdjs.PlayonlineCode.GDPlayer2textObjects3.length = 0;
gdjs.PlayonlineCode.GDPlayer1textObjects1.length = 0;
gdjs.PlayonlineCode.GDPlayer1textObjects2.length = 0;
gdjs.PlayonlineCode.GDPlayer1textObjects3.length = 0;
gdjs.PlayonlineCode.GDselesongtextObjects1.length = 0;
gdjs.PlayonlineCode.GDselesongtextObjects2.length = 0;
gdjs.PlayonlineCode.GDselesongtextObjects3.length = 0;
gdjs.PlayonlineCode.GDsongselectedtextObjects1.length = 0;
gdjs.PlayonlineCode.GDsongselectedtextObjects2.length = 0;
gdjs.PlayonlineCode.GDsongselectedtextObjects3.length = 0;
gdjs.PlayonlineCode.GDStartObjects1.length = 0;
gdjs.PlayonlineCode.GDStartObjects2.length = 0;
gdjs.PlayonlineCode.GDStartObjects3.length = 0;
gdjs.PlayonlineCode.GDBFPixelObjects1.length = 0;
gdjs.PlayonlineCode.GDBFPixelObjects2.length = 0;
gdjs.PlayonlineCode.GDBFPixelObjects3.length = 0;
gdjs.PlayonlineCode.GDHardObjects1.length = 0;
gdjs.PlayonlineCode.GDHardObjects2.length = 0;
gdjs.PlayonlineCode.GDHardObjects3.length = 0;
gdjs.PlayonlineCode.GDBackObjects1.length = 0;
gdjs.PlayonlineCode.GDBackObjects2.length = 0;
gdjs.PlayonlineCode.GDBackObjects3.length = 0;
gdjs.PlayonlineCode.GDJoin2Objects1.length = 0;
gdjs.PlayonlineCode.GDJoin2Objects2.length = 0;
gdjs.PlayonlineCode.GDJoin2Objects3.length = 0;
gdjs.PlayonlineCode.GDStatisticsObjects1.length = 0;
gdjs.PlayonlineCode.GDStatisticsObjects2.length = 0;
gdjs.PlayonlineCode.GDStatisticsObjects3.length = 0;
gdjs.PlayonlineCode.GDComboNumbersObjects1.length = 0;
gdjs.PlayonlineCode.GDComboNumbersObjects2.length = 0;
gdjs.PlayonlineCode.GDComboNumbersObjects3.length = 0;
gdjs.PlayonlineCode.GDNotesSplashObjects1.length = 0;
gdjs.PlayonlineCode.GDNotesSplashObjects2.length = 0;
gdjs.PlayonlineCode.GDNotesSplashObjects3.length = 0;
gdjs.PlayonlineCode.GDfpsObjects1.length = 0;
gdjs.PlayonlineCode.GDfpsObjects2.length = 0;
gdjs.PlayonlineCode.GDfpsObjects3.length = 0;
gdjs.PlayonlineCode.GDEngineTextObjects1.length = 0;
gdjs.PlayonlineCode.GDEngineTextObjects2.length = 0;
gdjs.PlayonlineCode.GDEngineTextObjects3.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollBFObjects1.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollBFObjects2.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollBFObjects3.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects1.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects2.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects3.length = 0;
gdjs.PlayonlineCode.GDHitboxLeftObjects1.length = 0;
gdjs.PlayonlineCode.GDHitboxLeftObjects2.length = 0;
gdjs.PlayonlineCode.GDHitboxLeftObjects3.length = 0;
gdjs.PlayonlineCode.GDHitboxDownObjects1.length = 0;
gdjs.PlayonlineCode.GDHitboxDownObjects2.length = 0;
gdjs.PlayonlineCode.GDHitboxDownObjects3.length = 0;
gdjs.PlayonlineCode.GDHitboxUpObjects1.length = 0;
gdjs.PlayonlineCode.GDHitboxUpObjects2.length = 0;
gdjs.PlayonlineCode.GDHitboxUpObjects3.length = 0;
gdjs.PlayonlineCode.GDhitrightObjects1.length = 0;
gdjs.PlayonlineCode.GDhitrightObjects2.length = 0;
gdjs.PlayonlineCode.GDhitrightObjects3.length = 0;
gdjs.PlayonlineCode.GDBFIconObjects1.length = 0;
gdjs.PlayonlineCode.GDBFIconObjects2.length = 0;
gdjs.PlayonlineCode.GDBFIconObjects3.length = 0;
gdjs.PlayonlineCode.GDPauseButtonObjects1.length = 0;
gdjs.PlayonlineCode.GDPauseButtonObjects2.length = 0;
gdjs.PlayonlineCode.GDPauseButtonObjects3.length = 0;
gdjs.PlayonlineCode.GDPauseButton2Objects1.length = 0;
gdjs.PlayonlineCode.GDPauseButton2Objects2.length = 0;
gdjs.PlayonlineCode.GDPauseButton2Objects3.length = 0;
gdjs.PlayonlineCode.GDBlackScreenObjects1.length = 0;
gdjs.PlayonlineCode.GDBlackScreenObjects2.length = 0;
gdjs.PlayonlineCode.GDBlackScreenObjects3.length = 0;
gdjs.PlayonlineCode.GDPauseTextObjects1.length = 0;
gdjs.PlayonlineCode.GDPauseTextObjects2.length = 0;
gdjs.PlayonlineCode.GDPauseTextObjects3.length = 0;
gdjs.PlayonlineCode.GDExitTextObjects1.length = 0;
gdjs.PlayonlineCode.GDExitTextObjects2.length = 0;
gdjs.PlayonlineCode.GDExitTextObjects3.length = 0;
gdjs.PlayonlineCode.GDRestartTextObjects1.length = 0;
gdjs.PlayonlineCode.GDRestartTextObjects2.length = 0;
gdjs.PlayonlineCode.GDRestartTextObjects3.length = 0;
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects1.length = 0;
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects2.length = 0;
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects3.length = 0;
gdjs.PlayonlineCode.GDBfUpNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDBfUpNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDBfUpNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDBfDownNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDBfDownNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDBfDownNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDBfLeftNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDBfLeftNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDBfLeftNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDBfRightNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDBfRightNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDBfRightNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDOppIconObjects1.length = 0;
gdjs.PlayonlineCode.GDOppIconObjects2.length = 0;
gdjs.PlayonlineCode.GDOppIconObjects3.length = 0;
gdjs.PlayonlineCode.GDtimerBarObjects1.length = 0;
gdjs.PlayonlineCode.GDtimerBarObjects2.length = 0;
gdjs.PlayonlineCode.GDtimerBarObjects3.length = 0;
gdjs.PlayonlineCode.GDtimeObjects1.length = 0;
gdjs.PlayonlineCode.GDtimeObjects2.length = 0;
gdjs.PlayonlineCode.GDtimeObjects3.length = 0;
gdjs.PlayonlineCode.GDtimerBar2Objects1.length = 0;
gdjs.PlayonlineCode.GDtimerBar2Objects2.length = 0;
gdjs.PlayonlineCode.GDtimerBar2Objects3.length = 0;
gdjs.PlayonlineCode.GDRatinsPopUpObjects1.length = 0;
gdjs.PlayonlineCode.GDRatinsPopUpObjects2.length = 0;
gdjs.PlayonlineCode.GDRatinsPopUpObjects3.length = 0;
gdjs.PlayonlineCode.GDLongNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDLongNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDLongNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDnotesObjects1.length = 0;
gdjs.PlayonlineCode.GDnotesObjects2.length = 0;
gdjs.PlayonlineCode.GDnotesObjects3.length = 0;
gdjs.PlayonlineCode.GDOppLeftNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDOppLeftNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDOppLeftNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDOppDownNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDOppDownNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDOppDownNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDOppUpNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDOppUpNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDOppUpNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDOppRightNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDOppRightNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDOppRightNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDLongNoteOppObjects1.length = 0;
gdjs.PlayonlineCode.GDLongNoteOppObjects2.length = 0;
gdjs.PlayonlineCode.GDLongNoteOppObjects3.length = 0;
gdjs.PlayonlineCode.GDStatistics2Objects1.length = 0;
gdjs.PlayonlineCode.GDStatistics2Objects2.length = 0;
gdjs.PlayonlineCode.GDStatistics2Objects3.length = 0;

gdjs.PlayonlineCode.eventsList8(runtimeScene);
gdjs.PlayonlineCode.GDJoinObjects1.length = 0;
gdjs.PlayonlineCode.GDJoinObjects2.length = 0;
gdjs.PlayonlineCode.GDJoinObjects3.length = 0;
gdjs.PlayonlineCode.GDbackObjects1.length = 0;
gdjs.PlayonlineCode.GDbackObjects2.length = 0;
gdjs.PlayonlineCode.GDbackObjects3.length = 0;
gdjs.PlayonlineCode.GDBFObjects1.length = 0;
gdjs.PlayonlineCode.GDBFObjects2.length = 0;
gdjs.PlayonlineCode.GDBFObjects3.length = 0;
gdjs.PlayonlineCode.GDPlayer2textObjects1.length = 0;
gdjs.PlayonlineCode.GDPlayer2textObjects2.length = 0;
gdjs.PlayonlineCode.GDPlayer2textObjects3.length = 0;
gdjs.PlayonlineCode.GDPlayer1textObjects1.length = 0;
gdjs.PlayonlineCode.GDPlayer1textObjects2.length = 0;
gdjs.PlayonlineCode.GDPlayer1textObjects3.length = 0;
gdjs.PlayonlineCode.GDselesongtextObjects1.length = 0;
gdjs.PlayonlineCode.GDselesongtextObjects2.length = 0;
gdjs.PlayonlineCode.GDselesongtextObjects3.length = 0;
gdjs.PlayonlineCode.GDsongselectedtextObjects1.length = 0;
gdjs.PlayonlineCode.GDsongselectedtextObjects2.length = 0;
gdjs.PlayonlineCode.GDsongselectedtextObjects3.length = 0;
gdjs.PlayonlineCode.GDStartObjects1.length = 0;
gdjs.PlayonlineCode.GDStartObjects2.length = 0;
gdjs.PlayonlineCode.GDStartObjects3.length = 0;
gdjs.PlayonlineCode.GDBFPixelObjects1.length = 0;
gdjs.PlayonlineCode.GDBFPixelObjects2.length = 0;
gdjs.PlayonlineCode.GDBFPixelObjects3.length = 0;
gdjs.PlayonlineCode.GDHardObjects1.length = 0;
gdjs.PlayonlineCode.GDHardObjects2.length = 0;
gdjs.PlayonlineCode.GDHardObjects3.length = 0;
gdjs.PlayonlineCode.GDBackObjects1.length = 0;
gdjs.PlayonlineCode.GDBackObjects2.length = 0;
gdjs.PlayonlineCode.GDBackObjects3.length = 0;
gdjs.PlayonlineCode.GDJoin2Objects1.length = 0;
gdjs.PlayonlineCode.GDJoin2Objects2.length = 0;
gdjs.PlayonlineCode.GDJoin2Objects3.length = 0;
gdjs.PlayonlineCode.GDStatisticsObjects1.length = 0;
gdjs.PlayonlineCode.GDStatisticsObjects2.length = 0;
gdjs.PlayonlineCode.GDStatisticsObjects3.length = 0;
gdjs.PlayonlineCode.GDComboNumbersObjects1.length = 0;
gdjs.PlayonlineCode.GDComboNumbersObjects2.length = 0;
gdjs.PlayonlineCode.GDComboNumbersObjects3.length = 0;
gdjs.PlayonlineCode.GDNotesSplashObjects1.length = 0;
gdjs.PlayonlineCode.GDNotesSplashObjects2.length = 0;
gdjs.PlayonlineCode.GDNotesSplashObjects3.length = 0;
gdjs.PlayonlineCode.GDfpsObjects1.length = 0;
gdjs.PlayonlineCode.GDfpsObjects2.length = 0;
gdjs.PlayonlineCode.GDfpsObjects3.length = 0;
gdjs.PlayonlineCode.GDEngineTextObjects1.length = 0;
gdjs.PlayonlineCode.GDEngineTextObjects2.length = 0;
gdjs.PlayonlineCode.GDEngineTextObjects3.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollBFObjects1.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollBFObjects2.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollBFObjects3.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects1.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects2.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects3.length = 0;
gdjs.PlayonlineCode.GDHitboxLeftObjects1.length = 0;
gdjs.PlayonlineCode.GDHitboxLeftObjects2.length = 0;
gdjs.PlayonlineCode.GDHitboxLeftObjects3.length = 0;
gdjs.PlayonlineCode.GDHitboxDownObjects1.length = 0;
gdjs.PlayonlineCode.GDHitboxDownObjects2.length = 0;
gdjs.PlayonlineCode.GDHitboxDownObjects3.length = 0;
gdjs.PlayonlineCode.GDHitboxUpObjects1.length = 0;
gdjs.PlayonlineCode.GDHitboxUpObjects2.length = 0;
gdjs.PlayonlineCode.GDHitboxUpObjects3.length = 0;
gdjs.PlayonlineCode.GDhitrightObjects1.length = 0;
gdjs.PlayonlineCode.GDhitrightObjects2.length = 0;
gdjs.PlayonlineCode.GDhitrightObjects3.length = 0;
gdjs.PlayonlineCode.GDBFIconObjects1.length = 0;
gdjs.PlayonlineCode.GDBFIconObjects2.length = 0;
gdjs.PlayonlineCode.GDBFIconObjects3.length = 0;
gdjs.PlayonlineCode.GDPauseButtonObjects1.length = 0;
gdjs.PlayonlineCode.GDPauseButtonObjects2.length = 0;
gdjs.PlayonlineCode.GDPauseButtonObjects3.length = 0;
gdjs.PlayonlineCode.GDPauseButton2Objects1.length = 0;
gdjs.PlayonlineCode.GDPauseButton2Objects2.length = 0;
gdjs.PlayonlineCode.GDPauseButton2Objects3.length = 0;
gdjs.PlayonlineCode.GDBlackScreenObjects1.length = 0;
gdjs.PlayonlineCode.GDBlackScreenObjects2.length = 0;
gdjs.PlayonlineCode.GDBlackScreenObjects3.length = 0;
gdjs.PlayonlineCode.GDPauseTextObjects1.length = 0;
gdjs.PlayonlineCode.GDPauseTextObjects2.length = 0;
gdjs.PlayonlineCode.GDPauseTextObjects3.length = 0;
gdjs.PlayonlineCode.GDExitTextObjects1.length = 0;
gdjs.PlayonlineCode.GDExitTextObjects2.length = 0;
gdjs.PlayonlineCode.GDExitTextObjects3.length = 0;
gdjs.PlayonlineCode.GDRestartTextObjects1.length = 0;
gdjs.PlayonlineCode.GDRestartTextObjects2.length = 0;
gdjs.PlayonlineCode.GDRestartTextObjects3.length = 0;
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects1.length = 0;
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects2.length = 0;
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects3.length = 0;
gdjs.PlayonlineCode.GDBfUpNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDBfUpNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDBfUpNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDBfDownNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDBfDownNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDBfDownNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDBfLeftNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDBfLeftNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDBfLeftNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDBfRightNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDBfRightNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDBfRightNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDOppIconObjects1.length = 0;
gdjs.PlayonlineCode.GDOppIconObjects2.length = 0;
gdjs.PlayonlineCode.GDOppIconObjects3.length = 0;
gdjs.PlayonlineCode.GDtimerBarObjects1.length = 0;
gdjs.PlayonlineCode.GDtimerBarObjects2.length = 0;
gdjs.PlayonlineCode.GDtimerBarObjects3.length = 0;
gdjs.PlayonlineCode.GDtimeObjects1.length = 0;
gdjs.PlayonlineCode.GDtimeObjects2.length = 0;
gdjs.PlayonlineCode.GDtimeObjects3.length = 0;
gdjs.PlayonlineCode.GDtimerBar2Objects1.length = 0;
gdjs.PlayonlineCode.GDtimerBar2Objects2.length = 0;
gdjs.PlayonlineCode.GDtimerBar2Objects3.length = 0;
gdjs.PlayonlineCode.GDRatinsPopUpObjects1.length = 0;
gdjs.PlayonlineCode.GDRatinsPopUpObjects2.length = 0;
gdjs.PlayonlineCode.GDRatinsPopUpObjects3.length = 0;
gdjs.PlayonlineCode.GDLongNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDLongNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDLongNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDnotesObjects1.length = 0;
gdjs.PlayonlineCode.GDnotesObjects2.length = 0;
gdjs.PlayonlineCode.GDnotesObjects3.length = 0;
gdjs.PlayonlineCode.GDOppLeftNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDOppLeftNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDOppLeftNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDOppDownNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDOppDownNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDOppDownNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDOppUpNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDOppUpNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDOppUpNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDOppRightNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDOppRightNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDOppRightNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDLongNoteOppObjects1.length = 0;
gdjs.PlayonlineCode.GDLongNoteOppObjects2.length = 0;
gdjs.PlayonlineCode.GDLongNoteOppObjects3.length = 0;
gdjs.PlayonlineCode.GDStatistics2Objects1.length = 0;
gdjs.PlayonlineCode.GDStatistics2Objects2.length = 0;
gdjs.PlayonlineCode.GDStatistics2Objects3.length = 0;


return;

}

gdjs['PlayonlineCode'] = gdjs.PlayonlineCode;
