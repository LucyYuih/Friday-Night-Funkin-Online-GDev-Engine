gdjs.PlayonlineCode = {};
gdjs.PlayonlineCode.localVariables = [];
gdjs.PlayonlineCode.idToCallbackMap = new Map();
gdjs.PlayonlineCode.GDJoinObjects1= [];
gdjs.PlayonlineCode.GDJoinObjects2= [];
gdjs.PlayonlineCode.GDJoinObjects3= [];
gdjs.PlayonlineCode.GDbackObjects1= [];
gdjs.PlayonlineCode.GDbackObjects2= [];
gdjs.PlayonlineCode.GDbackObjects3= [];
gdjs.PlayonlineCode.GDBFObjects1= [];
gdjs.PlayonlineCode.GDBFObjects2= [];
gdjs.PlayonlineCode.GDBFObjects3= [];
gdjs.PlayonlineCode.GDPlayer2textObjects1= [];
gdjs.PlayonlineCode.GDPlayer2textObjects2= [];
gdjs.PlayonlineCode.GDPlayer2textObjects3= [];
gdjs.PlayonlineCode.GDPlayer1textObjects1= [];
gdjs.PlayonlineCode.GDPlayer1textObjects2= [];
gdjs.PlayonlineCode.GDPlayer1textObjects3= [];
gdjs.PlayonlineCode.GDselesongtextObjects1= [];
gdjs.PlayonlineCode.GDselesongtextObjects2= [];
gdjs.PlayonlineCode.GDselesongtextObjects3= [];
gdjs.PlayonlineCode.GDsongselectedtextObjects1= [];
gdjs.PlayonlineCode.GDsongselectedtextObjects2= [];
gdjs.PlayonlineCode.GDsongselectedtextObjects3= [];
gdjs.PlayonlineCode.GDStartObjects1= [];
gdjs.PlayonlineCode.GDStartObjects2= [];
gdjs.PlayonlineCode.GDStartObjects3= [];
gdjs.PlayonlineCode.GDBFPixelObjects1= [];
gdjs.PlayonlineCode.GDBFPixelObjects2= [];
gdjs.PlayonlineCode.GDBFPixelObjects3= [];
gdjs.PlayonlineCode.GDHardObjects1= [];
gdjs.PlayonlineCode.GDHardObjects2= [];
gdjs.PlayonlineCode.GDHardObjects3= [];
gdjs.PlayonlineCode.GDBackObjects1= [];
gdjs.PlayonlineCode.GDBackObjects2= [];
gdjs.PlayonlineCode.GDBackObjects3= [];
gdjs.PlayonlineCode.GDJoin2Objects1= [];
gdjs.PlayonlineCode.GDJoin2Objects2= [];
gdjs.PlayonlineCode.GDJoin2Objects3= [];
gdjs.PlayonlineCode.GDStatisticsObjects1= [];
gdjs.PlayonlineCode.GDStatisticsObjects2= [];
gdjs.PlayonlineCode.GDStatisticsObjects3= [];
gdjs.PlayonlineCode.GDComboNumbersObjects1= [];
gdjs.PlayonlineCode.GDComboNumbersObjects2= [];
gdjs.PlayonlineCode.GDComboNumbersObjects3= [];
gdjs.PlayonlineCode.GDNotesSplashObjects1= [];
gdjs.PlayonlineCode.GDNotesSplashObjects2= [];
gdjs.PlayonlineCode.GDNotesSplashObjects3= [];
gdjs.PlayonlineCode.GDfpsObjects1= [];
gdjs.PlayonlineCode.GDfpsObjects2= [];
gdjs.PlayonlineCode.GDfpsObjects3= [];
gdjs.PlayonlineCode.GDEngineTextObjects1= [];
gdjs.PlayonlineCode.GDEngineTextObjects2= [];
gdjs.PlayonlineCode.GDEngineTextObjects3= [];
gdjs.PlayonlineCode.GDLongUpscrollBFObjects1= [];
gdjs.PlayonlineCode.GDLongUpscrollBFObjects2= [];
gdjs.PlayonlineCode.GDLongUpscrollBFObjects3= [];
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects1= [];
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects2= [];
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects3= [];
gdjs.PlayonlineCode.GDHitboxLeftObjects1= [];
gdjs.PlayonlineCode.GDHitboxLeftObjects2= [];
gdjs.PlayonlineCode.GDHitboxLeftObjects3= [];
gdjs.PlayonlineCode.GDHitboxDownObjects1= [];
gdjs.PlayonlineCode.GDHitboxDownObjects2= [];
gdjs.PlayonlineCode.GDHitboxDownObjects3= [];
gdjs.PlayonlineCode.GDHitboxUpObjects1= [];
gdjs.PlayonlineCode.GDHitboxUpObjects2= [];
gdjs.PlayonlineCode.GDHitboxUpObjects3= [];
gdjs.PlayonlineCode.GDhitrightObjects1= [];
gdjs.PlayonlineCode.GDhitrightObjects2= [];
gdjs.PlayonlineCode.GDhitrightObjects3= [];
gdjs.PlayonlineCode.GDBFIconObjects1= [];
gdjs.PlayonlineCode.GDBFIconObjects2= [];
gdjs.PlayonlineCode.GDBFIconObjects3= [];
gdjs.PlayonlineCode.GDPauseButtonObjects1= [];
gdjs.PlayonlineCode.GDPauseButtonObjects2= [];
gdjs.PlayonlineCode.GDPauseButtonObjects3= [];
gdjs.PlayonlineCode.GDPauseButton2Objects1= [];
gdjs.PlayonlineCode.GDPauseButton2Objects2= [];
gdjs.PlayonlineCode.GDPauseButton2Objects3= [];
gdjs.PlayonlineCode.GDBlackScreenObjects1= [];
gdjs.PlayonlineCode.GDBlackScreenObjects2= [];
gdjs.PlayonlineCode.GDBlackScreenObjects3= [];
gdjs.PlayonlineCode.GDPauseTextObjects1= [];
gdjs.PlayonlineCode.GDPauseTextObjects2= [];
gdjs.PlayonlineCode.GDPauseTextObjects3= [];
gdjs.PlayonlineCode.GDExitTextObjects1= [];
gdjs.PlayonlineCode.GDExitTextObjects2= [];
gdjs.PlayonlineCode.GDExitTextObjects3= [];
gdjs.PlayonlineCode.GDRestartTextObjects1= [];
gdjs.PlayonlineCode.GDRestartTextObjects2= [];
gdjs.PlayonlineCode.GDRestartTextObjects3= [];
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects1= [];
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects2= [];
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects3= [];
gdjs.PlayonlineCode.GDBfUpNoteObjects1= [];
gdjs.PlayonlineCode.GDBfUpNoteObjects2= [];
gdjs.PlayonlineCode.GDBfUpNoteObjects3= [];
gdjs.PlayonlineCode.GDBfDownNoteObjects1= [];
gdjs.PlayonlineCode.GDBfDownNoteObjects2= [];
gdjs.PlayonlineCode.GDBfDownNoteObjects3= [];
gdjs.PlayonlineCode.GDBfLeftNoteObjects1= [];
gdjs.PlayonlineCode.GDBfLeftNoteObjects2= [];
gdjs.PlayonlineCode.GDBfLeftNoteObjects3= [];
gdjs.PlayonlineCode.GDBfRightNoteObjects1= [];
gdjs.PlayonlineCode.GDBfRightNoteObjects2= [];
gdjs.PlayonlineCode.GDBfRightNoteObjects3= [];
gdjs.PlayonlineCode.GDOppIconObjects1= [];
gdjs.PlayonlineCode.GDOppIconObjects2= [];
gdjs.PlayonlineCode.GDOppIconObjects3= [];
gdjs.PlayonlineCode.GDtimerBarObjects1= [];
gdjs.PlayonlineCode.GDtimerBarObjects2= [];
gdjs.PlayonlineCode.GDtimerBarObjects3= [];
gdjs.PlayonlineCode.GDtimeObjects1= [];
gdjs.PlayonlineCode.GDtimeObjects2= [];
gdjs.PlayonlineCode.GDtimeObjects3= [];
gdjs.PlayonlineCode.GDtimerBar2Objects1= [];
gdjs.PlayonlineCode.GDtimerBar2Objects2= [];
gdjs.PlayonlineCode.GDtimerBar2Objects3= [];
gdjs.PlayonlineCode.GDRatinsPopUpObjects1= [];
gdjs.PlayonlineCode.GDRatinsPopUpObjects2= [];
gdjs.PlayonlineCode.GDRatinsPopUpObjects3= [];
gdjs.PlayonlineCode.GDLongNoteObjects1= [];
gdjs.PlayonlineCode.GDLongNoteObjects2= [];
gdjs.PlayonlineCode.GDLongNoteObjects3= [];
gdjs.PlayonlineCode.GDnotesObjects1= [];
gdjs.PlayonlineCode.GDnotesObjects2= [];
gdjs.PlayonlineCode.GDnotesObjects3= [];
gdjs.PlayonlineCode.GDOppLeftNoteObjects1= [];
gdjs.PlayonlineCode.GDOppLeftNoteObjects2= [];
gdjs.PlayonlineCode.GDOppLeftNoteObjects3= [];
gdjs.PlayonlineCode.GDOppDownNoteObjects1= [];
gdjs.PlayonlineCode.GDOppDownNoteObjects2= [];
gdjs.PlayonlineCode.GDOppDownNoteObjects3= [];
gdjs.PlayonlineCode.GDOppUpNoteObjects1= [];
gdjs.PlayonlineCode.GDOppUpNoteObjects2= [];
gdjs.PlayonlineCode.GDOppUpNoteObjects3= [];
gdjs.PlayonlineCode.GDOppRightNoteObjects1= [];
gdjs.PlayonlineCode.GDOppRightNoteObjects2= [];
gdjs.PlayonlineCode.GDOppRightNoteObjects3= [];
gdjs.PlayonlineCode.GDLongNoteOppObjects1= [];
gdjs.PlayonlineCode.GDLongNoteOppObjects2= [];
gdjs.PlayonlineCode.GDLongNoteOppObjects3= [];
gdjs.PlayonlineCode.GDStatistics2Objects1= [];
gdjs.PlayonlineCode.GDStatistics2Objects2= [];
gdjs.PlayonlineCode.GDStatistics2Objects3= [];


gdjs.PlayonlineCode.userFunc0x19f6ec0 = function GDJSInlineCode(runtimeScene) {
"use strict";
// WATCHER (download-only) — adapta repo ativo via localStorage e usa lógica de manifest otimizado do Script A
(async function(runtimeScene){
  // --- REPO STORAGE / HELPERS (Copiado do Script A) ---
  const REPO_STORAGE_KEY = "gdjs_repo_list_v1";
  const ACTIVE_REPO_KEY = "gdjs_active_repo_id_v1";

  function defaultRepoEntry() {
    return { id: "official", name: "oficial (LucyYuih/gdev-custom-charts)", owner: "LucyYuih", repo: "gdev-custom-skins", branch: "main", enabled: true };
  }

  function loadRepoList() {
    try {
      const raw = localStorage.getItem(REPO_STORAGE_KEY);
      if (!raw) { const list = [defaultRepoEntry()]; localStorage.setItem(REPO_STORAGE_KEY, JSON.stringify(list)); return list; }
      return JSON.parse(raw);
    } catch (e) { const list = [defaultRepoEntry()]; localStorage.setItem(REPO_STORAGE_KEY, JSON.stringify(list)); return list; }
  }

  function getActiveRepo() {
    try {
      const id = localStorage.getItem(ACTIVE_REPO_KEY);
      const list = loadRepoList();
      let pick = list.find(r => r.id === id && r.enabled);
      if (!pick) pick = list.find(r => r.enabled) || list[0];
      return pick || defaultRepoEntry();
    } catch(e){ return defaultRepoEntry(); }
  }

  function buildManifestCdnUrl(entry) {
    if (!entry) return null;
    if (entry.manifestUrl) return entry.manifestUrl;
    if (entry.owner && entry.repo) return `https://cdn.jsdelivr.net/gh/${entry.owner}/${entry.repo}@${entry.branch}/manifest.json`;
    return null;
  }

  // --- small util helpers ---
  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
  function isAudioFile(name){ return /\.(mp3|ogg|wav|aac|m4a)$/i.test(name); }
  function isJsonFile(name){ return /\.json$/i.test(name); }
  function basenameNoExt(p){ if(!p) return ""; const s = p.split("/").pop(); return s.replace(/\.[^.]+$/, ""); }

  // --- FUNÇÕES PARA MANIFEST OTIMIZADO COM ÁUDIOS (Copiado do Script A) ---
  function getBaseUrl(manifest) {
    if (manifest && manifest._base) {
      return `https://cdn.jsdelivr.net/gh/${manifest._base}/`;
    }
    // Fallback para manifest legado
    const activeRepo = getActiveRepo();
    return `https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/`;
  }

  function parseManifestEntry(entry, baseUrl = "") {
    if (!entry) return null;
    
    // Se for array de strings (diretórios ou arquivos)
    if (Array.isArray(entry) && entry.length > 0 && typeof entry[0] === "string") {
      // Verificar se são diretórios (não contém ponto) ou arquivos (contém ponto)
      const firstItem = entry[0];
      if (firstItem.includes('.') || firstItem.includes('/')) {
        // São arquivos (nova estrutura otimizada)
        return {
          type: 'files',
          value: entry.map(filePath => {
            const fileName = filePath.split('/').pop();
            return {
              name: fileName,
              type: "file",
              url: baseUrl + filePath
            };
          })
        };
      } else {
        // São diretórios
        return {
          type: 'subdirs', 
          value: entry
        };
      }
    }
    
    // Se for objeto com subdirs e files (nova estrutura com áudios em pastas não-folhas)
    if (typeof entry === 'object' && entry !== null && !Array.isArray(entry)) {
      if (entry.subdirs && entry.files) {
        return {
          type: 'folder',
          subdirs: entry.subdirs,
          files: entry.files.map(filePath => {
            const fileName = filePath.split('/').pop();
            return {
              name: fileName,
              type: "file", 
              url: baseUrl + filePath
            };
          })
        };
      }
    }
    
    // Se for array de objetos (estrutura legada)
    if (Array.isArray(entry) && entry.length > 0 && typeof entry[0] === "object") {
      return {
        type: 'files',
        value: entry.map(item => ({
          name: item.n || item.name,
          type: "file",
          url: item.u || item.url
        }))
      };
    }
    
    return null;
  }

  // --- MANIFEST / GITHUB helpers (Copiado do Script A, simplificado para o watcher) ---
  async function tryManifestFromGameVar(runtimeScene) {
    try {
      if (typeof runtimeScene !== "undefined" && runtimeScene.getGame) {
        const gg = runtimeScene.getGame().getVariables();
        if (gg.has("manifestjson")) {
          const s = gg.get("manifestjson").getAsString();
          if (s && s.trim()) {
            try { return JSON.parse(s); } catch(e) { return null; }
          }
        }
      }
    } catch(e){}
    return null;
  }

  async function tryManifestFromProjectResource() {
    try {
      const tries = ["manifest.json","resources/manifest.json","res/manifest.json","./manifest.json"];
      for (const p of tries) {
        try { const r = await fetch(p, {cache:"no-cache"}); if (r.ok) { try { return await r.json(); } catch(e){} } } catch(e){}
      }
    } catch(e){}
    return null;
  }

  async function tryManifestFromCdnOf(entry) {
    try {
      const url = buildManifestCdnUrl(entry);
      if (!url) return null;
      const r = await fetch(url, {cache:"no-cache"});
      if (r.ok) return await r.json();
    } catch(e){}
    return null;
  }

  const _manifest_cache_by_repo = {};

  async function loadManifestPreferLocalFor(entry, runtimeScene) {
    const repoId = (entry && entry.id) ? entry.id : "__default__";
    if (typeof _manifest_cache_by_repo[repoId] !== "undefined") return _manifest_cache_by_repo[repoId];

    const a = await tryManifestFromGameVar(runtimeScene); if (a) { _manifest_cache_by_repo[repoId] = a; return a; }
    const b = await tryManifestFromProjectResource(); if (b) { _manifest_cache_by_repo[repoId] = b; return b; }
    const c = await tryManifestFromCdnOf(entry); if (c) { _manifest_cache_by_repo[repoId] = c; return c; }
    _manifest_cache_by_repo[repoId] = null;
    return null;
  }

  // A função ghListApi do watcher original é mantida, mas renomeada para evitar conflito
  async function ghListApi(path="") {
    const active = getActiveRepo();
    if (!active.owner || !active.repo) throw new Error("No active GH repo configured");
    const apiUrl = `https://api.github.com/repos/${active.owner}/${active.repo}/contents/${encodeURIComponent(path)}?ref=${active.branch || "main"}`;
    let token = "";
    try { token = localStorage.getItem("gdjs_github_token") || ""; } catch(e){}
    try { if ((!token || token.trim()==="") && runtimeScene && runtimeScene.getGame) { const gv = runtimeScene.getGame().getVariables(); if (gv.has("GitHubToken")) token = gv.get("GitHubToken").getAsString(); } } catch(e){}
    const headers = token ? { "Authorization": "token " + token } : {};
    const r = await fetch(apiUrl, { headers });
    if (!r.ok) throw new Error(`GitHub API: ${r.status}`);
    const json = await r.json();
    return json.map(item => ({ name: item.name, path: item.path, type: item.type, download_url: item.download_url || null }));
  }

  // --- Variáveis e Funções do Watcher Original (Mantidas) ---
  const gg = runtimeScene.getGame().getVariables();
  function getVarString(name){ try { return gg.get(name).getAsString(); } catch(e){ return ""; } }
  function setVarString(name, v){ try { gg.get(name).setString(String(v)); } catch(e){} }
  function ensureVarString(name, def=""){ try { if(!gg.has(name)) gg.get(name).setString(def); } catch(e){} }
  function ensureVarNumber(name, def=0){ try { if(!gg.has(name)) gg.get(name).setNumber(def); } catch(e){} }
  function getVarNumber(name){ try { return gg.get(name).getAsNumber(); } catch(e){ return 0; } }
  function setVarNumber(name, n){ try { gg.get(name).setNumber(Number(n) || 0); } catch(e){} }

  ensureVarString("selectedTrackKey","");
  ensureVarString("BfChartJsonLoader","");
  ensureVarString("OppChartJsonLoader","");
  ensureVarString("metadatajson","");
  ensureVarString("SongName","");
  ensureVarNumber("jsmusicoffset",0);
  ensureVarNumber("jsmusicfinish",0);
  ensureVarNumber("Pause",0);

  ensureVarNumber("AllLoaded", 1);

  window.gdjsCustomAudio = window.gdjsCustomAudio || {};
  window.gdjsChannels = window.gdjsChannels || {};
  window._gdjs_manifest = window._gdjs_manifest || undefined; // Mantido para compatibilidade, mas não usado

  function stopAndCleanupAll(revokeBlobUrls = true){
    try {
      if (window.gdjsChannels) {
        Object.keys(window.gdjsChannels).forEach(k=>{
          try {
            const a = window.gdjsChannels[k];
            if (!a) return;
            try{ a.pause(); }catch(e){}
            try{ a.currentTime = 0; }catch(e){}
            if (a._gdjs_ended_handler) { try{ a.removeEventListener('ended', a._gdjs_ended_handler); }catch(e){} a._gdjs_ended_handler = null; }
            if (revokeBlobUrls && a.src && a.src.startsWith('blob:')) {
              try{ URL.revokeObjectURL(a.src); }catch(e){}
            }
          } catch(e){}
        });
      }
      if (window.gdjsCustomAudio) {
        Object.keys(window.gdjsCustomAudio).forEach(folder=>{
          try {
            const entry = window.gdjsCustomAudio[folder] || {};
            const audios = entry.audios || {};
            Object.keys(audios).forEach(name=>{
              try {
                const info = audios[name] || {};
                if (info && info.blobUrl && revokeBlobUrls) try{ URL.revokeObjectURL(info.blobUrl); }catch(e){}
              } catch(e){}
            });
            try{ delete window.gdjsCustomAudio[folder]; } catch(e){}
          } catch(e){}
        });
      }
    } catch(e){}
    window.gdjsChannels = {};
  }

  // Funções de Manifest do Watcher Original (Removidas/Substituídas)
  // tryManifestFromGameVar, tryManifestFromProjectResource, tryManifestFromCDN, loadManifestPreferLocal

  // --- NOVA LÓGICA DE LISTAGEM DE ARQUIVOS (Adaptada do Script A) ---
  async function getFilesFromManifest(folderPath, manifest, baseUrl) {
    if (!manifest || !manifest.hasOwnProperty(folderPath)) return [];
    
    const entry = manifest[folderPath];
    const parsed = parseManifestEntry(entry, baseUrl);

    if (parsed && parsed.type === 'files') {
      return parsed.value;
    }
    
    if (parsed && parsed.type === 'folder') {
      return parsed.files;
    }

    return [];
  }

  async function findAudioFilesWithFallback(rootFolder, difficultyPath) {
    const activeRepo = getActiveRepo();
    const manifest = await loadManifestPreferLocalFor(activeRepo, runtimeScene);
    const baseUrl = getBaseUrl(manifest);

    // 1. Tenta a pasta de dificuldade no manifest (estrutura otimizada)
    let list = await getFilesFromManifest(difficultyPath, manifest, baseUrl);
    if (list && list.length > 0) return list.filter(e => isAudioFile(e.name));

    // 2. Tenta a pasta raiz no manifest (estrutura otimizada)
    list = await getFilesFromManifest(rootFolder, manifest, baseUrl);
    if (list && list.length > 0) return list.filter(e => isAudioFile(e.name));

    // 3. Tenta a pasta pai no manifest (fallback do watcher original)
    const parts = (rootFolder || "").split("/").filter(Boolean);
    if (parts.length >= 2) {
      const modFolder = parts.slice(0, parts.length - 1).join("/");
      if (modFolder) {
        list = await getFilesFromManifest(modFolder, manifest, baseUrl);
        if (list && list.length > 0) return list.filter(e => isAudioFile(e.name));
      }
    }

    // 4. Fallback para GitHub API (ghListApi)
    try {
      const api = await (async ()=> { try { return await ghListApi(difficultyPath); } catch(e) { return []; } })();
      list = (api || []).filter(i => i.type !== "dir" && isAudioFile(i.name)).map(i => ({ name: i.name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`) }));
      if (list && list.length > 0) return list;
    } catch(e){}

    try {
      const api = await (async ()=> { try { return await ghListApi(rootFolder); } catch(e) { return []; } })();
      list = (api || []).filter(i => i.type !== "dir" && isAudioFile(i.name)).map(i => ({ name: i.name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`) }));
      if (list && list.length > 0) return list;
    } catch(e){}

    return [];
  }

  async function findJsonFilesWithFallback(rootFolder, difficultyPath) {
    const activeRepo = getActiveRepo();
    const manifest = await loadManifestPreferLocalFor(activeRepo, runtimeScene);
    const baseUrl = getBaseUrl(manifest);
    const allJsonsMap = {};

    // Função auxiliar para processar arquivos encontrados
    function processFiles(files, origin) {
      (files || []).filter(e => isJsonFile(e.name)).forEach(e => {
        if (!allJsonsMap[e.name]) {
          allJsonsMap[e.name] = { name: e.name, url: e.url, origin: origin };
        }
      });
    }

    // 1. Tenta a pasta de dificuldade no manifest (estrutura otimizada)
    processFiles(await getFilesFromManifest(difficultyPath, manifest, baseUrl), difficultyPath);

    // 2. Tenta a pasta raiz no manifest (estrutura otimizada)
    processFiles(await getFilesFromManifest(rootFolder, manifest, baseUrl), rootFolder);

    // 3. Fallback para GitHub API (ghListApi)
    try {
      const api = await (async ()=> { try { return await ghListApi(difficultyPath); } catch(e){ return []; } })();
      (api || []).filter(i=> i.type !== "dir" && isJsonFile(i.name)).forEach(i => {
        const name = i.name;
        if (!allJsonsMap[name]) {
          allJsonsMap[name] = { name: name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`), origin: difficultyPath };
        }
      });
    } catch(e){}

    try {
      const api = await (async ()=> { try { return await ghListApi(rootFolder); } catch(e){ return []; } })();
      (api || []).filter(i=> i.type !== "dir" && isJsonFile(i.name)).forEach(i=> {
        const name = i.name;
        if (!allJsonsMap[name]) {
          allJsonsMap[name] = { name: name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`), origin: rootFolder };
        }
      });
    } catch(e){}

    return Object.values(allJsonsMap);
  }

  // --- Funções de Download e UI (Mantidas) ---
  function attachEndedWatcherToChannel0(){
    const ch0 = window.gdjsChannels && window.gdjsChannels[0];
    if (!ch0) return;
    if (ch0._gdjs_ended_handler) { try{ ch0.removeEventListener('ended', ch0._gdjs_ended_handler); }catch(e){} ch0._gdjs_ended_handler = null; }
    ch0.loop = false;
    const handler = ()=> { setVarNumber("jsmusicfinish", 1); };
    ch0.addEventListener('ended', handler);
    ch0._gdjs_ended_handler = handler;
  }
  async function ensureAudioContext(){
    try {
      if (!window._gdjs_audio_ctx) window._gdjs_audio_ctx = new (window.AudioContext || window.webkitAudioContext)();
      const ctx = window._gdjs_audio_ctx;
      if (ctx.state === "suspended") { try { await ctx.resume(); } catch(e){} }
      Object.keys(window.gdjsChannels).forEach(k=>{
        try {
          const a = window.gdjsChannels[k];
          if (!a) return;
          if (!a._gdjs_connected_to_audioctx) {
            const source = ctx.createMediaElementSource(a);
            const gain = ctx.createGain();
            source.connect(gain);
            gain.connect(ctx.destination);
            a._gdjs_connected_to_audioctx = true; a._gdjs_gain_node = gain;
          } else if (a._gdjs_gain_node) { a._gdjs_gain_node.gain.value = 1.0; }
        } catch(e){}
      });
    } catch(e){}
  }

  async function fetchAsBlob(url, signal){
    const resp = await fetch(url, { signal });
    if (!resp.ok) throw new Error(`Fetch ${url} failed ${resp.status}`);
    return await resp.blob();
  }
  async function fetchAsText(url, signal){
    const resp = await fetch(url, { signal });
    if (!resp.ok) throw new Error(`Fetch ${url} failed ${resp.status}`);
    return await resp.text();
  }

  const OVERLAY_ID = "gdjs-download-overlay";
  function showDownloadOverlay(message){
    try {
      let ov = document.getElementById(OVERLAY_ID);
      if (ov) {
        const msgEl = ov.querySelector(".gdjs-download-msg");
        if (msgEl) msgEl.textContent = message || "Baixando...";
        return;
      }
      ov = document.createElement("div");
      ov.id = OVERLAY_ID;
      Object.assign(ov.style, {
        position: "fixed", left: "0", top: "0", right: "0", bottom: "0",
        zIndex: 2000000, background: "rgba(0,0,0,0.6)",
        display: "flex", alignItems: "center", justifyContent: "center",
        pointerEvents: "auto"
      });
      const box = document.createElement("div");
      Object.assign(box.style, { width: "360px", padding: "16px", borderRadius: "10px", background: "#0b0b0b", color: "#eee", textAlign: "center", boxShadow: "0 12px 40px rgba(0,0,0,0.6)" });
      box.innerHTML = `<div style="font-weight:700;margin-bottom:10px">Baixando...</div>
                       <div class="gdjs-download-msg" style="margin-bottom:12px">` + (message || "Aguarde — baixando recursos") + `</div>
                       <div style="font-size:13px;opacity:0.85">Esta janela fecha automaticamente quando o download terminar.</div>
                       <div style="margin-top:12px"><div class="gdjs-spinner" style="width:36px;height:36px;border-radius:50%;border:4px solid rgba(255,255,255,0.08);border-top-color:rgba(255,255,255,0.5);margin:10px auto;animation:gdjs-spin 1s linear infinite"></div></div>`;
      const style = document.createElement("style");
      style.textContent = `@keyframes gdjs-spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}`;
      document.head.appendChild(style);
      ov.appendChild(box);
      document.body.appendChild(ov);
    } catch(e){}
  }
  function hideDownloadOverlay(){
    try {
      const ov = document.getElementById(OVERLAY_ID);
      if (ov) ov.remove();
    } catch(e){}
  }

  async function downloadAndPrepareFolderFlexible(folderPathOrRoot, outerController, opts){
    const ctrl = outerController;
    const difficultyName = opts && opts.difficultyName ? opts.difficultyName : null;

    try {
      stopAndCleanupAll(true);

      const rootFolder = (() => {
        if (difficultyName) return folderPathOrRoot;
        const parts = (folderPathOrRoot || "").split("/").filter(Boolean);
        if (parts.length >= 3) return parts.slice(0, parts.length - 1).join("/");
        return folderPathOrRoot;
      })();

      let inferredDifficulty = difficultyName;
      if (!inferredDifficulty && (folderPathOrRoot || "").split("/").filter(Boolean).length >= 3) {
        const parts = (folderPathOrRoot || "").split("/").filter(Boolean);
        inferredDifficulty = parts.slice(-1)[0];
      }

      try { setVarString("SongName", basenameNoExt((rootFolder || "").split("/").pop()||"")); } catch(e){}
      try { runtimeScene.getGame().getVariables().get("selectedTrackKey").setString(folderPathOrRoot); } catch(e){}

      setVarNumber("AllLoaded", 0);

      showDownloadOverlay("Preparando download...");

      // --- ALTERAÇÃO PRINCIPAL: Usar as novas funções de listagem ---
      const difficultyPath = (rootFolder? rootFolder + "/" + inferredDifficulty : inferredDifficulty);
      const audioFiles = await findAudioFilesWithFallback(rootFolder, difficultyPath);
      const allJsonsMap = await findJsonFilesWithFallback(rootFolder, difficultyPath);
      // --- FIM ALTERAÇÃO PRINCIPAL ---

      window.gdjsCustomAudio[rootFolder] = window.gdjsCustomAudio[rootFolder] || { audios: {}, rawFiles: {} };
      const dest = window.gdjsCustomAudio[rootFolder];

      let nextChannelIndex = 0;
      for (const f of (audioFiles || [])) {
        if (ctrl.signal.aborted) throw new Error("aborted");
        try {
          showDownloadOverlay(`Baixando áudio: ${f.name} ...`);
          const blob = await fetchAsBlob(f.url, ctrl.signal);
          const blobUrl = URL.createObjectURL(blob);

          const audioEl = new Audio();
          audioEl.preload = "auto";
          audioEl.crossOrigin = "anonymous";
          audioEl.loop = false;

          try { audioEl.src = blobUrl; } catch(e){}
          try { audioEl.pause(); } catch(e){}
          try { audioEl.currentTime = 0; } catch(e){}

          dest.audios[f.name] = { blobUrl, audioEl };
          window.gdjsChannels[nextChannelIndex] = audioEl;
          nextChannelIndex++;
          setVarString("SongName", setVarString || "" );
        } catch(e){
        }
        await sleep(0);
      }

      const ggvars = runtimeScene.getGame().getVariables();
      for (const j of allJsonsMap) {
        if (ctrl.signal.aborted) throw new Error("aborted");
        try {
          showDownloadOverlay(`Baixando chart: ${j.name} ...`);
          const txt = await fetchAsText(j.url, ctrl.signal);
          const storeKey = (j.origin && j.origin !== rootFolder ? (j.origin.split("/").pop() + "/" + j.name) : j.name);
          dest.rawFiles[storeKey] = txt;
          const lname = j.name.toLowerCase();
          if (/metadata|meta/.test(lname)) ggvars.get("metadatajson").setString(txt);
          else if (/(bf|chartbf|chart_bf)/.test(lname)) ggvars.get("BfChartJsonLoader").setString(txt);
          else if (/(dad|opp|opponent)/.test(lname)) ggvars.get("OppChartJsonLoader").setString(txt);
          else {
            try {
              const parsed = JSON.parse(txt);
              if (parsed && parsed.notes) {
                if (!ggvars.get("BfChartJsonLoader").getAsString()) ggvars.get("BfChartJsonLoader").setString(txt);
                else if (!ggvars.get("OppChartJsonLoader").getAsString()) ggvars.get("OppChartJsonLoader").setString(txt);
                else if (!ggvars.get("metadatajson").getAsString()) ggvars.get("metadatajson").setString(txt);
              } else {
                if (!ggvars.get("metadatajson").getAsString()) ggvars.get("metadatajson").setString(txt);
              }
            } catch(e){
              if (!ggvars.get("metadatajson").getAsString()) ggvars.get("metadatajson").setString(txt);
            }
          }
        } catch(e){
        }
        await sleep(0);
      }

      attachEndedWatcherToChannel0();
      await ensureAudioContext();
      setVarNumber("jsmusicfinish", 0);

      setVarNumber("AllLoaded", 1);
      hideDownloadOverlay();

      return { ok:true };
    } catch(err){
      try { stopAndCleanupAll(true); } catch(e){}
      setVarNumber("AllLoaded", 0);
      hideDownloadOverlay();
      return { ok:false, reason: err && err.message ? err.message : String(err) };
    }
  }

  let lastSelected = getVarString("selectedTrackKey") || "";
  let currentDownloadController = null;
  let currentDownloadId = 0;

  async function startIfNeededOnStartup(){
    const sel = getVarString("selectedTrackKey") || "";
    if (sel && sel.trim()) {
      currentDownloadId++;
      const myId = currentDownloadId;
      if (currentDownloadController) { try{ currentDownloadController.abort(); }catch(e){} }
      currentDownloadController = new AbortController();
      downloadAndPrepareFolderFlexible(sel, currentDownloadController, {}).then(res=>{
        if (myId !== currentDownloadId) return;
      }).catch(()=>{});
      lastSelected = sel;
    }
  }
  startIfNeededOnStartup();

  (function pollLoop(){
    try {
      const cur = getVarString("selectedTrackKey") || "";
      if (cur !== lastSelected) {
        lastSelected = cur;
        try { if (currentDownloadController) currentDownloadController.abort(); } catch(e){}
        currentDownloadId++;
        const myId = currentDownloadId;
        currentDownloadController = new AbortController();

        if (!cur || !cur.trim()) {
          stopAndCleanupAll(true);
          setVarNumber("AllLoaded", 1);
        } else {
          (async ()=>{
            setVarNumber("AllLoaded", 0);
            setVarNumber("jsmusicfinish", 0);
            try { setVarString("SongName", basenameNoExt((cur.split("/").pop()||cur))); } catch(e){}
            await downloadAndPrepareFolderFlexible(cur, currentDownloadController, {});
            if (myId === currentDownloadId) {
            }
          })().catch(()=>{});
        }
      }
    } catch(e){}
    requestAnimationFrame(pollLoop);
  })();

  (function rafLoop(){
    try {
      const ch0 = window.gdjsChannels && window.gdjsChannels[0];
      if (ch0) { const cur = ch0.currentTime || 0; setVarNumber("jsmusicoffset", cur); }
      const pauseVal = Number(getVarNumber("Pause") || 0);
      if (pauseVal) {
        Object.keys(window.gdjsChannels||{}).forEach(k=>{ try { const a = window.gdjsChannels[k]; if (a && !a.paused && !a.ended) a.pause(); } catch(e){} });
      } else {
      }
    } catch(e){}
    requestAnimationFrame(rafLoop);
  })();

})(runtimeScene);

};
gdjs.PlayonlineCode.userFunc0xf58300 = function GDJSInlineCode(runtimeScene) {
"use strict";
// skin_watcher_online.js
// Watcher separado: observa SelectedSkin / SelectedDadSkin e aplica apenas quando mudarem.
// Mostra modal preta de baixa opacidade (z-index:1) durante download para bloquear inputs sob ela,
// mas deixa possível que janelas com z-index > 1 continuem sobre ela.

(function(){
  const JSDELIVR_PREFIX = "https://cdn.jsdelivr.net/gh";
  const DEFAULT_CDN_OWNER = "LucyYuih";
  const DEFAULT_CDN_REPO = "gdev-custom-skins";
  const DEFAULT_CDN_BRANCH = "main";

  function log(...s){ try { console.log("[skin-watcher]", ...s); } catch(e){} }
  function warn(...s){ try { console.warn("[skin-watcher]", ...s); } catch(e){} }
  function safeParseJson(s){ try { return JSON.parse(s); } catch(e){ return null; } }

  function encodePathForCdn(p){ return String(p).replace(/^\.\//,'').replace(/\\/g,'/').replace(/ /g,'%20'); }
  function buildCdnUrl(owner, repo, branch, path){ if (!owner || !repo) return null; const br = branch || "main"; return `${JSDELIVR_PREFIX}/${owner}/${repo}@${br}/${encodePathForCdn(path)}`; }

  async function fetchCdnFirst(pathOrUrl, as="arraybuffer", cdnBase=null){
    const isAbs = typeof pathOrUrl === "string" && (pathOrUrl.startsWith("http://") || pathOrUrl.startsWith("https://"));
    const tries = [];
    if (isAbs) tries.push(pathOrUrl);
    if (!isAbs && cdnBase && cdnBase.owner && cdnBase.repo){
      const c = buildCdnUrl(cdnBase.owner, cdnBase.repo, cdnBase.branch, pathOrUrl);
      if (c) tries.push(c);
    }
    tries.push(pathOrUrl);
    tries.push("resources/" + pathOrUrl);
    tries.push("./" + pathOrUrl);
    if (typeof pathOrUrl === "string"){
      const enc = pathOrUrl.replace(/ /g,"%20");
      tries.push(enc); tries.push("resources/" + enc); tries.push("./" + enc);
    }

    let lastErr = null;
    for (const u of tries){
      if (!u) continue;
      try {
        log("fetch try ->", u);
        const r = await fetch(u);
        if (!r.ok) throw new Error("Fetch failed " + r.status + " for " + u);
        if (as === "json") return await r.json();
        if (as === "blob") return await r.blob();
        return await r.arrayBuffer();
      } catch(e){
        lastErr = e;
        warn("fetch failed for", u, e && e.message ? e.message : e);
      }
    }
    throw lastErr || new Error("All fetch attempts failed");
  }

  // Helpers multiplayer (copiados/adaptados)
  function getPlayerOnlineValue(runtimeScene){
    try { const gv = runtimeScene.getGame().getVariables(); if (gv && gv.has("PlayerOnline")) { const n = gv.get("PlayerOnline").getAsNumber(); if (typeof n === 'number' && !isNaN(n)) return n; } } catch(e){}
    try { const sv = runtimeScene.getVariables(); if (sv && sv.has("PlayerOnline")) { const n = sv.get("PlayerOnline").getAsNumber(); if (typeof n === 'number' && !isNaN(n)) return n; } } catch(e){}
    try { if (typeof gdjs !== 'undefined' && gdjs.multiplayer && typeof gdjs.multiplayer.getCurrentPlayerNumber === 'function'){ const pn = gdjs.multiplayer.getCurrentPlayerNumber(); if (typeof pn === 'number') return pn === 1 ? 1 : 2; } } catch(e){}
    return 0;
  }
  function isLobbyRunning(runtimeScene){
    try { if (typeof gdjs !== 'undefined' && gdjs.multiplayer && typeof gdjs.multiplayer.isLobbyGameRunning === 'function') return !!gdjs.multiplayer.isLobbyGameRunning(runtimeScene); } catch(e){}
    try { const gv = runtimeScene.getGame().getVariables(); if (gv && gv.has("IsLobbyGameRunning")) return !!gv.get("IsLobbyGameRunning").getAsNumber(); if (gv && gv.has("LobbyGameIsRunning")) return !!gv.get("LobbyGameIsRunning").getAsNumber(); } catch(e){}
    try { const sv = runtimeScene.getVariables(); if (sv && sv.has("IsLobbyGameRunning")) return !!sv.get("IsLobbyGameRunning").getAsNumber(); } catch(e){}
    return false;
  }

  // Modal UI: baixa opacidade, bloqueia clique, z-index baixo (1)
  function createBlockingModal(){
    // evita duplicados
    if (document.getElementById("skin-watcher-modal")) return document.getElementById("skin-watcher-modal");

    const modal = document.createElement("div");
    modal.id = "skin-watcher-modal";
    modal.style.position = "fixed";
    modal.style.inset = "0";
    modal.style.background = "rgba(0,0,0,0.65)"; // baixa opacidade preta
    modal.style.display = "flex";
    modal.style.alignItems = "center";
    modal.style.justifyContent = "center";
    modal.style.zIndex = "1"; // INTENCIONAL: muito baixo para não sobrescrever outras janelas com z-index maior
    modal.style.pointerEvents = "auto"; // bloqueia toques abaixo
    modal.style.userSelect = "none";

    const panel = document.createElement("div");
    panel.style.padding = "14px 18px";
    panel.style.borderRadius = "8px";
    panel.style.background = "rgba(0,0,0,0.4)";
    panel.style.color = "#fff";
    panel.style.fontFamily = "Arial, sans-serif";
    panel.style.fontSize = "14px";
    panel.style.boxShadow = "0 6px 18px rgba(0,0,0,0.6)";
    panel.textContent = "Baixando skin...";

    const spinner = document.createElement("div");
    spinner.style.width = "36px";
    spinner.style.height = "36px";
    spinner.style.border = "4px solid rgba(255,255,255,0.2)";
    spinner.style.borderTopColor = "#fff";
    spinner.style.borderRadius = "50%";
    spinner.style.marginTop = "8px";
    spinner.style.animation = "skinWatcherSpin 1s linear infinite";

    const style = document.createElement("style");
    style.textContent = "@keyframes skinWatcherSpin { to { transform: rotate(360deg); } }";
    document.head.appendChild(style);

    panel.appendChild(spinner);
    modal.appendChild(panel);
    return modal;
  }
  function showBlockingModal(){
    const existing = document.getElementById("skin-watcher-modal");
    if (existing) return existing;
    const m = createBlockingModal();
    // inserir primeiro no body para z-index ser baixo (ninguém deve sobrescrever body content order)
    document.body.insertBefore(m, document.body.firstChild);
    return m;
  }
  function hideBlockingModal(){
    const m = document.getElementById("skin-watcher-modal");
    if (m && m.parentNode) m.parentNode.removeChild(m);
  }

  // Faz o download do zip (a partir de zip_cdn/zip) e aplica via GD_SKIN_PLAYER
  async function fetchAndApplySelection(runtimeScene, selStr, applyOpts){
    if (!selStr) return null;
    const parsed = safeParseJson(selStr);
    if (!parsed) return null;

    const candidates = [];
    if (parsed.zip_cdn) candidates.push(parsed.zip_cdn);
    if (parsed.zip) { candidates.push(parsed.zip); candidates.push("resources/" + parsed.zip); candidates.push("./" + parsed.zip); candidates.push(parsed.zip.replace(/ /g,"%20")); candidates.push("resources/" + parsed.zip.replace(/ /g,"%20")); }

    // tenter base via manifest se disponível
    try {
      let manifest = null;
      try { const r = await fetch("resources/manifestskins.json"); if (r.ok) manifest = await r.json(); } catch(e){}
      if (!manifest){
        const cdnTry = buildCdnUrl(DEFAULT_CDN_OWNER, DEFAULT_CDN_REPO, DEFAULT_CDN_BRANCH, "manifestskins.json");
        try { const r2 = await fetch(cdnTry); if (r2.ok) manifest = await r2.json(); } catch(e){}
      }
      if (manifest && manifest._base && parsed.zip){
        try {
          const [ownerRepo, branch] = manifest._base.split("@");
          const [owner, repo] = ownerRepo.split("/");
          const cdnBuilt = buildCdnUrl(owner, repo, branch || "main", parsed.zip);
          if (cdnBuilt) candidates.unshift(cdnBuilt);
        } catch(e){}
      }
    } catch(e){ warn("manifest detection failed:", e); }

    // cdn base fallback
    const cdnBase = { owner: DEFAULT_CDN_OWNER, repo: DEFAULT_CDN_REPO, branch: DEFAULT_CDN_BRANCH };

    let lastErr = null;
    for (const c of candidates){
      try {
        log("watcher fetching candidate ->", c);
        const arr = await fetchCdnFirst(c, "arraybuffer", cdnBase);
        if (!arr) throw new Error("Empty arrayBuffer");
        // show modal while applying
        showBlockingModal();
        try {
          if (!window.GD_SKIN_PLAYER || typeof window.GD_SKIN_PLAYER.loadFromArrayBuffer !== "function" || typeof window.GD_SKIN_PLAYER.applyPackageToScene !== "function"){
            throw new Error("GD_SKIN_PLAYER missing required functions");
          }
          const pkg = await window.GD_SKIN_PLAYER.loadFromArrayBuffer(runtimeScene, arr);
          const inst = await window.GD_SKIN_PLAYER.applyPackageToScene(runtimeScene, pkg, applyOpts || {});
          log("watcher applied package from", c);
          return inst;
        } finally {
          // always hide modal depois do attempt (se erro ou sucesso)
          hideBlockingModal();
        }
      } catch(e){
        lastErr = e;
        warn("watcher candidate failed", e && e.message ? e.message : e);
      }
    }
    warn("watcher: all candidates failed", lastErr);
    return null;
  }

  // Watcher principal (só executa ações quando variáveis mudarem)
  function createSkinWatcher(runtimeScene, opts){
    opts = opts || {};
    const pollInterval = (typeof opts.interval === "number") ? Math.max(150, opts.interval) : 600; // ms
    let last = { SelectedSkin: null, SelectedDadSkin: null };

    let intervalHandle = null;
    let running = false;

    async function tick(){
      try {
        const gv = runtimeScene.getGame().getVariables();
        if (!gv) return;

        // garante variáveis existam
        if (!gv.has('SelectedSkin')) gv.pushNew('SelectedSkin').setString('');
        if (!gv.has('SelectedDadSkin')) gv.pushNew('SelectedDadSkin').setString('');

        const cur = {
          SelectedSkin: gv.get('SelectedSkin').getAsString(),
          SelectedDadSkin: gv.get('SelectedDadSkin').getAsString()
        };

        const playerOnline = getPlayerOnlineValue(runtimeScene);
        const lobbyRunning = isLobbyRunning(runtimeScene);

        // SelectedSkin => BF (host); se local não for owner (playerOnline !== 1) então aplica a skin detectada do host
        if ((cur.SelectedSkin || '') !== (last.SelectedSkin || '')){
          log("Detected SelectedSkin change.");
          // Se local for host (playerOnline===1) normalmente não precisa rebaixar; mas se for player 2, deve baixar host's BF.
          if (playerOnline !== 1){
            // aplica BF localmente
            try {
              await fetchAndApplySelection(runtimeScene, cur.SelectedSkin, { targetName: "BF", targetAnimVar: "BFAnim" });
            } catch(e){ warn("Failed applying SelectedSkin via watcher", e); }
          } else {
            log("Local is player 1 -> SelectedSkin changed locally (no download needed).");
          }
          last.SelectedSkin = cur.SelectedSkin;
        }

        // SelectedDadSkin => Opponent (player2). If local is NOT player2, apply the opponent skin.
        if ((cur.SelectedDadSkin || '') !== (last.SelectedDadSkin || '')){
          log("Detected SelectedDadSkin change.");
          // If lobby is running and local is host (playerOnline === 1) skip applying opponent because in lobby host controls BF only.
          if (playerOnline === 1 && lobbyRunning){
            log("Lobby running + local host -> skipping SelectedDadSkin apply to avoid conflict.");
          } else {
            if (playerOnline !== 2){
              try {
                await fetchAndApplySelection(runtimeScene, cur.SelectedDadSkin, { targetName: "BFPixel", targetAnimVar: "OPPAnim" });
              } catch(e){ warn("Failed applying SelectedDadSkin via watcher", e); }
            } else {
              log("Local is player 2 -> SelectedDadSkin changed locally (no download needed).");
            }
          }
          last.SelectedDadSkin = cur.SelectedDadSkin;
        }
      } catch(e){
        warn("skinWatcher tick error:", e);
      }
    }

    function start(){
      if (running) return;
      // snapshot initial values to avoid immediate re-apply
      try {
        const gv = runtimeScene.getGame().getVariables();
        if (gv) {
          last.SelectedSkin = gv.has('SelectedSkin') ? gv.get('SelectedSkin').getAsString() : '';
          last.SelectedDadSkin = gv.has('SelectedDadSkin') ? gv.get('SelectedDadSkin').getAsString() : '';
        }
      } catch(e){}
      intervalHandle = setInterval(() => { tick().catch(e=>warn("tick outer:", e)); }, pollInterval);
      running = true;
      log("skin watcher started (pollInterval:", pollInterval, "ms)");
    }

    function stop(){
      if (!running) return;
      if (intervalHandle) clearInterval(intervalHandle);
      intervalHandle = null;
      running = false;
      log("skin watcher stopped");
    }

    return { start, stop, tickOnce: tick };
  }

  // Auto-start when runtimeScene fornecido (integração simples)
  // Para uso: inclua este arquivo e chame runtimeScene na inicialização da cena.
  window.__gd_skin_watcher = window.__gd_skin_watcher || {};
  window.__gd_skin_watcher._created = true;
  window.__gd_skin_watcher.createForScene = function(runtimeScene, options){
    if (!runtimeScene) throw new Error("runtimeScene required");
    // evita criar múltiplos watchers para a mesma cena
    if (window.__gd_skin_watcher._instance && window.__gd_skin_watcher._instance.running) return window.__gd_skin_watcher._instance;
    const w = createSkinWatcher(runtimeScene, options || {});
    w.start();
    window.__gd_skin_watcher._instance = w;
    return w;
  };

  // auto-boot if runtimeScene global pointer exists (convenience)
  try {
    if (typeof runtimeScene !== "undefined" && runtimeScene) {
      try { window.__gd_skin_watcher.createForScene(runtimeScene, { interval: 600 }); } catch(e){ warn("auto-create watcher failed", e); }
    } else if (window.__gd_runtimeScene_for_skin) {
      try { window.__gd_skin_watcher.createForScene(window.__gd_runtimeScene_for_skin, { interval: 600 }); } catch(e){ warn("auto-create watcher failed", e); }
    } else {
      log("skin-watcher loaded but no runtimeScene found. Call window.__gd_skin_watcher.createForScene(runtimeScene) to start.");
    }
  } catch(e){ warn("startup error", e); }

})();

};
gdjs.PlayonlineCode.eventsList0 = function(runtimeScene) {

{


gdjs.PlayonlineCode.userFunc0x19f6ec0(runtimeScene);

}


{


gdjs.PlayonlineCode.userFunc0xf58300(runtimeScene);

}


};gdjs.PlayonlineCode.eventsList1 = function(runtimeScene) {

{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = !(gdjs.multiplayer.isCurrentPlayerHost());
if (isConditionTrue_0) {
gdjs.copyArray(runtimeScene.getObjects("Start"), gdjs.PlayonlineCode.GDStartObjects1);
{for(var i = 0, len = gdjs.PlayonlineCode.GDStartObjects1.length ;i < len;++i) {
    gdjs.PlayonlineCode.GDStartObjects1[i].deleteFromScene(runtimeScene);
}
}

{ //Subevents
gdjs.PlayonlineCode.eventsList0(runtimeScene);} //End of subevents
}

}


};gdjs.PlayonlineCode.eventsList2 = function(runtimeScene) {

{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.playerAuthentication.isAuthenticated();
if (isConditionTrue_0) {
{gdjs.multiplayer.openLobbiesWindow(runtimeScene);
}
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = !(gdjs.playerAuthentication.isAuthenticated());
if (isConditionTrue_0) {
{gdjs.playerAuthentication.openAuthenticationWindow(runtimeScene);
}
}

}


};gdjs.PlayonlineCode.eventsList3 = function(runtimeScene) {

{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.playerAuthentication.isAuthenticated();
if (isConditionTrue_0) {
{gdjs.multiplayer.authenticateAndQuickJoinLobby(runtimeScene, true, true);
}
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = !(gdjs.playerAuthentication.isAuthenticated());
if (isConditionTrue_0) {
{gdjs.playerAuthentication.openAuthenticationWindow(runtimeScene);
}
}

}


};gdjs.PlayonlineCode.eventsList4 = function(runtimeScene) {

{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isCurrentPlayerHost();
if (isConditionTrue_0) {
{runtimeScene.getGame().getVariables().getFromIndex(16).setNumber(1);
}
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = !(gdjs.multiplayer.isCurrentPlayerHost());
if (isConditionTrue_0) {
gdjs.copyArray(runtimeScene.getObjects("selesongtext"), gdjs.PlayonlineCode.GDselesongtextObjects2);
{for(var i = 0, len = gdjs.PlayonlineCode.GDselesongtextObjects2.length ;i < len;++i) {
    gdjs.PlayonlineCode.GDselesongtextObjects2[i].deleteFromScene(runtimeScene);
}
}
{runtimeScene.getGame().getVariables().getFromIndex(16).setNumber(2);
}
}

}


{


let isConditionTrue_0 = false;
{
{gdjs.evtTools.camera.setCameraX(runtimeScene, gdjs.evtTools.camera.getCameraX(runtimeScene, "", 0) + (2220), "", 0);
}
{runtimeScene.getGame().getVariables().getFromIndex(62).getChild(2).setString("NoBotplay");
}
{gdjs.evtTools.storage.writeStringInJSONFile("Modifiers", "Botplay", "NoBotplay");
}
{runtimeScene.getGame().getVariables().getFromIndex(62).getChild(3).setString("NoMissesChallenge");
}
{gdjs.evtTools.storage.writeStringInJSONFile("Modifiers", "MissChallenge", "NoMissChallenge");
}
}

}


};gdjs.PlayonlineCode.userFunc0x1a0d9c0 = function GDJSInlineCode(runtimeScene) {
"use strict";
// skin_player.js (correção do flip do Opponent) - versão modificada (fix multiplayer idle bug)
(function(){
  const JSZIP_CDN = "https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js";
  const JSDELIVR_PREFIX = "https://cdn.jsdelivr.net/gh";
  const PLAYER_GLOBAL = "__gd_skin_player";

  function log(...s){ console.log("[gd-skin-player]", ...s); }
  function warn(...s){ console.warn("[gd-skin-player]", ...s); }

  async function ensureJSZip(){
    if (window.JSZip) return window.JSZip;
    await new Promise((res, rej) => {
      const s = document.createElement("script");
      s.src = JSZIP_CDN;
      s.onload = res;
      s.onerror = () => rej(new Error("Failed to load JSZip"));
      document.head.appendChild(s);
    });
    if (!window.JSZip) throw new Error("JSZip not available");
    return window.JSZip;
  }

  function safeParseJson(s){ try { return JSON.parse(s); } catch(e){ return null; } }
  function encodePathForCdn(p){ return String(p).replace(/^\.\//,'').replace(/\\/g,'/').replace(/ /g,'%20'); }
  function buildCdnUrl(owner, repo, branch, path){ if(!owner||!repo) return null; const br = branch||"main"; return `${JSDELIVR_PREFIX}/${owner}/${repo}@${br}/${encodePathForCdn(path)}`; }

  function getObjectSize(obj){
    try {
      if (!obj) return {w:0,h:0};
      if (typeof obj.getWidth === "function" && typeof obj.getHeight === "function") {
        return { w: obj.getWidth(), h: obj.getHeight() };
      }
      const ro = obj.getRendererObject && obj.getRendererObject();
      if (ro) {
        if (typeof ro.width === "number" && typeof ro.height === "number") return { w: ro.width, h: ro.height };
        if (ro.getBounds && typeof ro.getBounds === "function") {
          const b = ro.getBounds();
          return { w: b.width || 0, h: b.height || 0 };
        }
      }
      return { w: 0, h: 0 };
    } catch(e){ return {w:0,h:0}; }
  }
  
  function getTexturePixelSize(tex){
    try {
      if (!tex) return {w:0,h:0};
      
      if (tex.frame) {
        const frame = tex.frame;
        if (frame.width && frame.height) {
          return { w: frame.width, h: frame.height };
        }
        if (frame.realWidth && frame.realHeight) {
          return { w: frame.realWidth, h: frame.realHeight };
        }
      }
      
      if (tex.baseTexture) {
        const bt = tex.baseTexture;
        if (bt.realWidth && bt.realHeight) {
          return { w: bt.realWidth, h: bt.realHeight };
        }
        if (bt.width && bt.height) {
          return { w: bt.width, h: bt.height };
        }
      }
      
      if (typeof tex.width === "number" && typeof tex.height === "number") {
        return { w: tex.width, h: tex.height };
      }
      
      return {w:0,h:0};
    } catch(e){ 
      console.warn("getTexturePixelSize failed:", e);
      return {w:0,h:0}; 
    }
  }

  function findJsonAndBasePath(zip){
    const entries = Object.keys(zip.files);
    const candidates = [];
    for (const name of entries) {
      if (name.toLowerCase().endsWith(".json")) {
        const f = zip.files[name];
        const ts = (f && f.date && f.date instanceof Date) ? f.date.getTime() : 0;
        candidates.push({ name, ts });
      }
    }
    if (candidates.length === 0) throw new Error("Metadata JSON not found in ZIP");

    const metaMatches = candidates.filter(c => {
      const n = c.name.toLowerCase();
      return n.endsWith("/metadata.json") || n.endsWith("metadata.json") || n.includes("metadata");
    });

    let chosen;
    if (metaMatches.length) {
      metaMatches.sort((a,b) => b.ts - a.ts);
      chosen = metaMatches[0];
    } else {
      candidates.sort((a,b) => b.ts - a.ts);
      chosen = candidates[0];
    }

    const parts = chosen.name.split("/");
    const baseFolderPrefix = parts.slice(0, parts.length - 1).join("/");
    return { jsonEntryName: chosen.name, baseFolderPrefix };
  }

  function groupImageEntries(entries, baseFolderPrefix, metadata){
    const groups = {};
    const animNames = (metadata && Array.isArray(metadata.animations)) ? metadata.animations.map(a=>a.anim) : [];
    if (animNames.length === 0) groups["idle"] = [];
    for (const anim of animNames) groups[anim] = [];
    for (const e of entries){
      let rel = e;
      if (baseFolderPrefix && e.startsWith(baseFolderPrefix + "/")) rel = e.slice(baseFolderPrefix.length + 1);
      for (const anim of animNames){
        const folderCheck1 = rel.startsWith(anim + "/");
        const folderCheck2 = metadata && metadata.image && rel.startsWith(metadata.image + "/" + anim + "/");
        const filename = rel.split("/").pop();
        const nameCheck = filename.toLowerCase().startsWith(anim.toLowerCase() + "_");
        if ((folderCheck1 || folderCheck2 || nameCheck) && /\.(png|jpg|jpeg|gif)$/i.test(filename)){
          groups[anim].push(e);
        }
      }
      if (animNames.length === 0 && /\.(png|jpg|jpeg|gif)$/i.test(e.split("/").pop())){
        groups["idle"].push(e);
      }
    }
    for (const k of Object.keys(groups)) groups[k].sort((a,b)=>a.localeCompare(b, undefined, { numeric: true }));
    return groups;
  }

  async function loadTexturesFromZipEntries(zip, entryNames){
    const textures = [];
    for (const n of entryNames){
      try {
        const file = zip.file(n);
        if (!file) continue;
        const blob = await file.async("blob");
        const url = URL.createObjectURL(blob);
        const tex = PIXI.Texture.from(url);
        
        await new Promise((resolve, reject) => {
          if (tex.baseTexture && tex.baseTexture.valid) {
            return resolve();
          }
          
          const checkValid = () => {
            if (tex.baseTexture && tex.baseTexture.valid) {
              resolve();
            } else {
              setTimeout(checkValid, 10);
            }
          };
          
          setTimeout(() => {
            if (tex.baseTexture && tex.baseTexture.valid) {
              resolve();
            } else {
              reject(new Error("Texture loading timeout"));
            }
          }, 2000);
          
          checkValid();
        });
        
        textures.push({ tex, blobUrl: url, entryName: n });
      } catch(e){
        warn("Failed load entry", n, e);
      }
    }
    return textures;
  }

  async function loadFromArrayBuffer(runtimeScene, arrayBuffer, opts = {}) {
    await ensureJSZip();
    const zip = await window.JSZip().loadAsync(arrayBuffer);

    let jsonEntryName, baseFolderPrefix;
    try { const found = findJsonAndBasePath(zip); jsonEntryName = found.jsonEntryName; baseFolderPrefix = found.baseFolderPrefix; }
    catch(e){ throw new Error("Metadata JSON not found in zip: " + (e && e.message)); }

    let metadata;
    try {
      const txt = await zip.file(jsonEntryName).async("string");
      metadata = JSON.parse(txt);
    } catch(e){ throw new Error("Failed reading metadata: " + (e && e.message)); }

    try {
      if (!window.GD_SKIN_PLAYER) window.GD_SKIN_PLAYER = {};
      window.GD_SKIN_PLAYER.lastDownloadedMetadata = metadata;
      window.GD_SKIN_PLAYER.lastDownloadedJsonEntry = jsonEntryName;
      window.GD_SKIN_PLAYER.lastDownloadedBaseFolder = baseFolderPrefix;
      window.GD_SKIN_PLAYER.lastDownloadedAt = (new Date()).toISOString();
    } catch(e){ }

    const allEntries = Object.keys(zip.files);
    const groups = groupImageEntries(allEntries, baseFolderPrefix, metadata);

    const animations = {};
    for (const am of (metadata.animations || [])){
      animations[am.anim] = { name: am.anim, fps: am.fps||24, frames: [], loaded: false, loop: am.anim === "idle" };
    }
    if (Object.keys(animations).length === 0) animations["idle"] = { name:"idle", fps:24, frames:[], loaded:false, loop:true };

    for (const key of Object.keys(animations)){
      const entryNames = groups[key] || [];
      if (!entryNames.length) { animations[key].loaded = true; animations[key].frames = []; continue; }
      const loaded = await loadTexturesFromZipEntries(zip, entryNames);
      animations[key].frames = loaded.map(o => o.tex);
      animations[key].loaded = true;
      animations[key]._blobUrls = loaded.map(o => o.blobUrl);
    }

    return { 
      animations, 
      metadata, 
      _createdBlobUrls: (function collect(){ 
        const arr=[]; 
        for(const k of Object.keys(animations)){ 
          const a=animations[k]; 
          if (a._blobUrls) arr.push(...a._blobUrls);
        } 
        return arr; 
      })() 
    };
  }

  function computeCenterAndFeetForObject(obj){
    const size = getObjectSize(obj);
    const ro = (obj.getRendererObject && obj.getRendererObject()) || null;
    let anchorX = 0.5, anchorY = 0;
    try {
      if (ro) {
        if (ro.anchor && typeof ro.anchor.x === "number" && typeof ro.anchor.y === "number"){
          anchorX = ro.anchor.x; anchorY = ro.anchor.y;
        } else if (ro.pivot && typeof ro.pivot.x === "number" && typeof ro.pivot.y === "number" && typeof ro.width === "number" && typeof ro.height === "number" && ro.width>0 && ro.height>0) {
          anchorX = ro.pivot.x / (ro.width || 1);
          anchorY = ro.pivot.y / (ro.height || 1);
        }
      }
    } catch(e){}
    const gx = (typeof obj.getX === "function") ? obj.getX() : 0;
    const gy = (typeof obj.getY === "function") ? obj.getY() : 0;
    
    const centerX = gx + (0.5 - anchorX) * (size.w || 0);
    const feetY = gy + (1 - (typeof anchorY === "number" ? anchorY : 0)) * (size.h || 0);

    let pixelToSceneOriginal = 1;
    try {
      const tex = ro && (ro.texture || (ro.sprite && ro.sprite.texture));
      if (tex) {
        const texPx = getTexturePixelSize(tex);
        if (texPx && texPx.h > 0 && size.h > 0) {
          pixelToSceneOriginal = size.h / texPx.h;
        }
      }
    } catch(e){ }

    return { centerX, feetY, anchorX, anchorY, size, originalX: gx, originalY: gy, pixelToSceneOriginal };
  }

  async function applyPackageToScene(runtimeScene, packageObj, opts = {}) {
    const TARGET_NAME = (opts && opts.targetName) ? opts.targetName : "BF";
    const TARGET_ANIM_VAR = (opts && opts.targetAnimVar) ? opts.targetAnimVar : "BFAnim";
    const invertOffsetY = (typeof opts.invertOffsetY === "boolean") ? opts.invertOffsetY : false;
    const coordinateMode = (opts.coordinateMode === "raw") ? "raw" : "psych";

    const animations = packageObj.animations || {};
    const targetObjects = runtimeScene.getObjects(TARGET_NAME);
    if (!targetObjects || targetObjects.length === 0) {
      warn(TARGET_NAME + " not found in scene when applying skin. Aborting apply.");
      return null;
    }

    // CAPTURAR POSIÇÕES ORIGINAIS
    const targetInfos = [];
    for (const obj of targetObjects) {
      try {
        const info = computeCenterAndFeetForObject(obj);
        let originalScaleX = 1;
        try {
          const ro = obj.getRendererObject && obj.getRendererObject();
          if (ro) {
            if (ro.scale && typeof ro.scale.x === "number") originalScaleX = ro.scale.x;
            else if (typeof ro.scaleX === "number") originalScaleX = ro.scaleX;
          }
        } catch(e){}
        
        // use absolute value as baseline to avoid inheriting an unwanted flip
        const originalAbsScaleX = Math.abs(typeof originalScaleX === "number" && isFinite(originalScaleX) ? originalScaleX : 1) || 1;

        targetInfos.push({ 
          obj, 
          centerX: info.centerX, 
          feetY: info.feetY, 
          anchorX: info.anchorX, 
          anchorY: info.anchorY, 
          size: info.size, 
          originalScaleX,
          originalAbsScaleX,
          originalX: info.originalX,
          originalY: info.originalY,
          pixelToSceneOriginal: (typeof info.pixelToSceneOriginal === "number" && isFinite(info.pixelToSceneOriginal)) ? info.pixelToSceneOriginal : 1
        });
        
        log(`Original ${TARGET_NAME} pos - X:${info.originalX} Y:${info.originalY} centerX:${info.centerX} feetY:${info.feetY} size:${info.size.w}x${info.size.h} anchor:(${info.anchorX},${info.anchorY}) pxToScene:${info.pixelToSceneOriginal}`);
      } catch(e){
        const fallbackSize = getObjectSize(obj);
        const gx = (typeof obj.getX === "function") ? obj.getX() : 0;
        const gy = (typeof obj.getY === "function") ? obj.getY() : 0;
        targetInfos.push({ 
          obj, 
          centerX: gx, 
          feetY: gy + (fallbackSize.h || 0),
          anchorX: 0.5, 
          anchorY: 0, 
          size: fallbackSize, 
          originalScaleX: 1,
          originalAbsScaleX: 1,
          originalX: gx,
          originalY: gy,
          pixelToSceneOriginal: 1
        });
      }
    }

    const state = {
      current: "idle", 
      frameIndex: 0, 
      elapsed: 0, 
      lastAnimValue: "", 
      lastTick: performance.now(),
      _idleBeatTimeout: null, 
      _returnToIdleTimeout: null, 
      _createdBlobUrls: packageObj._createdBlobUrls || [], 
      _isPlayingSingAnimation: false,
      _idleTimerRunning: false,
      _watchdogCounter: 0
    };

    const meta = packageObj.metadata || {};
    
    // CORREÇÃO CRÍTICA: Lógica do flip para Opponent
    let invertSideGlobal = false;

    // normalizar meta.OPPSide para boolean robusto (aceita "true"/"false"/1/0)
    const parseBoolean = (v) => {
      if (typeof v === "boolean") return v;
      if (typeof v === "number") return v !== 0;
      if (typeof v === "string") {
        const s = v.trim().toLowerCase();
        if (s === "true" || s === "1" || s === "yes") return true;
        if (s === "false" || s === "0" || s === "no") return false;
      }
      return Boolean(v);
    };
    const oppSideBool = parseBoolean(meta.OPPSide);

    if (TARGET_NAME === "BFPixel") {
      // OPPSide = true -> SEM flip (normal), OPPSide = false -> COM flip
      invertSideGlobal = !oppSideBool;
      log(`Opponent flip logic: OPPSide=${meta.OPPSide} (parsed=${oppSideBool}), invertSideGlobal=${invertSideGlobal}`);
    } else {
      // BF: OPPSide = true -> COM flip, OPPSide = false -> SEM flip  
      invertSideGlobal = oppSideBool;
      log(`BF flip logic: OPPSide=${meta.OPPSide} (parsed=${oppSideBool}), invertSideGlobal=${invertSideGlobal}`);
    }

    function mapAnimToKey(rawAnim, invertSide){
      if (!rawAnim) return "";
      const v = rawAnim.toLowerCase();
      if (invertSide) {
        if (v.includes("left")) return "singRIGHT";
        if (v.includes("right")) return "singLEFT";
      } else {
        if (v.includes("left")) return "singLEFT";
        if (v.includes("right")) return "singRIGHT";
      }
      if (v.includes("down")) return "singDOWN";
      if (v.includes("up")) return "singUP";
      return rawAnim;
    }

    function applyFrameToAllObjects(tex){
      if (!targetInfos || targetInfos.length === 0) return;
      const texPixel = getTexturePixelSize(tex);
      const texPxW = texPixel.w || 0;
      const texPxH = texPixel.h || 0;

      for (const info of targetInfos) {
        const obj = info.obj;
        try {
          // Aplicar textura
          const ro = obj.getRendererObject && obj.getRendererObject();
          if (ro && ro.texture !== undefined) {
            ro.texture = tex;
          } else {
            try { obj.getRendererObject().texture = tex; } catch(e){}
          }

          const ox_scene = 0;
          const oy_scene = 0;

          let pixelToScene = 1;
          if (coordinateMode === "psych") {
            pixelToScene = (typeof info.pixelToSceneOriginal === "number" && info.pixelToSceneOriginal > 0) ? info.pixelToSceneOriginal : 1;
          } else {
            pixelToScene = 1;
          }

          const oyAdjusted = invertOffsetY ? -oy_scene : oy_scene;

          // USAR DIMENSÕES EXATAS DA TEXTURA
          const scaledTexWidth = texPxW * pixelToScene;
          const scaledTexHeight = texPxH * pixelToScene;

          const targetFeetY = info.feetY + oyAdjusted;
          const targetCenterX = info.centerX + ox_scene;

          const anchorX = (typeof info.anchorX === "number") ? info.anchorX : 0.5;
          const anchorY = (typeof info.anchorY === "number") ? info.anchorY : 0;

          const currentWidth = scaledTexWidth;
          const currentHeight = scaledTexHeight;

          const targetObjX = targetCenterX - (0.5 - anchorX) * currentWidth;
          const targetObjY = targetFeetY - (1 - anchorY) * currentHeight;

          if (typeof obj.setX === "function") obj.setX(targetObjX);
          if (typeof obj.setY === "function") obj.setY(targetObjY);

          // CORREÇÃO APLICADA: Lógica de flip corrigida usando originalAbsScaleX
          try {
            if (ro) {
              // baseline absoluto (garante que não herdamos um flip indesejado do original)
              const baseScale = (typeof info.originalAbsScaleX === "number" && info.originalAbsScaleX > 0) ? info.originalAbsScaleX : (Math.abs(info.originalScaleX) || 1);
              const wantScaleX = invertSideGlobal ? -baseScale : baseScale;

              if (ro.scale && typeof ro.scale.x === "number") {
                ro.scale.x = wantScaleX;
              } else if (typeof ro.scaleX === "number") {
                ro.scaleX = wantScaleX;
              } else {
                ro.scale = ro.scale || {};
                if (typeof ro.scale.x === "number") ro.scale.x = wantScaleX;
              }
              
              log(`Applied scale to ${TARGET_NAME}: ${wantScaleX} (invertSideGlobal: ${invertSideGlobal})`);
            }
          } catch(e){
            warn("Error applying scale:", e);
          }

          const newFeetY = targetObjY + (1 - anchorY) * currentHeight;
          const newCenterX = targetObjX + (0.5 - anchorX) * currentWidth;
          log(`Applied frame to ${TARGET_NAME} - Texture:${texPxW}x${texPxH} Scaled:${scaledTexWidth}x${scaledTexHeight} ActualFeetY:${newFeetY} ActualCenterX:${newCenterX}`);
        } catch(e){
          console.error("Error applying frame to object:", e);
        }
      }
    }

    // Aplicar frame inicial (idle)
    if (animations.idle && animations.idle.frames && animations.idle.frames[0]) {
      applyFrameToAllObjects(animations.idle.frames[0]);
    }

    let rafHandle = null;
    function clearAllTimeouts(){ 
      if (state._idleBeatTimeout){ clearTimeout(state._idleBeatTimeout); state._idleBeatTimeout=null; } 
      if (state._returnToIdleTimeout){ clearTimeout(state._returnToIdleTimeout); state._returnToIdleTimeout=null; } 
      state._idleTimerRunning = false;
    }
    
    // Helper robusto para decidir se um valor de animação é "vazio" (deve voltar para idle)
    function animValueIsEmpty(s){
      if (s === null || s === undefined) return true;
      try {
        const st = String(s).trim().toLowerCase();
        return st === "" || st === "idle";
      } catch(e){ return true; }
    }

    // Retorna ao idle com segurança
    function scheduleReturnToIdle(delayMs = 150){
      // sempre cancela timers anteriores para evitar múltiplos timers concorrentes
      if (state._returnToIdleTimeout) clearTimeout(state._returnToIdleTimeout);
      state._idleTimerRunning = true;
      state._returnToIdleTimeout = setTimeout(()=>{
        state._returnToIdleTimeout = null;
        state._idleTimerRunning = false;
        state.current = "idle";
        state.frameIndex = 0;
        state.elapsed = 0;
        state._isPlayingSingAnimation = false;
        if (animations.idle && animations.idle.frames && animations.idle.frames[0]) {
          applyFrameToAllObjects(animations.idle.frames[0]);
        }
        log("Returned to idle after scheduled timeout (multiplayer-safe)");
      }, delayMs);
    }

    // Watchdog para evitar ficar preso em animação sem avanço
    let watchdogLastFrameIndex = null;
    let watchdogCounter = 0;
    const WATCHDOG_MAX_TICKS = 40; // se por ~40 ticks (com dt limitado) não avançar ou variável estiver inconsistente, volta ao idle

    function tick(now){
      const dt = Math.min(100, now - (state.lastTick || now)); 
      state.lastTick = now;
      
      let currentAnim = "";
      try {
        const sv = runtimeScene.getVariables();
        const gv = runtimeScene.getGame().getVariables();
        // Tentar ler da variável de cena -> se não existir, ler game variable
        if (sv && sv.has && sv.has(TARGET_ANIM_VAR)) {
          currentAnim = sv.get(TARGET_ANIM_VAR).getAsString();
        } else if (gv && gv.has && gv.has(TARGET_ANIM_VAR)) {
          currentAnim = gv.get(TARGET_ANIM_VAR).getAsString();
        } else {
          currentAnim = "";
        }
      } catch(e){
        currentAnim = "";
      }
      
      // Início de nova animação: detectar mudanças claras (inclui caso em que variável vinha vazia)
      if (!animValueIsEmpty(currentAnim) && currentAnim !== state.lastAnimValue){
        // nova animação -> cancelar timers de retorno e iniciar
        clearAllTimeouts();
        const key = mapAnimToKey(currentAnim, invertSideGlobal);
        if (animations[key] && animations[key].frames && animations[key].frames.length > 0){
          state.current = key; 
          state.frameIndex = 0; 
          state.elapsed = 0; 
          state._isPlayingSingAnimation = true;
          state._idleTimerRunning = false;
          watchdogLastFrameIndex = 0;
          watchdogCounter = 0;
          const anim = animations[key]; 
          applyFrameToAllObjects(anim.frames[0]); 
          log("Started animation (multiplayer-safe):", key, "from animVar:", currentAnim);
        } else {
          // se não existe animação correspondente, schedule quick return to idle
          scheduleReturnToIdle(120);
        }
      }

      // Se variável está vazia/idle, iniciar retorno ao idle (mas com debounce curto)
      if (animValueIsEmpty(currentAnim) && state.current !== "idle" && !state._idleTimerRunning){
        // sempre (re)agendar; se durante o delay a variável voltar a ter valor, será cancelado abaixo
        scheduleReturnToIdle(150);
      }

      // Se timer está correndo e a variável voltou a ter valor, cancelar retorno
      if (state._idleTimerRunning && !animValueIsEmpty(currentAnim)){
        clearAllTimeouts();
      }
      
      state.lastAnimValue = currentAnim;

      // Animação atual -- avançar frames
      const anim = animations[state.current];
      if (anim && anim.frames && anim.frames.length > 0){
        const msPerFrame = 1000 / (anim.fps || 24);
        state.elapsed += dt;
        let frameChanged = false;
        while (state.elapsed >= msPerFrame && !frameChanged){
          state.elapsed -= msPerFrame; 
          state.frameIndex++; 
          frameChanged = true;
          if (state.frameIndex >= anim.frames.length){
            if (anim.loop){
              if (anim.name === "idle" || state.current === "idle"){
                // manter último quadro até beat timeout — preserve o comportamento original, mas garante reinício
                state.frameIndex = anim.frames.length - 1;
                if (!state._idleBeatTimeout){
                  state._idleBeatTimeout = setTimeout(()=>{
                    state._idleBeatTimeout = null;
                    state.current = "idle";
                    state.frameIndex = 0;
                    state.elapsed = 0;
                    if (animations.idle && animations.idle.frames && animations.idle.frames[0]){
                      applyFrameToAllObjects(animations.idle.frames[0]);
                    }
                    log("Idle loop restarted after 1s delay (multiplayer-safe)");
                  }, 1000);
                }
              } else {
                state.frameIndex = 0;
              }
            } else {
              state.frameIndex = anim.frames.length - 1;
              if (state._isPlayingSingAnimation){
                state._isPlayingSingAnimation = false;
              }
            }
          }
        }
        if (frameChanged){
          const tex = anim.frames[state.frameIndex]; 
          if (tex) {
            applyFrameToAllObjects(tex);
          }
          // watchdog: se anim é sing (não idle) e não avançou por muitos ticks, forçar idle
          if (state.current !== "idle"){
            if (watchdogLastFrameIndex === state.frameIndex) {
              watchdogCounter++;
            } else {
              watchdogCounter = 0;
            }
            watchdogLastFrameIndex = state.frameIndex;
            if (watchdogCounter > WATCHDOG_MAX_TICKS){
              // forçar retorno ao idle como fallback
              log("Watchdog triggered: forcing return to idle due to stalled animation (multiplayer)");
              clearAllTimeouts();
              state.current = "idle";
              state.frameIndex = 0;
              state.elapsed = 0;
              state._isPlayingSingAnimation = false;
              if (animations.idle && animations.idle.frames && animations.idle.frames[0]) applyFrameToAllObjects(animations.idle.frames[0]);
            }
          } else {
            watchdogCounter = 0;
            watchdogLastFrameIndex = null;
          }
        }
      } else {
        // sem frames para animação atual -> garantir retorno ao idle
        if (state.current !== "idle"){
          scheduleReturnToIdle(120);
        }
      }

      rafHandle = requestAnimationFrame(tick);
    }
    rafHandle = requestAnimationFrame(tick);

    function cleanup(){
      if (rafHandle) cancelAnimationFrame(rafHandle);
      clearAllTimeouts();
      try { 
        for (const b of state._createdBlobUrls){ 
          try{ URL.revokeObjectURL(b); }catch(e){} 
        } 
      } catch(e){}
      log("Player cleaned for " + TARGET_NAME);
    }

    const instance = { animations, state, cleanup, target: TARGET_NAME };
    window[PLAYER_GLOBAL] = instance;
    log("Player applied to " + TARGET_NAME + ". Anims:", Object.keys(animations).map(k=>`${k}(${animations[k].frames.length})`).join(", "));
    return instance;
  }

  async function autoApplySelectedSkin(runtimeScene, opts = {}) {
    const defaults = (opts && opts.extraDefaults) ? opts.extraDefaults : { owner: "LucyYuih", repo: "gdev-custom-skins", branch: "main" };
    let selStr = null;
    try {
      const gv = runtimeScene.getGame().getVariables();
      if (gv.has("SelectedSkin")) selStr = gv.get("SelectedSkin").getAsString();
    } catch(e){}
    if ((!selStr || selStr.trim() === "") && window.localStorage) {
      try { selStr = localStorage.getItem("gd_selected_skin"); } catch(e){}
    }
    if (!selStr) { log("autoApply: no SelectedSkin present."); return null; }
    const parsed = safeParseJson(selStr);
    if (!parsed) { warn("autoApply: SelectedSkin invalid JSON:", selStr); return null; }
    log("autoApplySelectedSkin found:", parsed);

    const candidates = [];
    if (parsed.zip_cdn) candidates.push(parsed.zip_cdn);
    if (parsed.zip) {
      candidates.push(parsed.zip);
      candidates.push("resources/" + parsed.zip);
      candidates.push("./" + parsed.zip);
      candidates.push(parsed.zip.replace(/ /g,"%20"));
      candidates.push("resources/" + parsed.zip.replace(/ /g,"%20"));
    }

    try {
      let manifest = null;
      try { const r = await fetch("resources/manifestskins.json"); if (r.ok) manifest = await r.json(); } catch(e){}
      if (!manifest) {
        const cdnTry = buildCdnUrl(defaults.owner, defaults.repo, defaults.branch, "manifestskins.json");
        try { const r2 = await fetch(cdnTry); if (r2.ok) manifest = await r2.json(); } catch(e){}
      }
      if (manifest && manifest._base) {
        const [ownerRepo, branch] = manifest._base.split("@");
        const [owner, repo] = ownerRepo.split("/");
        if (parsed.zip) {
          const cdnBuilt = buildCdnUrl(owner, repo, branch || "main", parsed.zip);
          if (cdnBuilt) candidates.unshift(cdnBuilt);
        }
      }
    } catch(e){ warn("manifest detection failed", e); }

    let lastErr = null;
    for (const c of candidates) {
      try {
        log("player fetch try ->", c);
        const r = await fetch(c);
        if (!r.ok) throw new Error("Fetch failed " + r.status);
        const arr = await r.arrayBuffer();
        log("player fetch ok ->", c);
        const pkg = await loadFromArrayBuffer(runtimeScene, arr);
        const inst = await applyPackageToScene(runtimeScene, pkg, opts);

        try {
          if (!window.GD_SKIN_PLAYER) window.GD_SKIN_PLAYER = {};
          window.GD_SKIN_PLAYER.lastAppliedZipSource = c;
          window.GD_SKIN_PLAYER.lastAppliedPackage = pkg;
        } catch(e){}

        try {
          const selToSave = Object.assign({}, parsed, { zip_cdn: c });
          const gv2 = runtimeScene.getGame().getVariables();
          if (gv2.has("SelectedSkin")) gv2.get("SelectedSkin").setString(JSON.stringify(selToSave));
          else runtimeScene.getGame().getVariables().pushNew("SelectedSkin").setString(JSON.stringify(selToSave));
          try { localStorage.setItem("gd_selected_skin", JSON.stringify(selToSave)); } catch(e){}
          log("Updated SelectedSkin.zip_cdn ->", c);
        } catch(e){ warn("failed saving zip_cdn", e); }
        return inst;
      } catch(err){
        lastErr = err;
        warn("player fetch failed for candidate ->", c, err && err.message ? err.message : err);
      }
    }
    warn("autoApplySelectedSkin: all candidates failed.", lastErr);
    return null;
  }

  async function autoApplySelectedDadSkin(runtimeScene, opts = {}) {
    const defaults = (opts && opts.extraDefaults) ? opts.extraDefaults : { owner: "LucyYuih", repo: "gdev-custom-skins", branch: "main" };
    let selStr = null;
    try {
      const gv = runtimeScene.getGame().getVariables();
      if (gv.has("SelectedDadSkin")) selStr = gv.get("SelectedDadSkin").getAsString();
    } catch(e){}
    if ((!selStr || selStr.trim() === "") && window.localStorage) {
      try { selStr = localStorage.getItem("gd_selected_dad_skin"); } catch(e){}
    }
    if (!selStr) { log("autoApply: no SelectedDadSkin present."); return null; }
    const parsed = safeParseJson(selStr);
    if (!parsed) { warn("autoApply: SelectedDadSkin invalid JSON:", selStr); return null; }
    log("autoApplySelectedDadSkin found:", parsed);

    const candidates = [];
    if (parsed.zip_cdn) candidates.push(parsed.zip_cdn);
    if (parsed.zip) {
      candidates.push(parsed.zip);
      candidates.push("resources/" + parsed.zip);
      candidates.push("./" + parsed.zip);
      candidates.push(parsed.zip.replace(/ /g,"%20"));
      candidates.push("resources/" + parsed.zip.replace(/ /g,"%20"));
    }

    try {
      let manifest = null;
      try { const r = await fetch("resources/manifestskins.json"); if (r.ok) manifest = await r.json(); } catch(e){}
      if (!manifest) {
        const cdnTry = buildCdnUrl(defaults.owner, defaults.repo, defaults.branch, "manifestskins.json");
        try { const r2 = await fetch(cdnTry); if (r2.ok) manifest = await r2.json(); } catch(e){}
      }
      if (manifest && manifest._base) {
        const [ownerRepo, branch] = manifest._base.split("@");
        const [owner, repo] = ownerRepo.split("/");
        if (parsed.zip) {
          const cdnBuilt = buildCdnUrl(owner, repo, branch || "main", parsed.zip);
          if (cdnBuilt) candidates.unshift(cdnBuilt);
        }
      }
    } catch(e){ warn("manifest detection failed", e); }

    let lastErr = null;
    for (const c of candidates) {
      try {
        log("player fetch try (Dad) ->", c);
        const r = await fetch(c);
        if (!r.ok) throw new Error("Fetch failed " + r.status);
        const arr = await r.arrayBuffer();
        log("player fetch ok (Dad) ->", c);
        const pkg = await loadFromArrayBuffer(runtimeScene, arr);
        const inst = await applyPackageToScene(runtimeScene, pkg, { 
          ...opts, 
          targetName: "BFPixel",
          targetAnimVar: "OPPAnim"
        });

        try {
          if (!window.GD_SKIN_PLAYER) window.GD_SKIN_PLAYER = {};
          window.GD_SKIN_PLAYER.lastAppliedDadZipSource = c;
          window.GD_SKIN_PLAYER.lastAppliedDadPackage = pkg;
        } catch(e){}

        try {
          const selToSave = Object.assign({}, parsed, { zip_cdn: c });
          const gv2 = runtimeScene.getGame().getVariables();
          if (gv2.has("SelectedDadSkin")) gv2.get("SelectedDadSkin").setString(JSON.stringify(selToSave));
          else runtimeScene.getGame().getVariables().pushNew("SelectedDadSkin").setString(JSON.stringify(selToSave));
          try { localStorage.setItem("gd_selected_dad_skin", JSON.stringify(selToSave)); } catch(e){}
          log("Updated SelectedDadSkin.zip_cdn ->", c);
        } catch(e){ warn("failed saving dad zip_cdn", e); }
        return inst;
      } catch(err){
        lastErr = err;
        warn("player fetch failed for dad candidate ->", c, err && err.message ? err.message : err);
      }
    }
    warn("autoApplySelectedDadSkin: all candidates failed.", lastErr);
    return null;
  }

  function cleanupGlobal(){ 
    try { 
      if (window[PLAYER_GLOBAL] && typeof window[PLAYER_GLOBAL].cleanup === "function") 
        window[PLAYER_GLOBAL].cleanup(); 
    } catch(e){} 
    window[PLAYER_GLOBAL] = null; 
  }

  window.GD_SKIN_PLAYER = Object.assign(window.GD_SKIN_PLAYER || {}, { 
    autoApplySelectedSkin, 
    autoApplySelectedDadSkin,
    loadFromArrayBuffer, 
    applyPackageToScene, 
    cleanup: cleanupGlobal, 
    lastDownloadedMetadata: window.GD_SKIN_PLAYER ? window.GD_SKIN_PLAYER.lastDownloadedMetadata : null 
  });

  log("GD_SKIN_PLAYER ready. (Opponent flip FIXED, multiplayer idle robustness)");

  (async ()=>{
    try {
      let rs = null;
      try { if (typeof runtimeScene !== "undefined") rs = runtimeScene; } catch(e){}
      if (!rs && window.__gd_runtimeScene_for_skin) rs = window.__gd_runtimeScene_for_skin;
      if (!rs) { log("player: no runtimeScene on load; waiting for manual call."); return; }
      
      try { 
        await window.GD_SKIN_PLAYER.autoApplySelectedSkin(rs, { 
          extraDefaults: { owner:"LucyYuih", repo:"gdev-custom-skins", branch:"main" } 
        }); 
      } catch(e){ warn("initial autoApply BF failed", e); }
      
      try { 
        await window.GD_SKIN_PLAYER.autoApplySelectedDadSkin(rs, { 
          extraDefaults: { owner:"LucyYuih", repo:"gdev-custom-skins", branch:"main" } 
        }); 
      } catch(e){ warn("initial autoApply Dad failed", e); }
    } catch(e){}
  })();

})();

};
gdjs.PlayonlineCode.eventsList5 = function(runtimeScene) {

{


gdjs.PlayonlineCode.userFunc0x1a0d9c0(runtimeScene);

}


};gdjs.PlayonlineCode.userFunc0xfbb938 = function GDJSInlineCode(runtimeScene) {
"use strict";
// skin_loader_online_preserve_original_vars.js
// Versão online — preserva exatamente o comportamento original ao salvar variáveis (SelectedSkin / SelectedDadSkin).
(async function(runtimeScene) {
  const MANIFEST_NAME = "manifestskins.json";
  const JSDELIVR_PREFIX = "https://cdn.jsdelivr.net/gh";
  
  function log(...s){ console.log("[skin-loader]", ...s); }
  function warn(...s){ console.warn("[skin-loader]", ...s); }

  // encodePath corrigido
  function encodePathForCdn(p){ return String(p).replace(/^\.\//,'').replace(/\\/g,'/').replace(/ /g,'%20'); }
  function buildCdnUrl(owner, repo, branch, path){ if (!owner || !repo) return null; const br = branch || "main"; return `${JSDELIVR_PREFIX}/${owner}/${repo}@${br}/${encodePathForCdn(path)}`; }

  async function fetchCdnFirst(pathOrUrl, as="json", cdnBase=null){
    const isAbs = typeof pathOrUrl === "string" && (pathOrUrl.startsWith("http://") || pathOrUrl.startsWith("https://"));
    const tries = [];
    if (isAbs) tries.push(pathOrUrl);
    if (!isAbs && cdnBase && cdnBase.owner && cdnBase.repo) {
      const c = buildCdnUrl(cdnBase.owner, cdnBase.repo, cdnBase.branch, pathOrUrl);
      if (c) tries.push(c);
    }
    tries.push(pathOrUrl);
    tries.push("resources/" + pathOrUrl);
    tries.push("./" + pathOrUrl);
    if (typeof pathOrUrl === "string") {
      const enc = pathOrUrl.replace(/ /g,"%20");
      tries.push(enc); tries.push("resources/" + enc); tries.push("./" + enc);
    }

    let lastErr = null;
    for (const u of tries) {
      try {
        log("loader fetch try ->", u);
        const r = await fetch(u);
        if (!r.ok) throw new Error("Fetch failed " + r.status + " for " + u);
        if (as === "json") return await r.json();
        if (as === "arraybuffer") return await r.arrayBuffer();
        if (as === "blob") return await r.blob();
        return await r.text();
      } catch (e) {
        lastErr = e;
        warn("loader fetch failed for", u, "->", e && e.message ? e.message : e);
      }
    }
    throw new Error("All loader fetch attempts failed: " + (lastErr ? lastErr.message : "unknown"));
  }

  // Helper: get skin "name" (compatibilidade: derive from path if name absent)
  function getSkinName(sk) {
    if (!sk) return "";
    if (sk.name && typeof sk.name === "string" && sk.name.trim() !== "") return sk.name;
    if (sk.path && typeof sk.path === "string") {
      const parts = sk.path.replace(/\\/g,'/').split('/');
      return parts[parts.length - 1] || "";
    }
    return "";
  }

  // Helper: build the stored thumb/zip path.
  // If sk[field] is an absolute URL -> return as-is
  // If sk[field] contains '/' -> assume it's already a relative path and return it
  // Else join sk.path + '/' + sk[field]
  function buildFilePathFromSkin(sk, field) {
    if (!sk) return "";
    const v = sk[field] || "";
    if (!v) return "";
    if (typeof v !== "string") return "";
    if (v.startsWith("http://") || v.startsWith("https://")) return v;
    if (v.indexOf('/') !== -1) return v.replace(/\\/g,'/');
    if (sk.path && typeof sk.path === "string") {
      return sk.path.replace(/\\/g,'/') + "/" + v;
    }
    return v;
  }

  function createLoadingModal() {
    const modal = document.createElement("div");
    modal.id = "skin-download-loading";
    modal.style.cssText = `
      position: fixed; inset: 0; background: rgba(0,0,0,0.85); 
      display: flex; align-items: center; justify-content: center; 
      z-index: 100000; color: white; font-family: Arial, sans-serif;
      flex-direction: column; gap: 16px;
    `;
    const spinner = document.createElement("div");
    spinner.style.cssText = `
      width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3);
      border-radius: 50%; border-top-color: #1976d2; animation: spin 1s linear infinite;
    `;
    const text = document.createElement("div");
    text.textContent = "Baixando skin...";
    text.style.fontSize = "16px";
    modal.appendChild(spinner);
    modal.appendChild(text);
    const style = document.createElement("style");
    style.textContent = `@keyframes spin { to { transform: rotate(360deg); } }`;
    document.head.appendChild(style);
    return modal;
  }
  function showLoadingModal() {
    const existing = document.getElementById("skin-download-loading");
    if (existing) return existing;
    const modal = createLoadingModal();
    document.body.appendChild(modal);
    return modal;
  }
  function hideLoadingModal() {
    const modal = document.getElementById("skin-download-loading");
    if (modal && modal.parentNode) modal.parentNode.removeChild(modal);
  }

  function createModal(defaultOwner="LucyYuih", defaultRepo="gdev-custom-skins", defaultBranch="main") {
    const css = `
      :root { --modal-gap:12px; --panel-bg:#0f0f11; --panel-radius:12px; --accent:#1976d2; --muted:#999; }
      .skin-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; z-index:99999; padding:20px; box-sizing: border-box; }
      .skin-panel { width: min(1100px,98%); max-width:1100px; height: min(86vh,820px); background:var(--panel-bg); color:#eee; border-radius:var(--panel-radius); display:grid; grid-template-columns:300px 1fr; gap:var(--modal-gap); overflow:hidden; font-family:Arial, sans-serif; box-shadow: 0 12px 32px rgba(0,0,0,0.6); }
      @media (max-width:720px){ .skin-panel{ grid-template-columns:1fr; height:calc(100vh-36px); width:100%; border-radius:8px;} .skin-left{ order:0; max-height:160px; overflow:auto; } .skin-right{ order:1; } }
      .skin-left{ padding:14px; border-right:1px solid rgba(255,255,255,0.05); overflow:auto; min-width:180px; box-sizing:border-box;}
      .skin-right{ padding:14px; display:flex; flex-direction:column; overflow:auto; box-sizing:border-box; }
      .skin-left-header{ display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; gap:8px;}
      .skin-toggle-btn{ background:transparent; border:1px solid rgba(255,255,255,0.04); padding:6px 8px; border-radius:6px; color:#ddd; cursor:pointer; font-size:13px;}
      .skin-mod{ padding:8px; margin:6px 0; background:rgba(255,255,255,0.02); border-radius:8px; cursor:pointer; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; user-select:none;}
      .skin-top{ display:flex; flex-direction:column; gap:8px;}
      .skin-title-row{ display:flex; justify-content:space-between; align-items:center; gap:8px;}
      .skin-title{ font-weight:700; font-size:1rem; }
      .skin-controls{ display:flex; gap:8px; align-items:center; margin-top:6px; flex-wrap:wrap; }
      .skin-btn{ padding:8px 10px; border-radius:8px; background: var(--accent); color:white; border:none; cursor:pointer; font-size:13px;}
      .skin-btn.opponent{ background:#d32f2f; } .skin-btn.bf{ background:#1976d2; }
      .cdn-inputs{ display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap;}
      .cdn-inputs input{ background:#0b0b0b; color:#ddd; border:1px solid rgba(255,255,255,0.04); padding:7px 8px; border-radius:6px; min-width:100px; }
      .skin-loading{ color:var(--muted); font-size:13px; margin:6px 0; }
      .skin-list{ display:flex; flex-wrap:wrap; gap:10px; overflow:auto; padding:6px; align-content:flex-start; }
      .skin-card{ width: clamp(110px,22%,160px); min-width:110px; background: rgba(255,255,255,0.02); border-radius:8px; padding:8px; text-align:center; cursor:pointer; box-sizing:border-box; display:flex; flex-direction:column; gap:8px; user-select:none; }
      .skin-card img{ width:100%; height:90px; object-fit:contain; background:#222; border-radius:6px; pointer-events:none; }
      .skin-card .label{ font-size:13px; color:#ddd; white-space:nowrap; text-overflow:ellipsis; overflow:hidden; }
      .skin-card .card-footer{ display:flex; gap:6px; justify-content:center; align-items:center; flex-direction: column; }
      .skin-card button.skin-btn{ padding:6px 8px; font-size:12px; border-radius:6px; width:100%; }
    `;
    const style = document.createElement("style");
    style.className = "skin-loader-style";
    style.textContent = css;
    document.head.appendChild(style);

    const modal = document.createElement("div"); modal.className = "skin-modal"; modal.setAttribute("role","dialog"); modal.setAttribute("aria-modal","true");
    const panel = document.createElement("div"); panel.className = "skin-panel";
    const left = document.createElement("div"); left.className = "skin-left";
    const leftList = document.createElement("div"); leftList.className = "skin-left-list";
    const right = document.createElement("div"); right.className = "skin-right";

    const leftHeader = document.createElement("div"); leftHeader.className = "skin-left-header";
    const leftTitle = document.createElement("div"); leftTitle.textContent = "Mods"; leftTitle.style.fontWeight = "700";
    const toggleBtn = document.createElement("button"); toggleBtn.className = "skin-toggle-btn"; toggleBtn.textContent = "Toggle";
    leftHeader.appendChild(leftTitle); leftHeader.appendChild(toggleBtn);
    left.appendChild(leftHeader); left.appendChild(leftList);

    const top = document.createElement("div"); top.className = "skin-top";
    const titleRow = document.createElement("div"); titleRow.className = "skin-title-row";
    const title = document.createElement("div"); title.className = "skin-title"; title.textContent = "Skins";
    const controls = document.createElement("div"); controls.className = "skin-controls";
    const closeBtn = document.createElement("button"); closeBtn.className = "skin-btn"; closeBtn.textContent = "Fechar";
    controls.appendChild(closeBtn);
    titleRow.appendChild(title); titleRow.appendChild(controls);

    const cdnRow = document.createElement("div"); cdnRow.className = "cdn-inputs";
    const ownerIn = document.createElement("input"); ownerIn.placeholder = "Owner"; ownerIn.value = defaultOwner || "LucyYuih";
    const repoIn = document.createElement("input"); repoIn.placeholder = "Repo"; repoIn.value = defaultRepo || "gdev-custom-skins";
    const branchIn = document.createElement("input"); branchIn.placeholder = "Branch"; branchIn.value = defaultBranch || "main";
    const note = document.createElement("div"); note.className = "note-small"; note.textContent = "CDN-first: thumbs/zips serão buscados no jsDelivr.";
    cdnRow.appendChild(ownerIn); cdnRow.appendChild(repoIn); cdnRow.appendChild(branchIn); cdnRow.appendChild(note);

    const info = document.createElement("div"); info.className = "skin-loading"; info.textContent = "Selecione um mod à esquerda.";
    const skinListWrap = document.createElement("div"); skinListWrap.style.flex = "1"; skinListWrap.style.overflow = "auto";

    top.appendChild(titleRow); top.appendChild(cdnRow);
    right.appendChild(top); right.appendChild(info); right.appendChild(skinListWrap);
    panel.appendChild(left); panel.appendChild(right); modal.appendChild(panel); document.body.appendChild(modal);

    return { modal, panel, left, leftList, right, ownerIn, repoIn, branchIn, closeBtn, info, skinListWrap, toggleBtn, styleEl: style, controlsEl: controls };
  }

  // Updated to use getSkinName for compatibility with new manifest format
  function findSkinInManifest(manifest, modName, skinName){
    if (!manifest || !modName || !skinName) return null;
    const arr = manifest[modName] || [];
    if (!Array.isArray(arr)) return null;
    for (const s of arr) if (getSkinName(s).toString() === skinName.toString()) return s;
    return null;
  }

  // small helper to get PlayerOnline (tries game vars, scene vars, gdjs.multiplayer fallback)
  function getPlayerOnlineValue(runtimeScene){
    try { const gv = runtimeScene.getGame().getVariables(); if (gv && gv.has("PlayerOnline")) { const n = gv.get("PlayerOnline").getAsNumber(); if (typeof n === 'number' && !isNaN(n)) return n; } } catch(e){}
    try { const sv = runtimeScene.getVariables(); if (sv && sv.has("PlayerOnline")) { const n = sv.get("PlayerOnline").getAsNumber(); if (typeof n === 'number' && !isNaN(n)) return n; } } catch(e){}
    try { if (typeof gdjs !== 'undefined' && gdjs.multiplayer && typeof gdjs.multiplayer.getCurrentPlayerNumber === 'function'){ const pn = gdjs.multiplayer.getCurrentPlayerNumber(); if (typeof pn === 'number') return pn === 1 ? 1 : 2; } } catch(e){}
    return 0;
  }

  // UI logic: create buttons but show/hide according to PlayerOnline WITHOUT changing what those buttons do
  let globalManifest = null;
  let modalOwner = null, modalRepo = null, modalBranch = null;

  // Keep the exact original variable behavior on download/apply/reset functions:
  // When target === "BF" -> set SelectedSkin & gd_selected_skin
  // When target === "Opponent" -> set SelectedDadSkin & gd_selected_dad_skin

  async function downloadAndSaveOnly(modName, skinObj, auto=false, target="BF"){
    if (downloadAndSaveOnly._busy) return;
    downloadAndSaveOnly._busy = true;

    // try to build zipPath properly (supports filename-only in manifest)
    let zipPath = buildFilePathFromSkin(skinObj, "zip") || (skinObj.zip || "");
    if (!zipPath) {
      const found = findSkinInManifest(globalManifest, modName, getSkinName(skinObj));
      if (found) zipPath = buildFilePathFromSkin(found, "zip") || (found.zip || "");
    }
    if (!zipPath) { downloadAndSaveOnly._busy = false; return; }

    const loadingModal = showLoadingModal();
    try {
      const cdnBase = { owner: modalOwner||"LucyYuih", repo: modalRepo||"gdev-custom-skins", branch: modalBranch||"main" };
      const cdnCandidate = (zipPath.startsWith("http://")||zipPath.startsWith("https://")) ? zipPath : buildCdnUrl(cdnBase.owner, cdnBase.repo, cdnBase.branch, zipPath);

      // just check availability (like original did)
      await fetchCdnFirst(cdnCandidate || zipPath, "arraybuffer", cdnBase);

      // Build selection object exactly like original
      const sel = { mod: modName, name: getSkinName(skinObj), zip: zipPath || null, thumb: buildFilePathFromSkin(skinObj, "thumb") || (skinObj.thumb || null) };
      if (typeof cdnCandidate === "string" && cdnCandidate.trim() !== "") sel.zip_cdn = cdnCandidate;
      else sel.zip_cdn = (zipPath && (zipPath.startsWith("http://")||zipPath.startsWith("https://"))) ? zipPath : null;

      // Preserve original behavior: set SelectedSkin or SelectedDadSkin and localStorage keys
      const varName = target === "BF" ? "SelectedSkin" : "SelectedDadSkin";
      const storageKey = target === "BF" ? "gd_selected_skin" : "gd_selected_dad_skin";
      const gv = runtimeScene.getGame().getVariables();
      if (gv.has(varName)) gv.get(varName).setString(JSON.stringify(sel));
      else runtimeScene.getGame().getVariables().pushNew(varName).setString(JSON.stringify(sel));
      try { localStorage.setItem(storageKey, JSON.stringify(sel)); } catch(e){}
      log("[skin-loader] Downloaded+Saved " + varName + ":", JSON.stringify(sel));
    } catch(e){
      console.error("Download/save failed:", e);
    } finally {
      hideLoadingModal();
      downloadAndSaveOnly._busy = false;
    }
  }

  async function applyNow(modName, skinObj, target){
    if (applyNow._busy) return;
    applyNow._busy = true;

    let zipPath = buildFilePathFromSkin(skinObj, "zip") || (skinObj.zip || "");
    if (!zipPath) {
      const found = findSkinInManifest(globalManifest, modName, getSkinName(skinObj));
      if (found) zipPath = buildFilePathFromSkin(found, "zip") || (found.zip || "");
    }
    if (!zipPath) { applyNow._busy = false; return; }

    const loadingModal = showLoadingModal();
    try {
      const cdnBase = { owner: modalOwner||"LucyYuih", repo: modalRepo||"gdev-custom-skins", branch: modalBranch||"main" };
      const cdnCandidate = (zipPath.startsWith("http://")||zipPath.startsWith("https://")) ? zipPath : buildCdnUrl(cdnBase.owner, cdnBase.repo, cdnBase.branch, zipPath);
      const arrbuf = await fetchCdnFirst(cdnCandidate || zipPath, "arraybuffer", cdnBase);

      const sel = { mod: modName, name: getSkinName(skinObj), zip: zipPath || null, thumb: buildFilePathFromSkin(skinObj, "thumb") || (skinObj.thumb || null) };
      if (typeof cdnCandidate === "string" && cdnCandidate.trim() !== "") sel.zip_cdn = cdnCandidate;
      else sel.zip_cdn = (zipPath && (zipPath.startsWith("http://")||zipPath.startsWith("https://"))) ? zipPath : null;
      
      // ORIGINAL behavior: write SelectedSkin or SelectedDadSkin and storage keys
      const varName = target === "BF" ? "SelectedSkin" : "SelectedDadSkin";
      const storageKey = target === "BF" ? "gd_selected_skin" : "gd_selected_dad_skin";
      const gv = runtimeScene.getGame().getVariables();
      if (gv.has(varName)) gv.get(varName).setString(JSON.stringify(sel));
      else runtimeScene.getGame().getVariables().pushNew(varName).setString(JSON.stringify(sel));
      try { localStorage.setItem(storageKey, JSON.stringify(sel)); } catch(e){}
      log("[skin-loader] Saved " + varName + ":", JSON.stringify(sel));

      // apply via GD_SKIN_PLAYER (same as original)
      if (window.GD_SKIN_PLAYER && typeof window.GD_SKIN_PLAYER.loadFromArrayBuffer === "function" && typeof window.GD_SKIN_PLAYER.applyPackageToScene === "function") {
        try {
          const pkg = await window.GD_SKIN_PLAYER.loadFromArrayBuffer(runtimeScene, arrbuf, { targetName: target === "BF" ? "BF" : "BFPixel" });
          await window.GD_SKIN_PLAYER.applyPackageToScene(runtimeScene, pkg, { 
            targetName: target === "BF" ? "BF" : "BFPixel",
            targetAnimVar: target === "BF" ? "BFAnim" : "OPPAnim"
          });
        } catch(e){
          warn("apply via player failed", e);
        }
      }
    } catch(e){
      console.error("applyNow failed:", e);
    } finally {
      hideLoadingModal();
      applyNow._busy = false;
    }
  }

  async function resetAndRedownload(modName, skinObj, auto=false){
    if (resetAndRedownload._busy) return;
    resetAndRedownload._busy = true;

    let zipPath = buildFilePathFromSkin(skinObj, "zip") || (skinObj.zip || "");
    if (!zipPath) {
      const found = findSkinInManifest(globalManifest, modName, getSkinName(skinObj));
      if (found) zipPath = buildFilePathFromSkin(found, "zip") || (found.zip || "");
    }
    if (!zipPath) { resetAndRedownload._busy = false; return; }

    const loadingModal = showLoadingModal();
    try {
      const cdnBase = { owner: modalOwner||"LucyYuih", repo: modalRepo||"gdev-custom-skins", branch: modalBranch||"main" };
      const cdnCandidate = (zipPath.startsWith("http://")||zipPath.startsWith("https://")) ? zipPath : buildCdnUrl(cdnBase.owner, cdnBase.repo, cdnBase.branch, zipPath);

      try {
        // Clear SelectedSkin/SelectedDadSkin if they reference this skin (preserve original logic)
        try {
          const gv = runtimeScene.getGame().getVariables();
          if (gv.has("SelectedSkin")) {
            const cur = gv.get("SelectedSkin").getAsString();
            if (cur && cur.includes(getSkinName(skinObj))) gv.get("SelectedSkin").setString("");
          }
          if (gv.has("SelectedDadSkin")) {
            const cur = gv.get("SelectedDadSkin").getAsString();
            if (cur && cur.includes(getSkinName(skinObj))) gv.get("SelectedDadSkin").setString("");
          }
        } catch(e2){}
        
        try {
          const ls1 = localStorage.getItem("gd_selected_skin");
          if (ls1 && ls1.includes(getSkinName(skinObj))) localStorage.removeItem("gd_selected_skin");
          const ls2 = localStorage.getItem("gd_selected_dad_skin");
          if (ls2 && ls2.includes(getSkinName(skinObj))) localStorage.removeItem("gd_selected_dad_skin");
        } catch(e2){}

        if (window.GD_SKIN_PLAYER) {
          try {
            if (typeof window.GD_SKIN_PLAYER.uninstallPackage === "function") {
              await window.GD_SKIN_PLAYER.uninstallPackage(modName, getSkinName(skinObj));
              log("Called GD_SKIN_PLAYER.uninstallPackage");
            } else if (typeof window.GD_SKIN_PLAYER.removePackageByUrl === "function") {
              await window.GD_SKIN_PLAYER.removePackageByUrl(cdnCandidate);
              log("Called GD_SKIN_PLAYER.removePackageByUrl");
            } else if (typeof window.GD_SKIN_PLAYER.clearCache === "function") {
              await window.GD_SKIN_PLAYER.clearCache();
              log("Called GD_SKIN_PLAYER.clearCache");
            }
          } catch(e3){
            warn("player cache clear attempt failed", e3);
          }
        }
      } catch(eClear){
        warn("Reset: local cache removal failed", eClear);
      }

      const arrbuf = await fetchCdnFirst(cdnCandidate || zipPath, "arraybuffer", cdnBase);

      const sel = { mod: modName, name: getSkinName(skinObj), zip: zipPath || null, thumb: buildFilePathFromSkin(skinObj, "thumb") || (skinObj.thumb || null) };
      if (typeof cdnCandidate === "string" && cdnCandidate.trim() !== "") sel.zip_cdn = cdnCandidate;
      else sel.zip_cdn = (zipPath && (zipPath.startsWith("http://")||zipPath.startsWith("https://"))) ? zipPath : null;
      
      // Save to SelectedSkin (original behavior) — choose BF variable for reset (original script did this)
      try {
        const gv = runtimeScene.getGame().getVariables();
        if (gv.has("SelectedSkin")) gv.get("SelectedSkin").setString(JSON.stringify(sel));
        else runtimeScene.getGame().getVariables().pushNew("SelectedSkin").setString(JSON.stringify(sel));
      } catch(e2){}
      try { localStorage.setItem("gd_selected_skin", JSON.stringify(sel)); } catch(e2){}
      log("Reset: saved SelectedSkin after redownload", sel);

      if (window.GD_SKIN_PLAYER && typeof window.GD_SKIN_PLAYER.loadFromArrayBuffer === "function" && typeof window.GD_SKIN_PLAYER.applyPackageToScene === "function") {
        try {
          const pkg = await window.GD_SKIN_PLAYER.loadFromArrayBuffer(runtimeScene, arrbuf, { targetName: "BF" });
          await window.GD_SKIN_PLAYER.applyPackageToScene(runtimeScene, pkg, { targetName: "BF" });
        } catch(e){
          warn("Reset apply via player failed", e);
        }
      }
    } catch(e){
      console.error("resetAndRedownload failed:", e);
    } finally {
      hideLoadingModal();
      resetAndRedownload._busy = false;
    }
  }

  // UI logic: create the modal, populate the mod list, handle skin selection
  let styleEl = null;
  let prevOverflow = null;
  let thumbsCache = {};
  let currentModName = null;

  async function openSkinSelector(manifest){
    globalManifest = manifest || { "": [] };
    let baseOwner=null, baseRepo=null, baseBranch=null;
    if (manifest && typeof manifest._base === "string" && manifest._base.includes("/")) {
      try { const base = manifest._base.trim(); const [ownerRepo, branch] = base.split("@"); const [owner, repo] = ownerRepo.split("/"); baseOwner = owner; baseRepo = repo; baseBranch = branch || "main"; } catch(e){}
    }

    const ui = createModal(baseOwner||"LucyYuih", baseRepo||"gdev-custom-skins", baseBranch||"main");
    const { modal, panel, left, leftList, right, ownerIn, repoIn, branchIn, closeBtn, info, skinListWrap, toggleBtn, styleEl: s, controlsEl } = ui;
    let currentMod = null; let downloading = false;
    
    // Variáveis globais atualizadas
    styleEl = s;
    modalOwner = ownerIn.value || baseOwner; modalRepo = repoIn.value || baseRepo; modalBranch = branchIn.value || baseBranch || "main";

    prevOverflow = document.documentElement.style.overflow;
    try { document.documentElement.style.overflow = 'hidden'; } catch(e){}

    [leftList, skinListWrap, right, left].forEach(el => { try { if (!el) return; el.addEventListener('touchstart', ()=>{}, {passive:true}); el.addEventListener('touchmove', ()=>{}, {passive:true}); } catch(e){} });

    const resetSelectedBtn = document.createElement("button");
    resetSelectedBtn.className = "skin-btn";
    resetSelectedBtn.textContent = "Reset Selected";
    resetSelectedBtn.title = "Remove SelectedSkin do cache/localStorage e rebaixa se possível";
    resetSelectedBtn.onclick = async () => {
      if (downloading) return;
      try {
        let selStr = null;
        try {
          const gv = runtimeScene.getGame().getVariables();
          if (gv.has("SelectedSkin")) selStr = gv.get("SelectedSkin").getAsString();
        } catch(e){}
        if ((!selStr || selStr.trim()==="") && window.localStorage) selStr = localStorage.getItem("gd_selected_skin");
        if (!selStr) return;
        const parsed = JSON.parse(selStr);
        if (!parsed || (!parsed.zip && !parsed.zip_cdn)) return;
        await resetAndRedownload(parsed.mod || parsed.modName || "", { name: parsed.name || "", zip: parsed.zip || parsed.zip_cdn }, true);
      } catch(e){
        console.error("Reset Selected failed:", e);
      }
    };
    controlsEl.insertBefore(resetSelectedBtn, controlsEl.firstChild);

    const mods = manifest[""] || [];
    if (!Array.isArray(mods) || mods.length === 0) {
      const no = Object.assign(document.createElement("div"), { textContent: "No mods found", style: "color:#aaa; padding:8px;" });
      leftList.appendChild(no);
    } else {
      for (const m of mods) {
        const el=document.createElement("div"); el.className="skin-mod"; el.textContent=m;
        el.onclick=()=>selectMod(m);
        el.addEventListener('touchstart', ()=>{}, {passive:true});
        leftList.appendChild(el);
      }
    }

    let leftHidden = false;
    function setLeftHidden(hide){
      leftHidden = !!hide;
      if (window.innerWidth <= 720) left.style.display = hide ? 'none' : 'flex';
      else left.style.display = 'block';
    }
    toggleBtn.onclick = ()=> setLeftHidden(!leftHidden);
    window.addEventListener('resize', ()=> { if (window.innerWidth > 720) left.style.display = 'block'; else if (leftHidden) left.style.display='none'; });

    const cleanupAndRemove = () => {
      try {
        for (const k in thumbsCache) unloadModThumbs(k);
        if (modal && modal.parentNode) modal.parentNode.removeChild(modal);
        try { document.head.removeChild(styleEl); } catch(e){}
        hideLoadingModal();
      } catch(e){ console.error("cleanup failed", e); }
      try { document.documentElement.style.overflow = prevOverflow || ""; } catch(e){}
      window.removeEventListener('keydown', onKeyDown);
      try { window.removeEventListener('resize', ()=>{}); } catch(e){}
    };

    closeBtn.onclick = () => { if (downloading) return; cleanupAndRemove(); };
    function onKeyDown(e){ if (e.key === 'Escape') { closeBtn.click(); } }
    window.addEventListener('keydown', onKeyDown);

    function unloadModThumbs(modName){ const arr = thumbsCache[modName]; if (!arr) return; for (const it of arr) { if (it.blobUrl) try{URL.revokeObjectURL(it.blobUrl)}catch(e){} } delete thumbsCache[modName]; log("Unloaded thumbs for",modName); }

    function createApplyButtonsForItem(){
      const playerOnline = getPlayerOnlineValue(runtimeScene);
      // playerOnline 1 => only BF; 2 => only Opponent; 0 => both
      const showBF = (playerOnline === 0 || playerOnline === 1);
      const showOpp = (playerOnline === 0 || playerOnline === 2);
      return { showBF, showOpp, playerOnline };
    }

    async function selectMod(modName){
      if (downloading) return;
      if (currentMod === modName) return;
      if (currentMod) unloadModThumbs(currentMod);
      currentMod = modName; skinListWrap.innerHTML=""; info.textContent="Carregando skins...";
      const skins = manifest[modName] || [];
      if (!Array.isArray(skins) || skins.length === 0) { info.textContent = "Nenhuma skin encontrada neste mod."; return; }
      info.textContent=""; const list=document.createElement("div"); list.className="skin-list"; skinListWrap.appendChild(list);

      thumbsCache[modName]=[];
      const cdnBase={ owner: ownerIn.value||baseOwner, repo: repoIn.value||baseRepo, branch: branchIn.value||baseBranch||"main" };

      for (const sk of skins){
        const card=document.createElement("div"); card.className="skin-card";
        const img=document.createElement("img"); img.alt=getSkinName(sk); img.src=""; img.draggable = false;
        const lbl=document.createElement("div"); lbl.className="label"; lbl.textContent=getSkinName(sk);
        const footer = document.createElement("div"); footer.className="card-footer";
        
        const { showBF, showOpp } = createApplyButtonsForItem();

        const applyBtnBF = document.createElement("button"); 
        applyBtnBF.className = "skin-btn bf"; 
        applyBtnBF.textContent = "BF";
        applyBtnBF.onclick = (ev)=> { ev.stopPropagation(); applyNow(modName, sk, "BF"); };
        if (!showBF) applyBtnBF.style.display = "none";

        const applyBtnOpp = document.createElement("button"); 
        applyBtnOpp.className = "skin-btn opponent"; 
        applyBtnOpp.textContent = "Opponent";
        applyBtnOpp.onclick = (ev)=> { ev.stopPropagation(); applyNow(modName, sk, "Opponent"); };
        if (!showOpp) applyBtnOpp.style.display = "none";

        const resetBtn = document.createElement("button"); 
        resetBtn.className = "skin-btn"; 
        resetBtn.textContent = "Reset";
        resetBtn.title = "Apaga cache/localStorage relacionado e rebaixa o .zip";
        resetBtn.onclick = (ev)=> { ev.stopPropagation(); resetAndRedownload(modName, sk, false); };

        footer.appendChild(applyBtnBF);
        footer.appendChild(applyBtnOpp);
        footer.appendChild(resetBtn);
        card.appendChild(img); card.appendChild(lbl); card.appendChild(footer);
        
        // default click on card -> download+save for the slot this player controls (preserve original default logic)
        card.onclick = ()=> downloadAndSaveOnly(modName, sk, false, (getPlayerOnlineValue(runtimeScene) === 2 ? "Opponent" : "BF"));
        card.addEventListener('touchstart', ()=>{}, {passive:true});
        list.appendChild(card);
        thumbsCache[modName].push({ skin: sk, imgEl: img, blobUrl: null, cardEl: card, applyBtnBF, applyBtnOpp, resetBtn });
      }

      for (const item of thumbsCache[modName]){
        const sk = item.skin; 
        // build thumb path using helper (supports filename-only)
        let thumbPath = buildFilePathFromSkin(sk, "thumb") || (sk.thumb || "");
        if (!thumbPath) { item.imgEl.style.background="#222"; continue; }
        try {
          let candidate = (thumbPath.startsWith("http://")||thumbPath.startsWith("https://")) ? thumbPath : buildCdnUrl(cdnBase.owner, cdnBase.repo, cdnBase.branch, thumbPath);
          const blob = await fetchCdnFirst(candidate || thumbPath, "blob", cdnBase);
          const url = URL.createObjectURL(blob);
          item.blobUrl = url; item.imgEl.src = url;
        } catch(e){ warn("Thumb load failed for",getSkinName(sk),e); }
      }
    }

    // A função cleanupAndRemove original foi movida para dentro de openSkinSelector
    // para ter acesso às variáveis locais.

    return { close: cleanupAndRemove, unloadModThumbs };
  }

  // ---------- watcher (observes other player's var changes and applies pack locally) ----------
  let _skinWatcherInterval = null;
  let _skinWatcherLast = { SelectedSkin: null, SelectedDadSkin: null };

  async function applySelectionString(runtimeScene, selStr, opts = {}){ 
    if (!selStr || !selStr.trim()) return null;
    let parsed = null;
    try { parsed = JSON.parse(selStr); } catch(e){ return null; }
    const candidates = [];
    if (parsed.zip_cdn) candidates.push(parsed.zip_cdn);
    if (parsed.zip) { candidates.push(parsed.zip); candidates.push("resources/" + parsed.zip); candidates.push("./" + parsed.zip); candidates.push(parsed.zip.replace(/ /g,"%20")); candidates.push("resources/" + parsed.zip.replace(/ /g,"%20")); }
    for (const c of candidates){
      try {
        log("watcher fetch try ->", c);
        const r = await fetch(c);
        if (!r.ok) throw new Error("Fetch failed " + r.status);
        const arr = await r.arrayBuffer();
        const pkg = await (window.GD_SKIN_PLAYER && typeof window.GD_SKIN_PLAYER.loadFromArrayBuffer === "function" ? window.GD_SKIN_PLAYER.loadFromArrayBuffer(runtimeScene, arr) : Promise.reject(new Error("GD_SKIN_PLAYER missing")));
        if (pkg) return window.GD_SKIN_PLAYER.applyPackageToScene(runtimeScene, pkg, opts);
      } catch(e){ warn("watcher apply candidate failed", e); }
    }
    return null;
  }

  async function skinWatcherTick(runtimeScene){
    try{
      const gv = runtimeScene.getGame().getVariables(); if (!gv) return;
      if (!gv.has('SelectedSkin')) gv.pushNew('SelectedSkin').setString('');
      if (!gv.has('SelectedDadSkin')) gv.pushNew('SelectedDadSkin').setString('');

      const cur = { SelectedSkin: gv.get('SelectedSkin').getAsString(), SelectedDadSkin: gv.get('SelectedDadSkin').getAsString() };
      const playerOnline = getPlayerOnlineValue(runtimeScene);

      // If SelectedSkin changed and this client is NOT player 1, download+apply host's BF skin locally
      if ((cur.SelectedSkin || '') !== (_skinWatcherLast.SelectedSkin || '')){
        if (playerOnline !== 1){
          const sel = cur.SelectedSkin || '';
          if (sel && sel.trim() !== ''){
            log("Watcher: SelectedSkin changed by host -> applying host's BF skin locally");
            try { await applySelectionString(runtimeScene, sel, { targetName: "BF", targetAnimVar: "BFAnim" }); } catch(e){ warn("Watcher apply host BF failed", e); }
          }
        }
      }

      // If SelectedDadSkin changed and this client is NOT player 2, download+apply opponent skin locally
      if ((cur.SelectedDadSkin || '') !== (_skinWatcherLast.SelectedDadSkin || '')){
        if (playerOnline !== 2){
          const sel = cur.SelectedDadSkin || '';
          if (sel && sel.trim() !== ''){
            log("Watcher: SelectedDadSkin changed by player2 -> applying opponent skin locally");
            try { await applySelectionString(runtimeScene, sel, { targetName: "BFPixel", targetAnimVar: "OPPAnim" }); } catch(e){ warn("Watcher apply opponent failed", e); }
          }
        }
      }

      _skinWatcherLast.SelectedSkin = cur.SelectedSkin;
      _skinWatcherLast.SelectedDadSkin = cur.SelectedDadSkin;
    } catch(e){ warn("skinWatcherTick error:", e); }
  }

  function startSkinWatcher(runtimeScene){
    if (_skinWatcherInterval) return;
    _skinWatcherInterval = setInterval(()=> skinWatcherTick(runtimeScene).catch(e=>warn("skinWatcherTick outer:",e)), 700);
    skinWatcherTick(runtimeScene).catch(e=>warn("skinWatcherTick initial:",e));
    log("Skin watcher started.");
  }
  function stopSkinWatcher(){ if (_skinWatcherInterval){ clearInterval(_skinWatcherInterval); _skinWatcherInterval = null; log("Skin watcher stopped."); } }

  // ---------- NOVO: Função para carregar o manifest com fallback para localStorage ----------
  // O repositório e branch padrão são 'LucyYuih/gdev-custom-skins' e 'main', inferidos do código original.
  const GITHUB_RAW_URL = `https://raw.githubusercontent.com/LucyYuih/gdev-custom-skins/main/${MANIFEST_NAME}`;
  const LOCAL_STORAGE_KEY = "skin_loader_manifest";

  async function loadManifestWithFallback(){
    let manifest = null;

    // 1. Tenta ler do GitHub API (usando o link raw)
    try {
      log("Tentando carregar manifest do GitHub:", GITHUB_RAW_URL);
      const response = await fetch(GITHUB_RAW_URL);
      
      if (!response.ok) {
        // Se falhar (incluindo rate limit, 404, etc.), lança erro para ir para o catch
        throw new Error(`Falha ao carregar do GitHub. Status: ${response.status}`);
      }

      const data = await response.json();
      
      // 2. Sucesso: Salva no localStorage e usa o manifest
      try {
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(data));
        log("Manifest carregado do GitHub e salvo no localStorage.");
      } catch(e) {
        warn("Falha ao salvar manifest no localStorage:", e);
      }
      manifest = data;

    } catch(e) {
      warn("Falha ao carregar manifest do GitHub:", e.message);
      
      // 3. Falha: Tenta ler do localStorage
      try {
        const storedManifest = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (storedManifest) {
          manifest = JSON.parse(storedManifest);
          log("Manifest carregado com sucesso do localStorage como fallback.");
        } else {
          throw new Error("localStorage vazio.");
        }
      } catch(e) {
        warn("Falha ao carregar manifest do localStorage:", e.message);
        
        // 4. Falha no localStorage: Tenta o fallback original (CDN/Local)
        log("Tentando fallback original (CDN/Local)...");
        try { 
          manifest = await fetchCdnFirst(MANIFEST_NAME, "json", null); 
        } catch(e){ 
          manifest = null; 
        }
        if (!manifest) { 
          try { 
            manifest = await fetchCdnFirst("resources/" + MANIFEST_NAME, "json", null); 
          } catch(e){ 
            manifest = null; 
          } 
        }
      }
    }

    if (!manifest) { 
      console.warn("manifestskins.json não encontrado em nenhuma fonte; abrindo UI vazia."); 
      manifest = { "": [] }; 
    }
    
    return manifest;
  }
  // ---------- FIM NOVO ----------

  // ---------- bootstrap: load manifest, open UI, start watcher ----------
  try {
    // O código original de carregamento foi substituído pela nova função
    const manifest = await loadManifestWithFallback();
    
    await openSkinSelector(manifest);
    startSkinWatcher(runtimeScene);
  } catch(e){
    console.error("Skin loader startup failed:", e);
  }

  // small debug hooks
  window.__skin_loader_online = window.__skin_loader_online || {};
  window.__skin_loader_online.stopWatcher = () => stopSkinWatcher();
  window.__skin_loader_online.startWatcher = (rs) => startSkinWatcher(rs || runtimeScene);

})(runtimeScene);

};
gdjs.PlayonlineCode.eventsList6 = function(runtimeScene) {

{


gdjs.PlayonlineCode.userFunc0xfbb938(runtimeScene);

}


};gdjs.PlayonlineCode.userFunc0x1a78378 = function GDJSInlineCode(runtimeScene) {
"use strict";
// SCRIPT A — CORRIGIDO (compatível com manifest otimizado com áudios) + Favorites & search que atinge ambas as listas
(function () {
  if (document.getElementById("gdjs-mod-list-ui-final")) return;

  // --- REPO STORAGE / HELPERS ---
  const REPO_STORAGE_KEY = "gdjs_repo_list_v1";
  const ACTIVE_REPO_KEY = "gdjs_active_repo_id_v1";
  const FAVORITES_STORAGE_KEY = "gdjs_fav_songs_v1";

  function defaultRepoEntry() {
    return { id: "official", name: "oficial (LucyYuih/gdev-custom-charts)", owner: "LucyYuih", repo: "gdev-custom-charts", branch: "main", enabled: true };
  }

  function loadRepoList() {
    try {
      const raw = localStorage.getItem(REPO_STORAGE_KEY);
      if (!raw) { const list = [defaultRepoEntry()]; localStorage.setItem(REPO_STORAGE_KEY, JSON.stringify(list)); return list; }
      return JSON.parse(raw);
    } catch (e) { const list = [defaultRepoEntry()]; localStorage.setItem(REPO_STORAGE_KEY, JSON.stringify(list)); return list; }
  }

  function saveRepoList(list) {
    try { localStorage.setItem(REPO_STORAGE_KEY, JSON.stringify(list || [])); } catch(e){}
  }

  function getActiveRepo() {
    try {
      const id = localStorage.getItem(ACTIVE_REPO_KEY);
      const list = loadRepoList();
      let pick = list.find(r => r.id === id && r.enabled);
      if (!pick) pick = list.find(r => r.enabled) || list[0];
      return pick || defaultRepoEntry();
    } catch(e){ return defaultRepoEntry(); }
  }

  function setActiveRepoById(id) { try { localStorage.setItem(ACTIVE_REPO_KEY, String(id)); } catch(e){} }

  function makeRepoId() { return "r_" + Math.random().toString(36).slice(2,10); }

  function parseRepoInput(input) {
    if (!input) return null;
    input = input.trim();
    if (/manifest\.json/.test(input) || /^https?:\/\//.test(input)) {
      const m = input.match(/cdn\.jsdelivr\.net\/gh\/([^\/]+)\/([^@\/]+)@([^\/]+)\/.*manifest\.json/i);
      if (m) return { owner: m[1], repo: m[2], branch: m[3], manifestUrl: input };
      return { owner: "", repo: "", branch: "", manifestUrl: input };
    }
    const m2 = input.match(/^([^\/\s]+)\/([^@\/\s]+)(?:@(.+))?$/);
    if (m2) {
      return { owner: m2[1], repo: m2[2], branch: m2[3] || "main" };
    }
    return null;
  }

  function buildManifestCdnUrl(entry) {
    if (!entry) return null;
    if (entry.manifestUrl) return entry.manifestUrl;
    if (entry.owner && entry.repo) return `https://cdn.jsdelivr.net/gh/${entry.owner}/${entry.repo}@${entry.branch}/manifest.json`;
    return null;
  }

  // --- small util helpers ---
  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
  function isAudioFile(name){ return /\.(mp3|ogg|wav|aac|m4a)$/i.test(name); }
  function isJsonFile(name){ return /\.json$/i.test(name); }
  function basenameNoExt(p){ if(!p) return ""; const s = p.split("/").pop(); return s.replace(/\.[^.]+$/, ""); }

  // --- FUNÇÕES PARA MANIFEST OTIMIZADO COM ÁUDIOS ---
  function getBaseUrl(manifest) {
    if (manifest && manifest._base) {
      return `https://cdn.jsdelivr.net/gh/${manifest._base}/`;
    }
    // Fallback para manifest legado
    const activeRepo = getActiveRepo();
    return `https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/`;
  }

  // monta url final a partir de baseUrl, folderPath e filePath (respeita URLs e caminhos já completos)
  function buildFileUrl(baseUrl, folderPath, filePath) {
    if (!filePath) return null;
    if (filePath.startsWith("http://") || filePath.startsWith("https://")) return filePath;
    // se filePath já contém '/', assume caminho relativo ao repo root -> baseUrl + filePath
    if (filePath.indexOf('/') !== -1) {
      return baseUrl + filePath.replace(/^\/+/,'');
    }
    // senao: é só o nome do arquivo -> junta folderPath
    if (folderPath && folderPath !== "") {
      return baseUrl + folderPath.replace(/^\/+|\/+$/g,'') + "/" + filePath;
    }
    return baseUrl + filePath;
  }

  // parseManifestEntry agora recebe também folderPath (chave do manifest) para montar URLs corretamente
  function parseManifestEntry(entry, baseUrl = "", folderPath = "") {
    if (!entry) return null;

    // Se for array de strings (diretórios ou arquivos)
    if (Array.isArray(entry) && entry.length > 0 && typeof entry[0] === "string") {
      const firstItem = entry[0];
      // Se o primeiro item contém '.' (arquivo) ou contém '/' -> consideramos arquivos.
      if (firstItem.includes('.') || firstItem.includes('/')) {
        // São arquivos (nova estrutura otimizada ou antiga)
        return {
          type: 'files',
          value: entry.map(filePath => {
            const fileName = filePath.split('/').pop();
            const url = buildFileUrl(baseUrl, folderPath, filePath);
            return {
              name: fileName,
              type: "file",
              url: url
            };
          })
        };
      } else {
        // São subdiretórios
        return {
          type: 'subdirs',
          value: entry.slice()
        };
      }
    }

    // Se for objeto com subdirs e files (nova estrutura)
    if (typeof entry === 'object' && entry !== null && !Array.isArray(entry)) {
      if (entry.subdirs && entry.files) {
        return {
          type: 'folder',
          subdirs: entry.subdirs,
          files: entry.files.map(filePath => {
            const fileName = filePath.split('/').pop();
            const url = buildFileUrl(baseUrl, folderPath, filePath);
            return {
              name: fileName,
              type: "file",
              url: url
            };
          })
        };
      }
    }

    // Se for array de objetos (estrutura legada)
    if (Array.isArray(entry) && entry.length > 0 && typeof entry[0] === "object") {
      return {
        type: 'files',
        value: entry.map(item => {
          const name = item.n || item.name;
          const urlRaw = item.u || item.url || "";
          // urlRaw pode ser relativo (path) ou completo; se for relativo e não contém '/', assumimos folderPath + '/' + urlRaw
          let url;
          if (!urlRaw) {
            url = buildFileUrl(baseUrl, folderPath, name);
          } else if (urlRaw.startsWith("http://") || urlRaw.startsWith("https://") || urlRaw.indexOf('/') !== -1) {
            url = urlRaw.startsWith("http") ? urlRaw : baseUrl + urlRaw.replace(/^\/+/,'');
          } else {
            url = buildFileUrl(baseUrl, folderPath, urlRaw);
          }
          return {
            name: name,
            type: "file",
            url: url
          };
        })
      };
    }

    return null;
  }

  // --- MANIFEST / GITHUB helpers ---
  async function tryManifestFromGameVar(runtimeScene) {
    try {
      if (typeof runtimeScene !== "undefined" && runtimeScene.getGame) {
        const gg = runtimeScene.getGame().getVariables();
        if (gg.has("manifestjson")) {
          const s = gg.get("manifestjson").getAsString();
          if (s && s.trim()) {
            try { return JSON.parse(s); } catch(e) { return null; }
          }
        }
      }
    } catch(e){}
    return null;
  }

  async function tryManifestFromProjectResource() {
    try {
      const tries = ["manifest.json","resources/manifest.json","res/manifest.json","./manifest.json"];
      for (const p of tries) {
        try { const r = await fetch(p, {cache:"no-cache"}); if (r.ok) { try { return await r.json(); } catch(e){} } } catch(e){}
      }
    } catch(e){}
    return null;
  }

  async function tryManifestFromCdnOf(entry) {
    try {
      const url = buildManifestCdnUrl(entry);
      if (!url) return null;
      const r = await fetch(url, {cache:"no-cache"});
      if (r.ok) return await r.json();
    } catch(e){}
    return null;
  }

  async function tryManifestFromGithubApiFor(entry, path="") {
    if (!entry || (!entry.owner || !entry.repo)) throw new Error("Invalid repo entry");
    const apiUrl = `https://api.github.com/repos/${entry.owner}/${entry.repo}/contents/${encodeURIComponent(path)}?ref=${entry.branch || "main"}`;
    let token = "";
    try { token = localStorage.getItem("gdjs_github_token") || ""; } catch(e){}
    const headers = token ? { "Authorization": "token " + token } : {};
    const r = await fetch(apiUrl, { headers });
    if (!r.ok) throw new Error(`GitHub API: ${r.status}`);
    const json = await r.json();
    return json.map(item => ({ name: item.name, path: item.path, type: item.type, download_url: item.download_url || null }));
  }

  const _manifest_cache_by_repo = {};

  async function loadManifestPreferLocalFor(entry, runtimeScene) {
    const repoId = (entry && entry.id) ? entry.id : "__default__";
    if (typeof _manifest_cache_by_repo[repoId] !== "undefined") return _manifest_cache_by_repo[repoId];

    const a = await tryManifestFromGameVar(runtimeScene); if (a) { _manifest_cache_by_repo[repoId] = a; return a; }
    const b = await tryManifestFromProjectResource(); if (b) { _manifest_cache_by_repo[repoId] = b; return b; }
    const c = await tryManifestFromCdnOf(entry); if (c) { _manifest_cache_by_repo[repoId] = c; return c; }
    _manifest_cache_by_repo[repoId] = null;
    return null;
  }

  async function ghListForFolderUsingEntry(entry, path="") {
    if (!entry || (!entry.owner || !entry.repo)) {
      throw new Error("No GitHub owner/repo specified for ghList");
    }
    return await tryManifestFromGithubApiFor(entry, path);
  }

  // --- UI: main container (full screen) ---
  const container = document.createElement("div");
  container.id = "gdjs-mod-list-ui-final";
  Object.assign(container.style, {
    position: "fixed", left: "0", top: "0", right: "0", bottom: "0",
    zIndex: 9999999, fontFamily: "Inter, system-ui, Arial", color: "#eee",
    overflow: "hidden", display: "flex", flexDirection: "column",
    background: "linear-gradient(180deg, rgba(12,12,12,0.98), rgba(8,8,8,0.95))"
  });

  // Header
  const header = document.createElement("div");
  Object.assign(header.style, { padding: "10px", display: "flex", gap: "8px", alignItems: "center", borderBottom: "1px solid rgba(255,255,255,0.04)", flex: "0 0 auto" });
  header.innerHTML = `
    <div style="display:flex;gap:8px;align-items:center">
      <div style="font-weight:700">Mods</div>
      <select id="gdjs-repo-select" style="padding:6px;border-radius:6px;background:#0b0b0b;color:#eee;border:1px solid rgba(255,255,255,0.06)"></select>
      <button id="gdjs-repo-manage" style="padding:6px;border-radius:6px">Gerenciar Repos</button>
      <button id="gdjs-repo-refresh" style="padding:6px;border-radius:6px">Atualizar</button>
      <button id="gdjs-repo-cache" style="padding:6px;border-radius:6px">Ver Cache</button>
    </div>
    <input id="gdjs-final-search" placeholder="Pesquisar mods / músicas..." style="margin-left:8px;flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:#0b0b0b;color:#eee" />
    <button id="gdjs-final-close" style="margin-left:8px;padding:6px;border-radius:6px">Fechar</button>
  `;

  // Main split
  const main = document.createElement("div");
  Object.assign(main.style, { display: "flex", gap: "10px", padding: "10px", flex: "1 1 auto", minHeight: 0, overflow: "hidden" });

  const leftPane = document.createElement("div");
  Object.assign(leftPane.style, { width: "38%", minWidth: "260px", maxWidth: "640px", overflowY: "auto", borderRight: "1px solid rgba(255,255,255,0.03)", paddingRight: "8px" });

  const rightPane = document.createElement("div");
  Object.assign(rightPane.style, { flex: "1 1 auto", overflowY: "auto", paddingLeft: "8px" });

  const footer = document.createElement("div");
  Object.assign(footer.style, { padding: "10px", borderTop: "1px solid rgba(255,255,255,0.04)", display: "flex", gap: "12px", alignItems: "center", flex: "0 0 auto" });
  footer.innerHTML = `<div id="gdjs-final-status" style="font-size:13px;opacity:0.9"></div><div id="gdjs-final-last" style="margin-left:auto;font-size:13px;opacity:0.85"></div>`;

  container.appendChild(header);
  main.appendChild(leftPane); main.appendChild(rightPane);
  container.appendChild(main); container.appendChild(footer);
  document.body.appendChild(container);

  // refs
  const repoSelect = document.getElementById("gdjs-repo-select");
  const btnManage = document.getElementById("gdjs-repo-manage");
  const btnRefresh = document.getElementById("gdjs-repo-refresh");
  const btnCache = document.getElementById("gdjs-repo-cache");
  const btnClose = document.getElementById("gdjs-final-close");
  const searchInput = document.getElementById("gdjs-final-search");
  const statusEl = document.getElementById("gdjs-final-status");
  const lastEl = document.getElementById("gdjs-final-last");

  function setStatus(s){ statusEl.textContent = s || ""; }
  function setLast(s){ lastEl.textContent = s || ""; }

  // state
  let currentModPath = "";
  let modsList = [];
  let songsList = [];
  let modElementMap = {};
  let songElementMap = {};
  let favorites = loadFavorites(); // array of { path, name, repoId }

  // --- Favorites helpers ---
  function loadFavorites() {
    try {
      const raw = localStorage.getItem(FAVORITES_STORAGE_KEY);
      if (!raw) return [];
      return JSON.parse(raw) || [];
    } catch(e){ return []; }
  }
  function saveFavorites() {
    try { localStorage.setItem(FAVORITES_STORAGE_KEY, JSON.stringify(favorites || [])); } catch(e){}
    // also push to game variable so "entra no jogo ja com eles"
    try {
      if (window.runtimeScene && window.runtimeScene.getGame) {
        runtimeScene.getGame().getVariables().get("FavoriteSongs").setString(JSON.stringify(favorites || []));
      }
    } catch(e){}
  }
  function isFavorite(path) {
    if (!path) return false;
    return favorites.some(f => f.path === path);
  }
  function addFavorite(path, name) {
    if (!path) return;
    if (isFavorite(path)) return;
    const entry = { path: path, name: name || basenameNoExt(path.split("/").pop()||path), repoId: getActiveRepo().id || null };
    favorites.push(entry);
    saveFavorites();
  }
  function removeFavorite(path) {
    if (!path) return;
    favorites = (favorites || []).filter(f => f.path !== path);
    saveFavorites();
  }
  function toggleFavorite(path, name) {
    if (isFavorite(path)) removeFavorite(path);
    else addFavorite(path, name);
    // refresh UI icon for this song item if exists
    if (songElementMap[path] && songElementMap[path].favIcon) {
      try { songElementMap[path].favIcon.textContent = isFavorite(path) ? "★" : "☆"; } catch(e){}
    }
    // If Favorites pane open, refresh
    if (currentModPath === "__favorites__") openMod("__favorites__");
  }

  // --- REPO UI / MANAGEMENT ---
  function renderRepoSelect() {
    const list = loadRepoList();
    repoSelect.innerHTML = "";
    for (const r of list) {
      const opt = document.createElement("option");
      opt.value = r.id;
      opt.textContent = (r.enabled ? "● " : "○ ") + (r.name || (r.owner? (r.owner + "/" + r.repo + (r.branch? "@" + r.branch : "")) : r.manifestUrl || "custom"));
      repoSelect.appendChild(opt);
    }
    const active = getActiveRepo();
    setActiveRepoById(active.id);
    try { repoSelect.value = active.id; } catch(e){}
  }

  function showRepoManagerModal() {
    // [código idêntico ao anterior...]
    const overlay = document.createElement("div");
    Object.assign(overlay.style, { position: "fixed", left: "0", top: "0", right: "0", bottom: "0", background: "rgba(0,0,0,0.6)", zIndex: 10000000, display: "flex", alignItems: "center", justifyContent: "center" });
    const box = document.createElement("div");
    Object.assign(box.style, { width: "720px", maxHeight: "80vh", overflowY: "auto", background: "#0f0f10", borderRadius: "8px", padding: "12px", boxShadow: "0 12px 40px rgba(0,0,0,0.6)", color: "#eee" });
    box.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><div style="font-weight:700">Gerenciar Repositórios</div><div style="margin-left:auto;font-size:13px;opacity:0.85">Formato: owner/repo@branch ou URL do manifest</div></div><div style="margin-top:10px" id="gdjs-repo-list-area"></div>
      <div style="margin-top:10px;display:flex;gap:8px">
        <input id="gdjs-repo-input" placeholder="ex: LucyYuih/gdev-custom-charts@main" style="flex:1;padding:8px;border-radius:6px;background:#0b0b0b;color:#eee;border:1px solid rgba(255,255,255,0.06)"/>
        <button id="gdjs-repo-add" style="padding:8px;border-radius:6px">Adicionar</button>
      </div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end">
        <button id="gdjs-repo-close" style="padding:8px;border-radius:6px">Fechar</button>
      </div>`;
    overlay.appendChild(box); document.body.appendChild(overlay);

    const listArea = box.querySelector("#gdjs-repo-list-area");
    function renderListArea() {
      const lst = loadRepoList();
      listArea.innerHTML = "";
      for (const r of lst) {
        const row = document.createElement("div");
        Object.assign(row.style, { display: "flex", gap: "8px", alignItems: "center", padding: "6px", borderRadius: "6px", background: "linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))", marginBottom: "6px" });
        const label = document.createElement("div"); label.style.flex = "1"; label.innerHTML = `<div style="font-weight:600">${r.name || (r.owner? (r.owner + "/" + r.repo) : r.manifestUrl)}</div><div style="font-size:12px;opacity:0.8">${r.owner? (r.owner + "/" + r.repo + (r.branch? "@" + r.branch : "")) : r.manifestUrl}</div>`;
        const controls = document.createElement("div"); controls.style.display = "flex"; controls.style.gap = "6px";
        const toggle = document.createElement("button"); toggle.textContent = r.enabled ? "Ativo" : "Desativar"; toggle.style.padding = "6px"; toggle.style.borderRadius = "6px";
        toggle.onclick = () => { r.enabled = !r.enabled; saveRepoList(lst); renderListArea(); renderRepoSelect(); };
        const setActiveBtn = document.createElement("button"); setActiveBtn.textContent = "Selecionar"; setActiveBtn.style.padding = "6px"; setActiveBtn.style.borderRadius = "6px";
        setActiveBtn.onclick = () => { setActiveRepoById(r.id); renderRepoSelect(); loadFolder(""); overlay.remove(); };
        const del = document.createElement("button"); del.textContent = "Excluir"; del.style.padding = "6px"; del.style.borderRadius = "6px";
        del.onclick = () => { const idx = lst.findIndex(x=>x.id===r.id); if (idx>=0) { lst.splice(idx,1); saveRepoList(lst); renderListArea(); renderRepoSelect(); } };
        controls.appendChild(toggle); controls.appendChild(setActiveBtn); controls.appendChild(del);
        row.appendChild(label); row.appendChild(controls); listArea.appendChild(row);
      }
      if ((lst||[]).length === 0) listArea.innerHTML = "<div style='opacity:0.8'>Nenhum repositório adicionado.</div>";
    }
    renderListArea();

    const input = box.querySelector("#gdjs-repo-input");
    const addBtn = box.querySelector("#gdjs-repo-add");
    addBtn.onclick = () => {
      const v = input.value.trim();
      if (!v) return;
      const parsed = parseRepoInput(v);
      if (!parsed) { alert("Formato inválido"); return; }
      const list = loadRepoList();
      const entry = { id: makeRepoId(), name: parsed.owner? (parsed.owner + "/" + parsed.repo + (parsed.branch? "@" + parsed.branch : "")) : (parsed.manifestUrl || v), owner: parsed.owner||"", repo: parsed.repo||"", branch: parsed.branch||"main", manifestUrl: parsed.manifestUrl||null, enabled: true };
      list.push(entry); saveRepoList(list); input.value = ""; renderListArea(); renderRepoSelect();
    };

    box.querySelector("#gdjs-repo-close").onclick = () => overlay.remove();
  }

  // --- CACHE manager modal ---
  function showCacheManager() {
    const overlay = document.createElement("div");
    Object.assign(overlay.style, { position: "fixed", left: "0", top: "0", right: "0", bottom: "0", background: "rgba(0,0,0,0.6)", zIndex: 10000000, display: "flex", alignItems: "center", justifyContent: "center" });
    const box = document.createElement("div");
    Object.assign(box.style, { width: "760px", maxHeight: "80vh", overflowY: "auto", background: "#0f0f10", borderRadius: "8px", padding: "12px", boxShadow: "0 12px 40px rgba(0,0,0,0.6)", color: "#eee" });
    box.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><div style="font-weight:700">Cache de Músicas</div><div style="margin-left:auto;font-size:13px;opacity:0.85">Gerencie músicas baixadas</div></div>
      <div id="gdjs-cache-list" style="margin-top:10px"></div>
      <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end">
        <button id="gdjs-cache-clear" style="padding:8px;border-radius:6px">Limpar Tudo</button>
        <button id="gdjs-cache-close" style="padding:8px;border-radius:6px">Fechar</button>
      </div>`;
    overlay.appendChild(box); document.body.appendChild(overlay);

    const listArea = box.querySelector("#gdjs-cache-list");
    function renderCache() {
      const keys = Object.keys(window.gdjsCustomAudio || {});
      listArea.innerHTML = "";
      if (!keys || keys.length === 0) { listArea.innerHTML = "<div style='opacity:0.8'>Nenhuma música em cache.</div>"; return; }
      for (const k of keys) {
        const row = document.createElement("div");
        Object.assign(row.style, { display: "flex", gap: "8px", alignItems: "center", padding: "8px", borderRadius: "6px", marginBottom: "6px", background: "linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))" });
        const label = document.createElement("div"); label.style.flex = "1"; label.innerHTML = `<div style="font-weight:600">${k}</div><div style="font-size:12px;opacity:0.8">${Object.keys((window.gdjsCustomAudio[k] && window.gdjsCustomAudio[k].audios) || {}).length} audios • ${Object.keys((window.gdjsCustomAudio[k] && window.gdjsCustomAudio[k].rawFiles) || {}).length} jsons</div>`;
        const btns = document.createElement("div"); btns.style.display = "flex"; btns.style.gap = "6px";
        const del = document.createElement("button"); del.textContent = "Deletar"; del.style.padding = "6px"; del.style.borderRadius = "6px";
        del.onclick = () => { delete window.gdjsCustomAudio[k]; try { /* revoke blobs if any */ } catch(e){} renderCache(); };
        const openBtn = document.createElement("button"); openBtn.textContent = "Abrir pasta"; openBtn.style.padding = "6px"; openBtn.style.borderRadius = "6px";
        openBtn.onclick = () => { showCacheDetails(k); };
        btns.appendChild(openBtn); btns.appendChild(del);
        row.appendChild(label); row.appendChild(btns); listArea.appendChild(row);
      }
    }

    function showCacheDetails(key) {
      const data = window.gdjsCustomAudio && window.gdjsCustomAudio[key];
      const modal = document.createElement("div");
      Object.assign(modal.style, { position: "fixed", left: "0", top: "0", right: "0", bottom: "0", background: "rgba(0,0,0,0.6)", zIndex: 10000001, display: "flex", alignItems: "center", justifyContent: "center" });
      const b = document.createElement("div"); Object.assign(b.style, { width: "720px", maxHeight: "80vh", overflowY: "auto", background: "#0f0f10", borderRadius: "8px", padding: "12px", color: "#eee" });
      b.innerHTML = `<div style="font-weight:700;margin-bottom:8px">${key}</div><div id="gdjs-cache-detail-list" style="display:flex;flex-direction:column;gap:6px"></div><div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px"><button id="gdjs-cache-detail-close" style="padding:8px;border-radius:6px">Fechar</button></div>`;
      modal.appendChild(b); document.body.appendChild(modal);
      const listEl = b.querySelector("#gdjs-cache-detail-list");
      const audios = (data && data.audios) ? Object.keys(data.audios) : [];
      const raws = (data && data.rawFiles) ? Object.keys(data.rawFiles) : [];
      if (audios.length === 0 && raws.length === 0) listEl.innerHTML = "<div style='opacity:0.8'>Vazio</div>";
      for (const a of audios) {
        const row = document.createElement("div"); row.style.display = "flex"; row.style.justifyContent = "space-between"; row.style.alignItems = "center";
        row.innerHTML = `<div>${a}</div>`;
        const btn = document.createElement("button"); btn.textContent = "Deletar"; btn.style.padding = "6px"; btn.style.borderRadius = "6px";
        btn.onclick = () => { try { delete data.audios[a]; } catch(e){} row.remove(); };
        row.appendChild(btn); listEl.appendChild(row);
      }
      for (const r of raws) {
        const row = document.createElement("div"); row.style.display = "flex"; row.style.justifyContent = "space-between"; row.style.alignItems = "center";
        row.innerHTML = `<div>${r}</div>`;
        const btn = document.createElement("button"); btn.textContent = "Deletar"; btn.style.padding = "6px"; btn.style.borderRadius = "6px";
        btn.onclick = () => { try { delete data.rawFiles[r]; } catch(e){} row.remove(); };
        row.appendChild(btn); listEl.appendChild(row);
      }
      b.querySelector("#gdjs-cache-detail-close").onclick = () => modal.remove();
    }

    box.querySelector("#gdjs-cache-clear").onclick = () => {
      if (!confirm("Deletar todo o cache de músicas?")) return;
      try { window.gdjsCustomAudio = {}; } catch(e){}
      renderCache();
    };

    box.querySelector("#gdjs-cache-close").onclick = () => overlay.remove();

    renderCache();
  }

  // --- rendering of mods (left) and songs (right) ---
  function renderModsList(items) {
    leftPane.innerHTML = "";
    modElementMap = {};
    // Insert Favorites fake item as first entry
    const favCount = (favorites || []).length;
    const favRow = document.createElement("div");
    Object.assign(favRow.style, {
      padding: "10px",
      borderRadius: "8px",
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      gap: "8px",
      marginBottom: "8px",
      cursor: "pointer",
      background: "linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))"
    });
    const leftFav = document.createElement("div"); leftFav.style.display = "flex"; leftFav.style.flexDirection = "column"; leftFav.innerHTML = `<div style="font-weight:600">Favorites</div><div style="font-size:12px;opacity:0.8">${favCount} músicas</div>`;
    favRow.appendChild(leftFav);
    favRow.onclick = ()=> openMod("__favorites__");
    leftPane.appendChild(favRow);
    modElementMap["__favorites__"] = { element: favRow, data: { name: "Favorites", path: "__favorites__" } };

    if (!items || items.length === 0) { const e = document.createElement("div"); e.textContent = "Nenhum mod encontrado."; e.style.opacity = "0.8"; leftPane.appendChild(e); return; }
    for (const item of items) {
      const row = document.createElement("div");
      Object.assign(row.style, {
        padding: "10px",
        borderRadius: "8px",
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        gap: "8px",
        marginBottom: "8px",
        cursor: "pointer",
        background: "linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))",
        transition: "transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease"
      });

      // hover animation (lift + scale + subtle shadow)
      row.addEventListener('mouseenter', ()=> {
        try {
          row.style.transform = "translateY(-4px) scale(1.02)";
          row.style.boxShadow = "0 10px 30px rgba(0,0,0,0.45)";
          row.style.background = "linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.008))";
        } catch(e){}
      });
      row.addEventListener('mouseleave', ()=> {
        try {
          row.style.transform = "translateY(0) scale(1)";
          row.style.boxShadow = "none";
          row.style.background = "linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))";
        } catch(e){}
      });

      const left = document.createElement("div"); left.style.display = "flex"; left.style.flexDirection = "column"; left.innerHTML = `<div style="font-weight:600">${item.name}</div>`;
      row.appendChild(left);

      row.onclick = ()=> openMod(item.path);

      leftPane.appendChild(row);
      modElementMap[item.path] = { element: row, data: item };
    }
  }

  function renderSongsList(items) {
    rightPane.innerHTML = "";
    songElementMap = {};
    if (!items || items.length === 0) { const e = document.createElement("div"); e.textContent = "Selecione um mod à esquerda."; e.style.opacity = "0.8"; rightPane.appendChild(e); return; }
    for (const item of items) {
      const row = document.createElement("div");
      Object.assign(row.style, { padding: "10px", borderRadius: "8px", display: "flex", justifyContent: "space-between", alignItems: "center", gap: "8px", marginBottom: "8px", background: "linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))" });
      // left column: name only (removed path below name)
      const left = document.createElement("div"); left.style.display = "flex"; left.style.flexDirection = "column"; left.innerHTML = `<div style="font-weight:600">${item.name}</div>`;
      const right = document.createElement("div"); right.style.display = "flex"; right.style.gap = "8px"; right.style.alignItems = "center";
      // star favorite icon
      const favIcon = document.createElement("div");
      favIcon.textContent = isFavorite(item.path) ? "★" : "☆";
      favIcon.title = isFavorite(item.path) ? "Remover dos favoritos" : "Adicionar aos favoritos";
      Object.assign(favIcon.style, { cursor: "pointer", fontSize: "18px", userSelect: "none" });
      favIcon.onclick = (ev) => { ev.stopPropagation(); toggleFavorite(item.path, item.name); };
      // action buttons container
      const checkBtn = document.createElement("button"); checkBtn.textContent = "Checando..."; checkBtn.disabled = true; checkBtn.style.padding="6px"; checkBtn.style.borderRadius="6px";
      right.appendChild(favIcon);
      right.appendChild(checkBtn);
      row.appendChild(left); row.appendChild(right); rightPane.appendChild(row);
      songElementMap[item.path] = { element: row, data: item, rightContainer: right, placeholderBtn: checkBtn, name: item.name, favIcon: favIcon };
    }
    startBackgroundCheckOnSongs(items);
  }

  // --- background check ---
  let bgController = null;
  const hasSubCache = {};

  function startBackgroundCheckOnSongs(items) {
    if (bgController && typeof bgController.abort === "function") try { bgController.abort(); } catch(e){}
    bgController = { aborted:false, abort(){ this.aborted=true; } };
    const list = items || [];
    const concurrency = 3;
    let idx = 0;
    const activeRepo = getActiveRepo();

    async function worker() {
      while(!bgController.aborted) {
        if (idx >= list.length) break;
        const p = list[idx++].path;
        try {
          if (typeof hasSubCache[p] !== "undefined") { updateButtonsForDecisionFromCache(p, hasSubCache[p]); await sleep(0); continue; }
          const manifest = await loadManifestPreferLocalFor(activeRepo, window.runtimeScene || undefined);
          let hasSubdirs = false;
          
          if (manifest && manifest.hasOwnProperty(p)) {
            const baseUrl = getBaseUrl(manifest);
            const parsed = parseManifestEntry(manifest[p], baseUrl, p);
            
            if (parsed && (parsed.type === 'subdirs' || (parsed.type === 'folder' && parsed.subdirs && parsed.subdirs.length > 0))) {
              hasSubdirs = true;
            } else {
              hasSubdirs = false;
            }
          } else {
            // Se não está no manifest, tenta GitHub API
            try {
              const api = await ghListForFolderUsingEntry(activeRepo, p).catch(()=>[]);
              hasSubdirs = Array.isArray(api) && api.some(x=>x.type==="dir");
            } catch(e) {
              hasSubdirs = false;
            }
          }
          
          hasSubCache[p] = hasSubdirs;
          updateButtonsForDecisionFromCache(p, hasSubdirs);
        } catch(e){}
        await sleep(40);
      }
    }
    for (let i=0;i<concurrency;i++) worker();
  }

  function updateButtonsForDecisionFromCache(path, hasSubdirs) {
    const el = songElementMap[path];
    if (!el) return;
    const right = el.rightContainer; right.innerHTML = "";
    const itemName = el.name || path.split("/").pop();

    // favorite icon (recreate to keep consistent)
    const favIcon = document.createElement("div");
    favIcon.textContent = isFavorite(path) ? "★" : "☆";
    favIcon.title = isFavorite(path) ? "Remover dos favoritos" : "Adicionar aos favoritos";
    Object.assign(favIcon.style, { cursor: "pointer", fontSize: "18px", userSelect: "none" });
    favIcon.onclick = (ev) => { ev.stopPropagation(); toggleFavorite(path, itemName); };

    if (hasSubdirs) {
      const pickBtn = document.createElement("button"); pickBtn.textContent = "Selecionar difficulty"; pickBtn.style.padding="6px"; pickBtn.style.borderRadius="6px";
      pickBtn.onclick = async ()=>{ 
        try {
          setStatus("Carregando difficulties de " + itemName + "...");
          const activeRepo = getActiveRepo();
          const subdirs = await fetchSubdirsUsingEntry(activeRepo, path);
          if (!subdirs || subdirs.length === 0) { setStatus("Nenhuma difficulty encontrada."); return; }
          showDifficultyChooser(path, subdirs);
          setStatus("");
        } catch(e){ setStatus("Erro listando difficulties."); }
      };
      right.appendChild(favIcon);
      right.appendChild(pickBtn);
    } else {
      const dlBtn = document.createElement("button"); dlBtn.textContent = "Selecionar e baixar"; dlBtn.style.padding="6px"; dlBtn.style.borderRadius="6px";
      dlBtn.onclick = ()=> downloadSongFolder(path);
      right.appendChild(favIcon);
      right.appendChild(dlBtn);
    }
    // update map ref
    if (songElementMap[path]) songElementMap[path].favIcon = favIcon;
  }

  async function fetchSubdirsUsingEntry(entry, folderPath) {
    try {
      const manifest = await loadManifestPreferLocalFor(entry, window.runtimeScene || undefined);
      if (manifest && manifest.hasOwnProperty(folderPath)) {
        const baseUrl = getBaseUrl(manifest);
        const parsed = parseManifestEntry(manifest[folderPath], baseUrl, folderPath);
        if (parsed && parsed.type === 'subdirs') {
          return parsed.value.slice();
        } else if (parsed && parsed.type === 'folder' && parsed.subdirs) {
          return parsed.subdirs.slice();
        }
      }
    } catch(e){}
    try {
      const api = await ghListForFolderUsingEntry(entry, folderPath);
      const dirs = (api || []).filter(i=> i.type === "dir").map(i=> i.name);
      return dirs;
    } catch(e){ return []; }
  }

  async function loadFolder(path="") {
    try {
      setStatus("Carregando pasta...");
      const activeRepo = getActiveRepo();
      for (const d of (modsList||[])) delete hasSubCache[d.path];
      const manifest = await loadManifestPreferLocalFor(activeRepo, window.runtimeScene || undefined);
      let items = [];
      if (manifest && manifest.hasOwnProperty(path)) {
        const baseUrl = getBaseUrl(manifest);
        const parsed = parseManifestEntry(manifest[path], baseUrl, path);
        if (parsed && (parsed.type === 'subdirs' || (parsed.type === 'folder' && parsed.subdirs))) {
          const subdirs = parsed.type === 'subdirs' ? parsed.value : parsed.subdirs;
          items = subdirs.map(name => ({ name, path: (path? path + "/" + name : name), type: "dir" }));
        }
      } else {
        try {
          const api = await ghListForFolderUsingEntry(activeRepo, path);
          items = (api || []).filter(it => it.type === "dir").map(it => ({ name: it.name, path: it.path, type: "dir" }));
        } catch(e){
          items = [];
        }
      }
      modsList = items || [];
      currentModPath = "";
      renderModsList(modsList);
      renderSongsList([]);
      setStatus(((path||"Mods")) + ` — ${modsList.length} pastas`);
      setTimeout(()=> startBackgroundCheckOnSongs(modsList), 10);
      // update saved favorites variable in runtime scene
      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("FavoriteSongs").setString(JSON.stringify(favorites || [])); } catch(e){}
    } catch (err) {
      modsList = []; renderModsList(modsList);
      setStatus("Erro carregando pasta: " + (err && err.message ? err.message : err));
    }
  }

  async function openMod(path) {
    try {
      setStatus("Abrindo " + path + "...");
      currentModPath = path;

      // Special handling for Favorites
      if (path === "__favorites__") {
        const items = (favorites || []).map(f => ({ name: f.name || basenameNoExt(f.path.split("/").pop()||f.path), path: f.path }));
        songsList = items;
        renderSongsList(songsList);
        setStatus(`Favorites — ${songsList.length} músicas`);
        return;
      }

      const activeRepo = getActiveRepo();
      const manifest = await loadManifestPreferLocalFor(activeRepo, window.runtimeScene || undefined);
      let items = [];
      if (manifest && manifest.hasOwnProperty(path)) {
        const baseUrl = getBaseUrl(manifest);
        const parsed = parseManifestEntry(manifest[path], baseUrl, path);
        if (parsed && (parsed.type === 'subdirs' || (parsed.type === 'folder' && parsed.subdirs))) {
          const subdirs = parsed.type === 'subdirs' ? parsed.value : parsed.subdirs;
          items = subdirs.map(name => ({ name, path: (path? path + "/" + name : name), type: "dir" }));
        } else if (parsed && parsed.type === 'files') {
          // If manifest path directly lists files, treat each file as an item (name = filename, path = path/filename)
          items = (parsed.value || []).map(f => ({ name: f.name, path: (path? path + "/" + f.name : f.name) }));
        }
      } else {
        try {
          const api = await ghListForFolderUsingEntry(activeRepo, path);
          items = (api || []).filter(it => it.type === "dir").map(it => ({ name: it.name, path: it.path, type: "dir" }));
        } catch(e){ items = []; }
      }
      songsList = items || [];
      renderSongsList(songsList);
      setStatus(`${path} — ${songsList.length} músicas`);
    } catch(e){
      setStatus("Erro ao abrir mod: " + (e && e.message ? e.message : e));
    }
  }

  // --- FUNÇÕES DE DOWNLOAD CORRIGIDAS ---
  async function getFilesFromManifest(path) {
    try {
      const activeRepo = getActiveRepo();
      const manifest = await loadManifestPreferLocalFor(activeRepo, window.runtimeScene || undefined);
      if (!manifest || !manifest.hasOwnProperty(path)) return null;
      
      const baseUrl = getBaseUrl(manifest);
      const parsed = parseManifestEntry(manifest[path], baseUrl, path);
      
      if (!parsed) return null;
      
      if (parsed.type === 'files') {
        return parsed.value;
      } else if (parsed.type === 'folder' && parsed.files) {
        return parsed.files;
      }
      
      return null;
    } catch(e){}
    return null;
  }

  async function audioListFromManifestPath(p) {
    try {
      const files = await getFilesFromManifest(p);
      if (!files) return [];
      return files.filter(e => isAudioFile(e.name)).map(e => ({ 
        name: e.name, 
        url: e.url 
      }));
    } catch(e){}
    return [];
  }

  function stopAndCleanupPrevious(options){
    options = options || {};
    const revokeBlobUrls = options.revokeBlobUrls === true;
    try {
      if (window.gdjsChannels) {
        Object.keys(window.gdjsChannels).forEach(k=>{
          try {
            const a = window.gdjsChannels[k];
            if (!a) return;
            try { a.pause(); } catch(e){}
            try { a.currentTime = 0; } catch(e){}
            if (a._gdjs_ended_handler) { try { a.removeEventListener('ended', a._gdjs_ended_handler); } catch(e){} a._gdjs_ended_handler = null; }
            try { if (revokeBlobUrls && a.src && a.src.startsWith('blob:')) URL.revokeObjectURL(a.src); } catch(e){}
          } catch(e){}
        });
      }

      if (window.gdjsCustomAudio) {
        Object.keys(window.gdjsCustomAudio).forEach(folder=>{
          try {
            const entry = window.gdjsCustomAudio[folder] || {};
            const audios = entry.audios || {};
            Object.keys(audios).forEach(name=>{
              try {
                const info = audios[name] || {};
                if (info && info.blobUrl && revokeBlobUrls) {
                  try { URL.revokeObjectURL(info.blobUrl); } catch(e){}
                }
              } catch(e){}
            });
            try { delete window.gdjsCustomAudio[folder]; } catch(e){}
          } catch(e){}
        });
      }

      window.gdjsChannels = {};
    } catch(e){}
  }

  async function findAudioFilesWithFallback(rootFolder, difficultyPath) {
    const activeRepo = getActiveRepo();
    const manifest = await loadManifestPreferLocalFor(activeRepo, window.runtimeScene || undefined);

    async function audioListFromManifestPathLocal(p) {
      try {
        const files = await getFilesFromManifest(p);
        if (!files) return [];
        return files.filter(e => isAudioFile(e.name)).map(e => ({ name: e.name, url: e.url }));
      } catch(e){}
      return [];
    }

    async function audioListFromGithubPath(p) {
      try {
        const api = await ghListForFolderUsingEntry(activeRepo, p).catch(()=>[]);
        return (api || []).filter(i => i.type !== "dir" && isAudioFile(i.name)).map(i => ({ name: i.name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`) }));
      } catch(e){}
      return [];
    }

    // 1. Primeiro tenta na pasta da difficulty
    try {
      let list = await audioListFromManifestPathLocal(difficultyPath);
      if (list && list.length>0) return list;
      list = await audioListFromGithubPath(difficultyPath);
      if (list && list.length>0) return list;
    } catch(e){}

    // 2. Se não achou, tenta na pasta da música (rootFolder)
    try {
      let list = await audioListFromManifestPathLocal(rootFolder);
      if (list && list.length>0) return list;
      list = await audioListFromGithubPath(rootFolder);
      if (list && list.length>0) return list;
    } catch(e){}

    // 3. Se não achou, tenta na pasta do mod (pai da rootFolder)
    try {
      const parts = (rootFolder || "").split("/").filter(Boolean);
      if (parts.length >= 2) {
        const modFolder = parts.slice(0, parts.length - 1).join("/");
        if (modFolder) {
          let list = await audioListFromManifestPathLocal(modFolder);
          if (list && list.length>0) return list;
          list = await audioListFromGithubPath(modFolder);
          if (list && list.length>0) return list;
        }
      }
    } catch(e){}
    
    return [];
  }

  async function downloadDifficultyKeepAudioRoot(rootFolder, difficultyName) {
    const difficultyPath = (rootFolder? rootFolder + "/" + difficultyName : difficultyName);
    try { btnClose.disabled = true; } catch(e){}
    try {
      stopAndCleanupPrevious({ revokeBlobUrls: true });

      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("selectedTrackKey").setString(rootFolder); } catch(e){}
      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("SongName").setString(basenameNoExt(rootFolder.split("/").pop()||rootFolder)); } catch(e){}

      setStatus("Listando arquivos (procura áudios: difficulty -> song -> mod)...");

      const audioFiles = await findAudioFilesWithFallback(rootFolder, difficultyPath);

      let chartFiles = [];
      const activeRepo = getActiveRepo();
      const files = await getFilesFromManifest(difficultyPath);
      if (files) {
        chartFiles = files.filter(e => isJsonFile(e.name)).map(e => ({ name: e.name, url: e.url }) );
      } else {
        try {
          const api = await ghListForFolderUsingEntry(activeRepo, difficultyPath);
          chartFiles = (api || []).filter(i => i.type !== "dir" && isJsonFile(i.name)).map(i => ({ name: i.name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`) })); 
        } catch(e){}
      }

      let rootJsons = [];
      const rootFiles = await getFilesFromManifest(rootFolder);
      if (rootFiles) {
        rootJsons = rootFiles.filter(e => isJsonFile(e.name)).map(e => ({ name: e.name, url: e.url }) );
      } else {
        try {
          const api = await ghListForFolderUsingEntry(activeRepo, rootFolder);
          rootJsons = (api || []).filter(i => i.type !== "dir" && isJsonFile(i.name)).map(i => ({ name: i.name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`) })); 
        } catch(e){}
      }

      const allJsonsMap = {};
      rootJsons.forEach(j => { allJsonsMap[j.name] = j; });
      chartFiles.forEach(j => { allJsonsMap[j.name] = j; });

      window.gdjsCustomAudio = window.gdjsCustomAudio || {};
      window.gdjsCustomAudio[rootFolder] = window.gdjsCustomAudio[rootFolder] || { audios: {}, rawFiles: {} };
      const dest = window.gdjsCustomAudio[rootFolder];

      let nextChannelIndex = 0;
      const unlockQueue = [];
      for (const f of (audioFiles || [])) {
        try {
          setStatus("Baixando áudio: " + f.name + "...");
          const resp = await fetch(f.url);
          if (!resp.ok) continue;
          const blob = await resp.blob();
          const blobUrl = URL.createObjectURL(blob);
          const audioEl = new Audio(blobUrl);
          audioEl.preload = "auto"; audioEl.crossOrigin = "anonymous"; audioEl.loop = false;
          dest.audios[f.name] = { blobUrl, audioEl };
          window.gdjsChannels[nextChannelIndex] = audioEl;
          nextChannelIndex++;
          try {
            const p = audioEl.play();
            if (p && typeof p.then === "function") {
              p.then(()=>{ try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }).catch(()=>{ unlockQueue.push({audioEl, name: f.name}); });
            } else { try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }
          } catch(e){ unlockQueue.push({audioEl, name: f.name}); }
        } catch(e){}
        await sleep(0);
      }

      for (const name in allJsonsMap) {
        try {
          const j = allJsonsMap[name];
          setStatus("Baixando chart: " + name + "...");
          const r = await fetch(j.url);
          if (!r.ok) continue;
          const txt = await r.text();
          const key = difficultyName + "/" + name;
          dest.rawFiles[key] = txt;
          const lname = name.toLowerCase();
          const gg = (window.runtimeScene && window.runtimeScene.getGame) ? runtimeScene.getGame().getVariables() : null;
          if (gg) {
            if (/metadata|meta/.test(lname)) gg.get("metadatajson").setString(txt);
            else if (/(bf|chartbf|chart_bf)/.test(lname)) gg.get("BfChartJsonLoader").setString(txt);
            else if (/(dad|opp|opponent)/.test(lname)) gg.get("OppChartJsonLoader").setString(txt);
            else {
              try {
                const parsed = JSON.parse(txt);
                if (parsed && parsed.notes) {
                  if (!gg.get("BfChartJsonLoader").getAsString()) gg.get("BfChartJsonLoader").setString(txt);
                  else if (!gg.get("OppChartJsonLoader").getAsString()) gg.get("OppChartJsonLoader").setString(txt);
                  else if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                } else {
                  if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                }
              } catch(e){
                if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
              }
            }
          }
        } catch(e){}
        await sleep(0);
      }

      if (unlockQueue.length > 0) {
        const unlock = async () => { for (const it of unlockQueue) { try { await it.audioEl.play(); it.audioEl.pause(); it.audioEl.currentTime = 0; } catch(e){} } window.removeEventListener('pointerdown', unlock); };
        window.addEventListener('pointerdown', unlock, { once: true });
      }

      setStatus('Download concluído para "' + rootFolder + '" (difficulty: ' + difficultyName + ').');
    } catch(e){
      setStatus("Erro ao baixar: " + (e && e.message ? e.message : e));
    } finally {
      try { btnClose.disabled = false; } catch(e){}
    }
  }

  async function downloadAllDifficulties(rootFolder, subdirs) {
    try { btnClose.disabled = true; } catch(e){}
    try {
      stopAndCleanupPrevious({ revokeBlobUrls: true });
      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("selectedTrackKey").setString(rootFolder); } catch(e){}
      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("SongName").setString(basenameNoExt(rootFolder.split("/").pop()||rootFolder)); } catch(e){}

      setStatus("Procurando áudios (difficulty -> song -> mod)...");
      const hintDifficulty = (subdirs && subdirs.length>0) ? (rootFolder + "/" + subdirs[0]) : rootFolder;
      const audioFiles = await findAudioFilesWithFallback(rootFolder, hintDifficulty);

      window.gdjsCustomAudio = window.gdjsCustomAudio || {};
      window.gdjsCustomAudio[rootFolder] = window.gdjsCustomAudio[rootFolder] || { audios: {}, rawFiles: {} };
      const dest = window.gdjsCustomAudio[rootFolder];
      let nextChannelIndex = 0;
      const unlockQueue = [];
      for (const f of (audioFiles || [])) {
        try {
          setStatus("Baixando áudio: " + f.name + "...");
          const resp = await fetch(f.url);
          if (!resp.ok) continue;
          const blob = await resp.blob();
          const blobUrl = URL.createObjectURL(blob);
          const audioEl = new Audio(blobUrl);
          audioEl.preload = "auto"; audioEl.crossOrigin = "anonymous"; audioEl.loop = false;
          dest.audios[f.name] = { blobUrl, audioEl };
          window.gdjsChannels[nextChannelIndex] = audioEl;
          nextChannelIndex++;
          try {
            const p = audioEl.play();
            if (p && typeof p.then === "function") {
              p.then(()=>{ try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }).catch(()=>{ unlockQueue.push({audioEl, name: f.name}); });
            } else { try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }
          } catch(e){ unlockQueue.push({audioEl, name: f.name}); }
        } catch(e){}
        await sleep(0);
      }

      const activeRepo = getActiveRepo();
      for (const d of subdirs) {
        try {
          setStatus("Baixando charts: " + d + " ...");
          let chartFiles = [];
          const difficultyPath = (rootFolder? rootFolder + "/" + d : d);
          const files = await getFilesFromManifest(difficultyPath);
          if (files) {
            chartFiles = files.filter(e => isJsonFile(e.name)).map(e => ({ name: e.name, url: e.url }) );
          } else {
            try {
              const api = await ghListForFolderUsingEntry(activeRepo, difficultyPath);
              chartFiles = (api || []).filter(i => i.type !== "dir" && isJsonFile(i.name)).map(i => ({ name: i.name, url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`) })); 
            } catch(e){}
          }
          for (const j of chartFiles) {
            try {
              const r = await fetch(j.url);
              if (!r.ok) continue;
              const txt = await r.text();
              const key = d + "/" + j.name;
              dest.rawFiles[key] = txt;
              const lname = j.name.toLowerCase();
              const gg = (window.runtimeScene && window.runtimeScene.getGame) ? runtimeScene.getGame().getVariables() : null;
              if (gg) {
                if (/metadata|meta/.test(lname)) gg.get("metadatajson").setString(txt);
                else if (/(bf|chartbf|chart_bf)/.test(lname)) gg.get("BfChartJsonLoader").setString(txt);
                else if (/(dad|opp|opponent)/.test(lname)) gg.get("OppChartJsonLoader").setString(txt);
                else {
                  try {
                    const parsed = JSON.parse(txt);
                    if (parsed && parsed.notes) {
                      if (!gg.get("BfChartJsonLoader").getAsString()) gg.get("BfChartJsonLoader").setString(txt);
                      else if (!gg.get("OppChartJsonLoader").getAsString()) gg.get("OppChartJsonLoader").setString(txt);
                      else if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                    } else {
                      if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                    }
                  } catch(e){
                    if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                  }
                }
              }
            } catch(e){}
            await sleep(0);
          }
        } catch(e){}
      }

      if (unlockQueue.length > 0) {
        const unlock = async () => { for (const it of unlockQueue) { try { await it.audioEl.play(); it.audioEl.pause(); it.audioEl.currentTime = 0; } catch(e){} } window.removeEventListener('pointerdown', unlock); };
        window.addEventListener('pointerdown', unlock, { once: true });
      }

      setStatus('Download concluído para "' + rootFolder + '" (todas difficulties).');
    } catch(e){
      setStatus("Erro ao baixar: " + (e && e.message ? e.message : e));
    } finally {
      try { btnClose.disabled = false; } catch(e){}
    }
  }

  async function downloadSongFolder(folderPath) {
    try { btnClose.disabled = true; } catch(e){}
    try {
      stopAndCleanupPrevious({ revokeBlobUrls: true });

      setStatus("Listando arquivos em " + folderPath + "...");

      let files = await getFilesFromManifest(folderPath);

      if (!files) {
        // Fallback para GitHub API
        const activeRepo = getActiveRepo();
        try {
          const apiList = await ghListForFolderUsingEntry(activeRepo, folderPath);
          files = (apiList || []).map(i => ({ 
            name: i.name, 
            url: i.download_url || (`https://cdn.jsdelivr.net/gh/${activeRepo.owner}/${activeRepo.repo}@${activeRepo.branch}/${i.path}`), 
            type: i.type 
          }));
          files = files.filter(x => x.type !== "dir");
        } catch(e){
          files = [];
        }
      }

      if (!Array.isArray(files) || files.length === 0) { setStatus("Pasta vazia."); return; }

      window.gdjsCustomAudio = window.gdjsCustomAudio || {};
      window.gdjsCustomAudio[folderPath] = window.gdjsCustomAudio[folderPath] || {audios:{}, rawFiles:{}}; 
      const dest = window.gdjsCustomAudio[folderPath];

      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("selectedTrackKey").setString(folderPath); } catch(e){}
      try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("SongName").setString(basenameNoExt(folderPath.split("/").pop()||folderPath)); } catch(e){}

      const totalFiles = files.length;
      let processed = 0;
      let nextChannelIndex = (window.gdjsChannels) ? Object.keys(window.gdjsChannels).length : 0;
      const unlockQueue = [];

      for (const f of files) {
        processed++; setStatus(`${processed} / ${totalFiles}`);
        const fname = f.name;
        const url = f.url;
        if (!url) continue;

        if (isJsonFile(fname)) {
          try {
            const txtResp = await fetch(url);
            if (txtResp.ok) {
              const txt = await txtResp.text();
              dest.rawFiles[fname] = txt;
              const lname = fname.toLowerCase();
              const gg = (window.runtimeScene && window.runtimeScene.getGame) ? runtimeScene.getGame().getVariables() : null;
              if (gg) {
                if (/metadata|meta/.test(lname)) gg.get("metadatajson").setString(txt);
                else if (/(bf|chartbf|chart_bf)/.test(lname)) gg.get("BfChartJsonLoader").setString(txt);
                else if (/(dad|opp|opponent)/.test(lname)) gg.get("OppChartJsonLoader").setString(txt);
                else {
                  try {
                    const parsed = JSON.parse(txt);
                    if (parsed && parsed.notes) {
                      if (!gg.get("BfChartJsonLoader").getAsString()) gg.get("BfChartJsonLoader").setString(txt);
                      else if (!gg.get("OppChartJsonLoader").getAsString()) gg.get("OppChartJsonLoader").setString(txt);
                      else if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                    } else {
                      if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                    }
                  } catch(e) {
                    if (!gg.get("metadatajson").getAsString()) gg.get("metadatajson").setString(txt);
                  }
                }
              }
            }
          } catch(e){}
        } else if (isAudioFile(fname)) {
          try {
            setStatus("Baixando áudio: " + fname + "...");
            const resp = await fetch(url);
            if (!resp.ok) continue;
            const blob = await resp.blob();
            const blobUrl = URL.createObjectURL(blob);
            const audioEl = new Audio(blobUrl);
            audioEl.preload = "auto"; audioEl.crossOrigin = "anonymous"; audioEl.loop = false;
            dest.audios[fname] = { blobUrl, audioEl, audioElRef: audioEl };
            window.gdjsChannels = window.gdjsChannels || {};
            window.gdjsChannels[nextChannelIndex] = audioEl;
            nextChannelIndex++;
            try {
              const p = audioEl.play();
              if (p && typeof p.then === "function") {
                p.then(()=>{ try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }).catch(()=>{ unlockQueue.push({audioEl, name: fname}); });
              } else { try{ audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }
            } catch(e){ unlockQueue.push({audioEl, name: fname}); }
            try { const gg = (window.runtimeScene && window.runtimeScene.getGame) ? runtimeScene.getGame().getVariables() : null; if (gg && !gg.get("SongName").getAsString()) gg.get("SongName").setString(basenameNoExt(fname)); } catch(e){}
          } catch(e){}
        }
        await sleep(0);
      }

      if (unlockQueue.length > 0) {
        const unlock = async () => { for (const it of unlockQueue) { try { await it.audioEl.play(); it.audioEl.pause(); it.audioEl.currentTime = 0; } catch(e){} } window.removeEventListener('pointerdown', unlock); };
        window.addEventListener('pointerdown', unlock, { once: true });
      }

      setStatus('Download concluído para "' + folderPath + '".');
    } catch(e){
      setStatus("Erro ao baixar pasta: " + (e && e.message ? e.message : e));
    } finally {
      try { btnClose.disabled = false; } catch(e){}
    }
  }

  // --- difficulty chooser modal ---
  function showDifficultyChooser(rootFolder, subdirs) {
    const overlay = document.createElement("div");
    Object.assign(overlay.style, { position: "fixed", left: "0", top: "0", right: "0", bottom: "0", background: "rgba(0,0,0,0.6)", zIndex: 10000010, display: "flex", alignItems: "center", justifyContent: "center", pointerEvents: "auto" });
    const box = document.createElement("div");
    Object.assign(box.style, { width: "420px", maxHeight: "70vh", overflowY: "auto", background: "#0f0f10", borderRadius: "8px", padding: "12px", boxShadow: "0 12px 40px rgba(0,0,0,0.6)", color: "#eee" });
    box.innerHTML = `<div style="font-weight:700;margin-bottom:8px">Escolha uma difficulty para:</div><div style="margin-bottom:8px;color:#bbb">${rootFolder}</div>`;
    const list = document.createElement("div"); list.style.display = "flex"; list.style.flexDirection = "column"; list.style.gap = "6px";
    for (const d of subdirs) {
      const b = document.createElement("button");
      b.textContent = d;
      b.style.padding="8px"; b.style.borderRadius="6px";
      b.onclick = ()=> { overlay.remove(); downloadDifficultyKeepAudioRoot(rootFolder, d); };
      list.appendChild(b);
    }
    const cancel = document.createElement("button"); cancel.textContent = "Cancelar"; cancel.style.marginTop="10px"; cancel.style.padding="8px"; cancel.style.borderRadius="6px";
    cancel.onclick = ()=> overlay.remove();
    box.appendChild(list); box.appendChild(cancel);
    overlay.appendChild(box);
    document.body.appendChild(overlay);
    setTimeout(()=> { try { overlay.focus(); } catch(e){} }, 0);
  }

  // --- events wiring ---
  btnClose.onclick = ()=> container.remove();
  btnManage.onclick = ()=> showRepoManagerModal();
  btnCache.onclick = ()=> showCacheManager();
  btnRefresh.onclick = async ()=> {
    try { setStatus("Atualizando..."); } catch(e){}
    try { for (const it of modsList) delete hasSubCache[it.path]; } catch(e){}
    try { Object.keys(_manifest_cache_by_repo).forEach(k=> delete _manifest_cache_by_repo[k]); } catch(e){}

    // guarda qual mod estava aberto antes do refresh
    const prevOpen = currentModPath;

    // Recarrega a lista raiz (evita transformar songs em mods)
    await loadFolder("");

    // tenta reabrir o mod antigo (se ainda existir)
    try {
      if (prevOpen && prevOpen === "__favorites__") {
        openMod("__favorites__");
      } else if (prevOpen) {
        // pequeno delay para garantir que modsList foi populada
        setTimeout(()=>{
          try {
            const found = modsList.find(m => m.path === prevOpen);
            if (found) openMod(prevOpen);
          } catch(e){}
        }, 60);
      }
    } catch(e){}
  };

  // Substitua o handler de troca de repo (repoSelect.onchange) por este
  repoSelect.onchange = ()=> {
    try { setActiveRepoById(repoSelect.value); } catch(e){}
    try { Object.keys(_manifest_cache_by_repo).forEach(k=> delete _manifest_cache_by_repo[k]); } catch(e){}
    const prevOpen = currentModPath;
    // recarrega raiz e tenta reabrir o mod (se existir)
    loadFolder("").then(()=>{
      try {
        if (prevOpen && prevOpen === "__favorites__") {
          openMod("__favorites__");
        } else if (prevOpen) {
          const found = modsList.find(m => m.path === prevOpen);
          if (found) openMod(prevOpen);
        }
      } catch(e){}
    }).catch(()=>{});
  };

  // SEARCH: agora impacta ambas as listas
  searchInput.addEventListener("input", ()=> {
    const q = searchInput.value.trim().toLowerCase();
    if (!q) {
      renderModsList(modsList);
      setStatus((currentModPath||"Mods")+` — ${modsList.length} pastas`);
      // if a mod is open, re-open it to show all songs
      if (currentModPath) {
        if (currentModPath === "__favorites__") openMod("__favorites__");
        else openMod(currentModPath);
      } else {
        renderSongsList([]);
      }
      setTimeout(()=> startBackgroundCheckOnSongs(modsList), 10);
      return;
    }
    // filter mods by name
    const filteredMods = modsList.filter(it => (it.name || "").toLowerCase().includes(q));
    renderModsList(filteredMods);
    // also filter songs: if a mod is selected, filter its songs; if favorites selected, filter favorites
    if (currentModPath === "__favorites__") {
      const favItems = (favorites || []).map(f => ({ name: f.name || basenameNoExt(f.path.split("/").pop()||f.path), path: f.path }));
      const filteredSongs = favItems.filter(s => (s.name || "").toLowerCase().includes(q));
      renderSongsList(filteredSongs);
      setStatus(`Resultado: ${filteredSongs.length} / ${favItems.length} (favorites)`);
    } else if (currentModPath) {
      // filter songsList (if current open)
      const filteredSongs = (songsList || []).filter(s => (s.name || "").toLowerCase().includes(q));
      renderSongsList(filteredSongs);
      setStatus(`Resultado: ${filteredSongs.length} / ${songsList.length}`);
      setTimeout(()=> startBackgroundCheckOnSongs(filteredSongs), 10);
    } else {
      // no mod open: just inform mods results
      setStatus(`Resultado: ${filteredMods.length} / ${modsList.length} pastas`);
    }
  });

  (function init() {
    const list = loadRepoList();
    if (!list || list.length === 0) { saveRepoList([defaultRepoEntry()]); }
    renderRepoSelect();
    loadFolder("");
    // expose runtimeScene if exists
    try { if (typeof runtimeScene !== "undefined") window.runtimeScene = runtimeScene; } catch(e){}
    // push favorites to runtime variable on init
    try { if (window.runtimeScene && window.runtimeScene.getGame) runtimeScene.getGame().getVariables().get("FavoriteSongs").setString(JSON.stringify(favorites || [])); } catch(e){}
  })();

})();

};
gdjs.PlayonlineCode.eventsList7 = function(runtimeScene) {

{


gdjs.PlayonlineCode.userFunc0x1a78378(runtimeScene);

}


};gdjs.PlayonlineCode.mapOfGDgdjs_9546PlayonlineCode_9546GDStartObjects1Objects = Hashtable.newFrom({"Start": gdjs.PlayonlineCode.GDStartObjects1});
gdjs.PlayonlineCode.eventsList8 = function(runtimeScene) {

{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.evtTools.runtimeScene.sceneJustBegins(runtimeScene);
if (isConditionTrue_0) {
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(27));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(28));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(29));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(30));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(31));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(32));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(33));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(34));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(25));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(59));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(57));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(88).getChild("BestScore"));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(88).getChild("SongsBestScore"));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(88).getChild("Points"));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(88).getChild("PointsMessage"));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(88).getChild("Pfcs"));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(61).getChild(4));
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(57));
}
{gdjs.evtTools.runtimeScene.prioritizeLoadingOfScene(runtimeScene, "Play");
}
{runtimeScene.getGame().getVariables().getFromIndex(9).setNumber(1);
}
{gdjs.multiplayerVariablesManager.disableVariableSynchronization(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(14));
}
{gdjs.multiplayerVariablesManager.setPlayerVariableOwnership(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(7), 2);
}
{gdjs.multiplayerVariablesManager.setPlayerVariableOwnership(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(8), 2);
}
{gdjs.multiplayerVariablesManager.setPlayerVariableOwnership(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(5), 1);
}
{gdjs.multiplayerVariablesManager.setPlayerVariableOwnership(runtimeScene, runtimeScene.getGame().getVariables().getFromIndex(6), 1);
}

{ //Subevents
gdjs.PlayonlineCode.eventsList1(runtimeScene);} //End of subevents
}

}


{

gdjs.copyArray(runtimeScene.getObjects("Join"), gdjs.PlayonlineCode.GDJoinObjects1);

let isConditionTrue_0 = false;
isConditionTrue_0 = false;
for (var i = 0, k = 0, l = gdjs.PlayonlineCode.GDJoinObjects1.length;i<l;++i) {
    if ( gdjs.PlayonlineCode.GDJoinObjects1[i].IsClicked(null) ) {
        isConditionTrue_0 = true;
        gdjs.PlayonlineCode.GDJoinObjects1[k] = gdjs.PlayonlineCode.GDJoinObjects1[i];
        ++k;
    }
}
gdjs.PlayonlineCode.GDJoinObjects1.length = k;
if (isConditionTrue_0) {
isConditionTrue_0 = false;
{isConditionTrue_0 = runtimeScene.getOnceTriggers().triggerOnce(35508020);
}
}
if (isConditionTrue_0) {

{ //Subevents
gdjs.PlayonlineCode.eventsList2(runtimeScene);} //End of subevents
}

}


{

gdjs.copyArray(runtimeScene.getObjects("Join2"), gdjs.PlayonlineCode.GDJoin2Objects1);

let isConditionTrue_0 = false;
isConditionTrue_0 = false;
for (var i = 0, k = 0, l = gdjs.PlayonlineCode.GDJoin2Objects1.length;i<l;++i) {
    if ( gdjs.PlayonlineCode.GDJoin2Objects1[i].IsClicked(null) ) {
        isConditionTrue_0 = true;
        gdjs.PlayonlineCode.GDJoin2Objects1[k] = gdjs.PlayonlineCode.GDJoin2Objects1[i];
        ++k;
    }
}
gdjs.PlayonlineCode.GDJoin2Objects1.length = k;
if (isConditionTrue_0) {
isConditionTrue_0 = false;
{isConditionTrue_0 = runtimeScene.getOnceTriggers().triggerOnce(35510484);
}
}
if (isConditionTrue_0) {

{ //Subevents
gdjs.PlayonlineCode.eventsList3(runtimeScene);} //End of subevents
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isLobbyGameRunning();
if (isConditionTrue_0) {
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isPlayerConnected(2);
if (isConditionTrue_0) {
isConditionTrue_0 = false;
{isConditionTrue_0 = runtimeScene.getOnceTriggers().triggerOnce(35503268);
}
}
}
if (isConditionTrue_0) {
gdjs.copyArray(runtimeScene.getObjects("Player1text"), gdjs.PlayonlineCode.GDPlayer1textObjects1);
gdjs.copyArray(runtimeScene.getObjects("Player2text"), gdjs.PlayonlineCode.GDPlayer2textObjects1);
{for(var i = 0, len = gdjs.PlayonlineCode.GDPlayer1textObjects1.length ;i < len;++i) {
    gdjs.PlayonlineCode.GDPlayer1textObjects1[i].getBehavior("Text").setText(gdjs.multiplayer.getPlayerUsername(1) + gdjs.evtTools.string.newLine() + "v");
}
}
{for(var i = 0, len = gdjs.PlayonlineCode.GDPlayer2textObjects1.length ;i < len;++i) {
    gdjs.PlayonlineCode.GDPlayer2textObjects1[i].getBehavior("Text").setText(gdjs.multiplayer.getPlayerUsername(2) + gdjs.evtTools.string.newLine() + "v");
}
}

{ //Subevents
gdjs.PlayonlineCode.eventsList4(runtimeScene);} //End of subevents
}

}


{


let isConditionTrue_0 = false;
{
{runtimeScene.getGame().getVariables().getFromIndex(8).setString(runtimeScene.getGame().getVariables().getFromIndex(7).getAsString());
}
{runtimeScene.getGame().getVariables().getFromIndex(6).setString(runtimeScene.getGame().getVariables().getFromIndex(5).getAsString());
}
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isLobbyGameRunning();
if (isConditionTrue_0) {
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isPlayerConnected(2);
if (isConditionTrue_0) {
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isCurrentPlayerHost();
}
}
if (isConditionTrue_0) {
{runtimeScene.getGame().getVariables().getFromIndex(16).setNumber(1);
}
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isLobbyGameRunning();
if (isConditionTrue_0) {
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isPlayerConnected(2);
if (isConditionTrue_0) {
isConditionTrue_0 = false;
isConditionTrue_0 = !(gdjs.multiplayer.isCurrentPlayerHost());
}
}
if (isConditionTrue_0) {
{runtimeScene.getGame().getVariables().getFromIndex(16).setNumber(2);
}
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.evtTools.runtimeScene.sceneJustBegins(runtimeScene);
if (isConditionTrue_0) {

{ //Subevents
gdjs.PlayonlineCode.eventsList5(runtimeScene);} //End of subevents
}

}


{

gdjs.copyArray(runtimeScene.getObjects("Hard"), gdjs.PlayonlineCode.GDHardObjects1);

let isConditionTrue_0 = false;
isConditionTrue_0 = false;
for (var i = 0, k = 0, l = gdjs.PlayonlineCode.GDHardObjects1.length;i<l;++i) {
    if ( gdjs.PlayonlineCode.GDHardObjects1[i].getBehavior("MultitouchButton").IsJustPressed(null) ) {
        isConditionTrue_0 = true;
        gdjs.PlayonlineCode.GDHardObjects1[k] = gdjs.PlayonlineCode.GDHardObjects1[i];
        ++k;
    }
}
gdjs.PlayonlineCode.GDHardObjects1.length = k;
if (isConditionTrue_0) {
isConditionTrue_0 = false;
{isConditionTrue_0 = runtimeScene.getOnceTriggers().triggerOnce(35519668);
}
}
if (isConditionTrue_0) {

{ //Subevents
gdjs.PlayonlineCode.eventsList6(runtimeScene);} //End of subevents
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isLobbyGameRunning();
if (isConditionTrue_0) {
isConditionTrue_0 = false;
isConditionTrue_0 = !(gdjs.multiplayer.isPlayerConnected(2));
}
if (isConditionTrue_0) {
{gdjs.multiplayer.endLobbyGame();
}
}

}


{

gdjs.copyArray(runtimeScene.getObjects("selesongtext"), gdjs.PlayonlineCode.GDselesongtextObjects1);

let isConditionTrue_0 = false;
isConditionTrue_0 = false;
for (var i = 0, k = 0, l = gdjs.PlayonlineCode.GDselesongtextObjects1.length;i<l;++i) {
    if ( gdjs.PlayonlineCode.GDselesongtextObjects1[i].getBehavior("ButtonFSM").IsClicked(null) ) {
        isConditionTrue_0 = true;
        gdjs.PlayonlineCode.GDselesongtextObjects1[k] = gdjs.PlayonlineCode.GDselesongtextObjects1[i];
        ++k;
    }
}
gdjs.PlayonlineCode.GDselesongtextObjects1.length = k;
if (isConditionTrue_0) {
isConditionTrue_0 = false;
{isConditionTrue_0 = runtimeScene.getOnceTriggers().triggerOnce(35521804);
}
}
if (isConditionTrue_0) {

{ //Subevents
gdjs.PlayonlineCode.eventsList7(runtimeScene);} //End of subevents
}

}


{



}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayer.isCurrentPlayerHost();
if (isConditionTrue_0) {
isConditionTrue_0 = false;
{isConditionTrue_0 = runtimeScene.getOnceTriggers().triggerOnce(35523564);
}
}
if (isConditionTrue_0) {
gdjs.PlayonlineCode.GDStartObjects1.length = 0;

{gdjs.evtTools.object.createObjectOnScene(runtimeScene, gdjs.PlayonlineCode.mapOfGDgdjs_9546PlayonlineCode_9546GDStartObjects1Objects, 3058, 651, "");
}
}

}


{


let isConditionTrue_0 = false;
{
gdjs.copyArray(runtimeScene.getObjects("songselectedtext"), gdjs.PlayonlineCode.GDsongselectedtextObjects1);
{for(var i = 0, len = gdjs.PlayonlineCode.GDsongselectedtextObjects1.length ;i < len;++i) {
    gdjs.PlayonlineCode.GDsongselectedtextObjects1[i].getBehavior("Text").setText("Song Selected: " + runtimeScene.getGame().getVariables().getFromIndex(4).getAsString());
}
}
}

}


{



}


{

gdjs.copyArray(runtimeScene.getObjects("Start"), gdjs.PlayonlineCode.GDStartObjects1);

let isConditionTrue_0 = false;
isConditionTrue_0 = false;
for (var i = 0, k = 0, l = gdjs.PlayonlineCode.GDStartObjects1.length;i<l;++i) {
    if ( gdjs.PlayonlineCode.GDStartObjects1[i].IsClicked(null) ) {
        isConditionTrue_0 = true;
        gdjs.PlayonlineCode.GDStartObjects1[k] = gdjs.PlayonlineCode.GDStartObjects1[i];
        ++k;
    }
}
gdjs.PlayonlineCode.GDStartObjects1.length = k;
if (isConditionTrue_0) {
isConditionTrue_0 = false;
{isConditionTrue_0 = (runtimeScene.getGame().getVariables().getFromIndex(4).getAsString() != "None");
}
}
if (isConditionTrue_0) {
{gdjs.evtTools.runtimeScene.replaceScene(runtimeScene, "Play", false);
}
}

}


{


let isConditionTrue_0 = false;
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.multiplayerMessageManager.hasAnyPlayerJustLeft();
if (isConditionTrue_0) {
isConditionTrue_0 = false;
isConditionTrue_0 = gdjs.evtTools.camera.getCameraX(runtimeScene, "", 0) == 2220 + 960;
}
if (isConditionTrue_0) {
{gdjs.evtTools.camera.setCameraX(runtimeScene, 960, "", 0);
}
}

}


{

gdjs.copyArray(runtimeScene.getObjects("PauseButton"), gdjs.PlayonlineCode.GDPauseButtonObjects1);

let isConditionTrue_0 = false;
isConditionTrue_0 = false;
for (var i = 0, k = 0, l = gdjs.PlayonlineCode.GDPauseButtonObjects1.length;i<l;++i) {
    if ( gdjs.PlayonlineCode.GDPauseButtonObjects1[i].getBehavior("ButtonFSM").IsClicked(null) ) {
        isConditionTrue_0 = true;
        gdjs.PlayonlineCode.GDPauseButtonObjects1[k] = gdjs.PlayonlineCode.GDPauseButtonObjects1[i];
        ++k;
    }
}
gdjs.PlayonlineCode.GDPauseButtonObjects1.length = k;
if (isConditionTrue_0) {
{gdjs.evtTools.runtimeScene.replaceScene(runtimeScene, "Inicio", false);
}
}

}


};

gdjs.PlayonlineCode.func = function(runtimeScene) {
runtimeScene.getOnceTriggers().startNewFrame();

gdjs.PlayonlineCode.GDJoinObjects1.length = 0;
gdjs.PlayonlineCode.GDJoinObjects2.length = 0;
gdjs.PlayonlineCode.GDJoinObjects3.length = 0;
gdjs.PlayonlineCode.GDbackObjects1.length = 0;
gdjs.PlayonlineCode.GDbackObjects2.length = 0;
gdjs.PlayonlineCode.GDbackObjects3.length = 0;
gdjs.PlayonlineCode.GDBFObjects1.length = 0;
gdjs.PlayonlineCode.GDBFObjects2.length = 0;
gdjs.PlayonlineCode.GDBFObjects3.length = 0;
gdjs.PlayonlineCode.GDPlayer2textObjects1.length = 0;
gdjs.PlayonlineCode.GDPlayer2textObjects2.length = 0;
gdjs.PlayonlineCode.GDPlayer2textObjects3.length = 0;
gdjs.PlayonlineCode.GDPlayer1textObjects1.length = 0;
gdjs.PlayonlineCode.GDPlayer1textObjects2.length = 0;
gdjs.PlayonlineCode.GDPlayer1textObjects3.length = 0;
gdjs.PlayonlineCode.GDselesongtextObjects1.length = 0;
gdjs.PlayonlineCode.GDselesongtextObjects2.length = 0;
gdjs.PlayonlineCode.GDselesongtextObjects3.length = 0;
gdjs.PlayonlineCode.GDsongselectedtextObjects1.length = 0;
gdjs.PlayonlineCode.GDsongselectedtextObjects2.length = 0;
gdjs.PlayonlineCode.GDsongselectedtextObjects3.length = 0;
gdjs.PlayonlineCode.GDStartObjects1.length = 0;
gdjs.PlayonlineCode.GDStartObjects2.length = 0;
gdjs.PlayonlineCode.GDStartObjects3.length = 0;
gdjs.PlayonlineCode.GDBFPixelObjects1.length = 0;
gdjs.PlayonlineCode.GDBFPixelObjects2.length = 0;
gdjs.PlayonlineCode.GDBFPixelObjects3.length = 0;
gdjs.PlayonlineCode.GDHardObjects1.length = 0;
gdjs.PlayonlineCode.GDHardObjects2.length = 0;
gdjs.PlayonlineCode.GDHardObjects3.length = 0;
gdjs.PlayonlineCode.GDBackObjects1.length = 0;
gdjs.PlayonlineCode.GDBackObjects2.length = 0;
gdjs.PlayonlineCode.GDBackObjects3.length = 0;
gdjs.PlayonlineCode.GDJoin2Objects1.length = 0;
gdjs.PlayonlineCode.GDJoin2Objects2.length = 0;
gdjs.PlayonlineCode.GDJoin2Objects3.length = 0;
gdjs.PlayonlineCode.GDStatisticsObjects1.length = 0;
gdjs.PlayonlineCode.GDStatisticsObjects2.length = 0;
gdjs.PlayonlineCode.GDStatisticsObjects3.length = 0;
gdjs.PlayonlineCode.GDComboNumbersObjects1.length = 0;
gdjs.PlayonlineCode.GDComboNumbersObjects2.length = 0;
gdjs.PlayonlineCode.GDComboNumbersObjects3.length = 0;
gdjs.PlayonlineCode.GDNotesSplashObjects1.length = 0;
gdjs.PlayonlineCode.GDNotesSplashObjects2.length = 0;
gdjs.PlayonlineCode.GDNotesSplashObjects3.length = 0;
gdjs.PlayonlineCode.GDfpsObjects1.length = 0;
gdjs.PlayonlineCode.GDfpsObjects2.length = 0;
gdjs.PlayonlineCode.GDfpsObjects3.length = 0;
gdjs.PlayonlineCode.GDEngineTextObjects1.length = 0;
gdjs.PlayonlineCode.GDEngineTextObjects2.length = 0;
gdjs.PlayonlineCode.GDEngineTextObjects3.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollBFObjects1.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollBFObjects2.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollBFObjects3.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects1.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects2.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects3.length = 0;
gdjs.PlayonlineCode.GDHitboxLeftObjects1.length = 0;
gdjs.PlayonlineCode.GDHitboxLeftObjects2.length = 0;
gdjs.PlayonlineCode.GDHitboxLeftObjects3.length = 0;
gdjs.PlayonlineCode.GDHitboxDownObjects1.length = 0;
gdjs.PlayonlineCode.GDHitboxDownObjects2.length = 0;
gdjs.PlayonlineCode.GDHitboxDownObjects3.length = 0;
gdjs.PlayonlineCode.GDHitboxUpObjects1.length = 0;
gdjs.PlayonlineCode.GDHitboxUpObjects2.length = 0;
gdjs.PlayonlineCode.GDHitboxUpObjects3.length = 0;
gdjs.PlayonlineCode.GDhitrightObjects1.length = 0;
gdjs.PlayonlineCode.GDhitrightObjects2.length = 0;
gdjs.PlayonlineCode.GDhitrightObjects3.length = 0;
gdjs.PlayonlineCode.GDBFIconObjects1.length = 0;
gdjs.PlayonlineCode.GDBFIconObjects2.length = 0;
gdjs.PlayonlineCode.GDBFIconObjects3.length = 0;
gdjs.PlayonlineCode.GDPauseButtonObjects1.length = 0;
gdjs.PlayonlineCode.GDPauseButtonObjects2.length = 0;
gdjs.PlayonlineCode.GDPauseButtonObjects3.length = 0;
gdjs.PlayonlineCode.GDPauseButton2Objects1.length = 0;
gdjs.PlayonlineCode.GDPauseButton2Objects2.length = 0;
gdjs.PlayonlineCode.GDPauseButton2Objects3.length = 0;
gdjs.PlayonlineCode.GDBlackScreenObjects1.length = 0;
gdjs.PlayonlineCode.GDBlackScreenObjects2.length = 0;
gdjs.PlayonlineCode.GDBlackScreenObjects3.length = 0;
gdjs.PlayonlineCode.GDPauseTextObjects1.length = 0;
gdjs.PlayonlineCode.GDPauseTextObjects2.length = 0;
gdjs.PlayonlineCode.GDPauseTextObjects3.length = 0;
gdjs.PlayonlineCode.GDExitTextObjects1.length = 0;
gdjs.PlayonlineCode.GDExitTextObjects2.length = 0;
gdjs.PlayonlineCode.GDExitTextObjects3.length = 0;
gdjs.PlayonlineCode.GDRestartTextObjects1.length = 0;
gdjs.PlayonlineCode.GDRestartTextObjects2.length = 0;
gdjs.PlayonlineCode.GDRestartTextObjects3.length = 0;
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects1.length = 0;
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects2.length = 0;
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects3.length = 0;
gdjs.PlayonlineCode.GDBfUpNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDBfUpNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDBfUpNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDBfDownNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDBfDownNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDBfDownNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDBfLeftNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDBfLeftNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDBfLeftNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDBfRightNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDBfRightNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDBfRightNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDOppIconObjects1.length = 0;
gdjs.PlayonlineCode.GDOppIconObjects2.length = 0;
gdjs.PlayonlineCode.GDOppIconObjects3.length = 0;
gdjs.PlayonlineCode.GDtimerBarObjects1.length = 0;
gdjs.PlayonlineCode.GDtimerBarObjects2.length = 0;
gdjs.PlayonlineCode.GDtimerBarObjects3.length = 0;
gdjs.PlayonlineCode.GDtimeObjects1.length = 0;
gdjs.PlayonlineCode.GDtimeObjects2.length = 0;
gdjs.PlayonlineCode.GDtimeObjects3.length = 0;
gdjs.PlayonlineCode.GDtimerBar2Objects1.length = 0;
gdjs.PlayonlineCode.GDtimerBar2Objects2.length = 0;
gdjs.PlayonlineCode.GDtimerBar2Objects3.length = 0;
gdjs.PlayonlineCode.GDRatinsPopUpObjects1.length = 0;
gdjs.PlayonlineCode.GDRatinsPopUpObjects2.length = 0;
gdjs.PlayonlineCode.GDRatinsPopUpObjects3.length = 0;
gdjs.PlayonlineCode.GDLongNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDLongNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDLongNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDnotesObjects1.length = 0;
gdjs.PlayonlineCode.GDnotesObjects2.length = 0;
gdjs.PlayonlineCode.GDnotesObjects3.length = 0;
gdjs.PlayonlineCode.GDOppLeftNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDOppLeftNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDOppLeftNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDOppDownNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDOppDownNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDOppDownNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDOppUpNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDOppUpNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDOppUpNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDOppRightNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDOppRightNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDOppRightNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDLongNoteOppObjects1.length = 0;
gdjs.PlayonlineCode.GDLongNoteOppObjects2.length = 0;
gdjs.PlayonlineCode.GDLongNoteOppObjects3.length = 0;
gdjs.PlayonlineCode.GDStatistics2Objects1.length = 0;
gdjs.PlayonlineCode.GDStatistics2Objects2.length = 0;
gdjs.PlayonlineCode.GDStatistics2Objects3.length = 0;

gdjs.PlayonlineCode.eventsList8(runtimeScene);
gdjs.PlayonlineCode.GDJoinObjects1.length = 0;
gdjs.PlayonlineCode.GDJoinObjects2.length = 0;
gdjs.PlayonlineCode.GDJoinObjects3.length = 0;
gdjs.PlayonlineCode.GDbackObjects1.length = 0;
gdjs.PlayonlineCode.GDbackObjects2.length = 0;
gdjs.PlayonlineCode.GDbackObjects3.length = 0;
gdjs.PlayonlineCode.GDBFObjects1.length = 0;
gdjs.PlayonlineCode.GDBFObjects2.length = 0;
gdjs.PlayonlineCode.GDBFObjects3.length = 0;
gdjs.PlayonlineCode.GDPlayer2textObjects1.length = 0;
gdjs.PlayonlineCode.GDPlayer2textObjects2.length = 0;
gdjs.PlayonlineCode.GDPlayer2textObjects3.length = 0;
gdjs.PlayonlineCode.GDPlayer1textObjects1.length = 0;
gdjs.PlayonlineCode.GDPlayer1textObjects2.length = 0;
gdjs.PlayonlineCode.GDPlayer1textObjects3.length = 0;
gdjs.PlayonlineCode.GDselesongtextObjects1.length = 0;
gdjs.PlayonlineCode.GDselesongtextObjects2.length = 0;
gdjs.PlayonlineCode.GDselesongtextObjects3.length = 0;
gdjs.PlayonlineCode.GDsongselectedtextObjects1.length = 0;
gdjs.PlayonlineCode.GDsongselectedtextObjects2.length = 0;
gdjs.PlayonlineCode.GDsongselectedtextObjects3.length = 0;
gdjs.PlayonlineCode.GDStartObjects1.length = 0;
gdjs.PlayonlineCode.GDStartObjects2.length = 0;
gdjs.PlayonlineCode.GDStartObjects3.length = 0;
gdjs.PlayonlineCode.GDBFPixelObjects1.length = 0;
gdjs.PlayonlineCode.GDBFPixelObjects2.length = 0;
gdjs.PlayonlineCode.GDBFPixelObjects3.length = 0;
gdjs.PlayonlineCode.GDHardObjects1.length = 0;
gdjs.PlayonlineCode.GDHardObjects2.length = 0;
gdjs.PlayonlineCode.GDHardObjects3.length = 0;
gdjs.PlayonlineCode.GDBackObjects1.length = 0;
gdjs.PlayonlineCode.GDBackObjects2.length = 0;
gdjs.PlayonlineCode.GDBackObjects3.length = 0;
gdjs.PlayonlineCode.GDJoin2Objects1.length = 0;
gdjs.PlayonlineCode.GDJoin2Objects2.length = 0;
gdjs.PlayonlineCode.GDJoin2Objects3.length = 0;
gdjs.PlayonlineCode.GDStatisticsObjects1.length = 0;
gdjs.PlayonlineCode.GDStatisticsObjects2.length = 0;
gdjs.PlayonlineCode.GDStatisticsObjects3.length = 0;
gdjs.PlayonlineCode.GDComboNumbersObjects1.length = 0;
gdjs.PlayonlineCode.GDComboNumbersObjects2.length = 0;
gdjs.PlayonlineCode.GDComboNumbersObjects3.length = 0;
gdjs.PlayonlineCode.GDNotesSplashObjects1.length = 0;
gdjs.PlayonlineCode.GDNotesSplashObjects2.length = 0;
gdjs.PlayonlineCode.GDNotesSplashObjects3.length = 0;
gdjs.PlayonlineCode.GDfpsObjects1.length = 0;
gdjs.PlayonlineCode.GDfpsObjects2.length = 0;
gdjs.PlayonlineCode.GDfpsObjects3.length = 0;
gdjs.PlayonlineCode.GDEngineTextObjects1.length = 0;
gdjs.PlayonlineCode.GDEngineTextObjects2.length = 0;
gdjs.PlayonlineCode.GDEngineTextObjects3.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollBFObjects1.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollBFObjects2.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollBFObjects3.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects1.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects2.length = 0;
gdjs.PlayonlineCode.GDLongUpscrollOPPObjects3.length = 0;
gdjs.PlayonlineCode.GDHitboxLeftObjects1.length = 0;
gdjs.PlayonlineCode.GDHitboxLeftObjects2.length = 0;
gdjs.PlayonlineCode.GDHitboxLeftObjects3.length = 0;
gdjs.PlayonlineCode.GDHitboxDownObjects1.length = 0;
gdjs.PlayonlineCode.GDHitboxDownObjects2.length = 0;
gdjs.PlayonlineCode.GDHitboxDownObjects3.length = 0;
gdjs.PlayonlineCode.GDHitboxUpObjects1.length = 0;
gdjs.PlayonlineCode.GDHitboxUpObjects2.length = 0;
gdjs.PlayonlineCode.GDHitboxUpObjects3.length = 0;
gdjs.PlayonlineCode.GDhitrightObjects1.length = 0;
gdjs.PlayonlineCode.GDhitrightObjects2.length = 0;
gdjs.PlayonlineCode.GDhitrightObjects3.length = 0;
gdjs.PlayonlineCode.GDBFIconObjects1.length = 0;
gdjs.PlayonlineCode.GDBFIconObjects2.length = 0;
gdjs.PlayonlineCode.GDBFIconObjects3.length = 0;
gdjs.PlayonlineCode.GDPauseButtonObjects1.length = 0;
gdjs.PlayonlineCode.GDPauseButtonObjects2.length = 0;
gdjs.PlayonlineCode.GDPauseButtonObjects3.length = 0;
gdjs.PlayonlineCode.GDPauseButton2Objects1.length = 0;
gdjs.PlayonlineCode.GDPauseButton2Objects2.length = 0;
gdjs.PlayonlineCode.GDPauseButton2Objects3.length = 0;
gdjs.PlayonlineCode.GDBlackScreenObjects1.length = 0;
gdjs.PlayonlineCode.GDBlackScreenObjects2.length = 0;
gdjs.PlayonlineCode.GDBlackScreenObjects3.length = 0;
gdjs.PlayonlineCode.GDPauseTextObjects1.length = 0;
gdjs.PlayonlineCode.GDPauseTextObjects2.length = 0;
gdjs.PlayonlineCode.GDPauseTextObjects3.length = 0;
gdjs.PlayonlineCode.GDExitTextObjects1.length = 0;
gdjs.PlayonlineCode.GDExitTextObjects2.length = 0;
gdjs.PlayonlineCode.GDExitTextObjects3.length = 0;
gdjs.PlayonlineCode.GDRestartTextObjects1.length = 0;
gdjs.PlayonlineCode.GDRestartTextObjects2.length = 0;
gdjs.PlayonlineCode.GDRestartTextObjects3.length = 0;
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects1.length = 0;
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects2.length = 0;
gdjs.PlayonlineCode.GDmisses_9595challenge_9595textObjects3.length = 0;
gdjs.PlayonlineCode.GDBfUpNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDBfUpNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDBfUpNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDBfDownNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDBfDownNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDBfDownNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDBfLeftNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDBfLeftNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDBfLeftNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDBfRightNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDBfRightNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDBfRightNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDOppIconObjects1.length = 0;
gdjs.PlayonlineCode.GDOppIconObjects2.length = 0;
gdjs.PlayonlineCode.GDOppIconObjects3.length = 0;
gdjs.PlayonlineCode.GDtimerBarObjects1.length = 0;
gdjs.PlayonlineCode.GDtimerBarObjects2.length = 0;
gdjs.PlayonlineCode.GDtimerBarObjects3.length = 0;
gdjs.PlayonlineCode.GDtimeObjects1.length = 0;
gdjs.PlayonlineCode.GDtimeObjects2.length = 0;
gdjs.PlayonlineCode.GDtimeObjects3.length = 0;
gdjs.PlayonlineCode.GDtimerBar2Objects1.length = 0;
gdjs.PlayonlineCode.GDtimerBar2Objects2.length = 0;
gdjs.PlayonlineCode.GDtimerBar2Objects3.length = 0;
gdjs.PlayonlineCode.GDRatinsPopUpObjects1.length = 0;
gdjs.PlayonlineCode.GDRatinsPopUpObjects2.length = 0;
gdjs.PlayonlineCode.GDRatinsPopUpObjects3.length = 0;
gdjs.PlayonlineCode.GDLongNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDLongNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDLongNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDnotesObjects1.length = 0;
gdjs.PlayonlineCode.GDnotesObjects2.length = 0;
gdjs.PlayonlineCode.GDnotesObjects3.length = 0;
gdjs.PlayonlineCode.GDOppLeftNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDOppLeftNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDOppLeftNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDOppDownNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDOppDownNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDOppDownNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDOppUpNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDOppUpNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDOppUpNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDOppRightNoteObjects1.length = 0;
gdjs.PlayonlineCode.GDOppRightNoteObjects2.length = 0;
gdjs.PlayonlineCode.GDOppRightNoteObjects3.length = 0;
gdjs.PlayonlineCode.GDLongNoteOppObjects1.length = 0;
gdjs.PlayonlineCode.GDLongNoteOppObjects2.length = 0;
gdjs.PlayonlineCode.GDLongNoteOppObjects3.length = 0;
gdjs.PlayonlineCode.GDStatistics2Objects1.length = 0;
gdjs.PlayonlineCode.GDStatistics2Objects2.length = 0;
gdjs.PlayonlineCode.GDStatistics2Objects3.length = 0;


return;

}

gdjs['PlayonlineCode'] = gdjs.PlayonlineCode;
